<!doctype html>
<html lang="pl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title data-i18n="dash.page_title">Rider-PC — mini dashboard</title>
<link rel="stylesheet" href="/web/assets/dashboard-common.css">
<style>
  body{margin:0;background:#0e1a24;color:#d7e2ee;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  .wrap{max-width:1180px;margin:28px auto;padding:0 18px}
  h1{font-size:28px;margin:0 0 8px}
  .hint{opacity:.6;font-size:12px;margin-bottom:18px}
  .grid{display:grid;grid-template-columns:repeat(4,1fr);gap:18px}
  .card{background:#0f2233;border:1px solid #1d3548;border-radius:12px;padding:14px;box-shadow:0 2px 10px rgba(0,0,0,.25)}
  .card h3{margin:0 0 10px;font-size:16px;color:#9cc8ff}
  .kv{display:grid;grid-template-columns:1fr auto;gap:6px 10px;font-size:13px}
  .kv div{opacity:.9}
  .ok{color:#5fe39a} .bad{color:#ff6b6b} .muted{opacity:.6}
  canvas{width:100%;height:140px;background:#0c1b28;border-radius:8px;border:1px solid #1d3548}
  a{color:#87b7ff}

  .legend{display:flex;gap:14px;margin-top:6px;font-size:12px;opacity:.8;flex-wrap:wrap}
  .dot{display:inline-block;width:8px;height:8px;border-radius:50%;margin-right:6px;vertical-align:middle}
  .cpu{background:#6db3ff}.mem{background:#ffd36d}
  .raw{background:#6db3ff}.proc{background:#ffd36d}.obst{background:#9be3b0}.edge{background:#6db3ff}

  .thumb{background:#0c1b28;border:1px solid #1d3548;border-radius:10px;padding:8px}
  .thumb img{display:block;width:100%;height:auto;border-radius:6px}
  .thumb.blank{background:#000;border-color:#222}
  @media (max-width:980px){.grid{grid-template-columns:1fr}}

  .cam-badge{display:inline-block;padding:2px 8px;border-radius:999px;font-size:12px;margin-left:8px;border:1px solid #2b5577;background:#11263a;color:#b7cee3}
  .cam-badge.on{border-color:#2d6a4f;color:#9be3b0;background:#103226}
  .cam-img{width:100%;height:auto;border-radius:10px;border:1px solid #1d3548;background:#0c1b28;aspect-ratio:16/9;object-fit:cover}

  .statusbar{position:sticky;bottom:-1px;margin-top:18px;background:#0f2233;border:1px solid #1d3548;border-radius:10px;padding:10px 12px;display:flex;gap:14px;align-items:center;flex-wrap:wrap;font-size:13px;box-shadow:0 2px 10px rgba(0,0,0,.25)}
  .pill{padding:2px 10px;border-radius:999px;border:1px solid #2b5577;background:#11263a;color:#b7cee3}
  .pill.ok{border-color:#2d6a4f;background:#103226;color:#9be3b0}
  .pill.bad{border-color:#7a2b2b;background:#2a1212;color:#ff9f9f}
  .sep{opacity:.4}
</style>
</head>
<body data-page="view">
<div data-dashboard-menu-target></div>
<div class="wrap">
  <h1 class="page-title" data-i18n="dash.page_title">Rider-PC — mini dashboard</h1>
  <div class="hint">
    <span data-i18n="dash.hint_prefix">Auto-refresh co ≈ 2 s.</span>
    <span data-i18n="dash.hint_endpoints">Endpointy:</span>
    <a href="/healthz">/healthz</a>, <a href="/state">/state</a>, <a href="/sysinfo">/sysinfo</a>, <a href="/vision/snap-info">/vision/snap-info</a>
  </div>

  <!-- RZĄD 1 -->
  <div class="grid">
    <div class="card">
      <h3 data-i18n="dash.system.title">System</h3>
      <div class="kv">
        <div data-i18n="dash.system.cpu_est">cpu (szac.)</div><div id="ci_cpu" class="muted">—</div>
        <div data-i18n="dash.system.load">load (1/5/15)</div><div id="ci_load" class="muted">—</div>
        <div data-i18n="dash.system.mem">pamięć</div><div id="ci_mem" class="muted">—</div>
        <div data-i18n="dash.system.disk">dysk</div><div id="ci_disk" class="muted">—</div>
        <div data-i18n="dash.system.os">os</div><div id="ci_os" class="muted">—</div>
        <div data-i18n="dash.system.fw">fw</div><div id="ci_fw" class="muted">—</div>
      </div>
    </div>

    <div class="card">
      <h3 data-i18n="dash.devices.title">Urządzenia</h3>
      <div class="kv">
        <div data-i18n="dash.devices.camera">kamera</div><div id="d_cam" class="muted">—</div>
        <div data-i18n="dash.devices.lcd">lcd</div><div id="d_lcd" class="muted">—</div>
        <div data-i18n="dash.devices.xgo_imu">xgo.imu</div><div id="d_xgo_imu" class="muted">—</div>
        <div data-i18n="dash.devices.xgo_pose">xgo.pozycja</div><div id="d_xgo_pose" class="muted">—</div>
        <div data-i18n="dash.devices.xgo_battery">xgo.bateria</div><div id="d_xgo_batt" class="muted">—</div>
        <div data-i18n="dash.devices.temp">temp</div><div id="d_temp" class="muted">—</div>
      </div>
    </div>

    <div class="card">
      <h3 data-i18n="dash.history.title">Historia (60 s) — CPU / MEM</h3>
      <canvas id="chart" width="300" height="140"></canvas>
      <div class="legend">
        <span><i class="dot cpu"></i><span data-i18n="dash.history.cpu">cpu%</span></span>
        <span><i class="dot mem"></i><span data-i18n="dash.history.mem">mem%</span></span>
      </div>
    </div>

    <div class="card">
      <h3 style="display:flex;align-items:center;gap:8px" data-i18n="dash.camera.title">
        Kamera
        <span id="camBadge" class="cam-badge">…</span>
      </h3>
      <div class="thumb">
        <img id="img_cam" class="cam-img" src="/camera/placeholder" alt="kamera" decoding="async" loading="lazy">
      </div>
      <div class="legend">
        <span><i class="dot raw"></i><span id="leg_cam_txt">RAW • age: —</span></span>
      </div>
    </div>
  </div>

  <!-- RZĄD 2 -->
  <div class="grid" style="margin-top:18px">
    <div class="card">
      <h3 data-i18n="dash.health.title">Health</h3>
      <div class="kv">
        <div data-i18n="dash.health.status">status</div><div id="h_status" class="ok">OK</div>
        <div data-i18n="dash.health.uptime">uptime</div><div id="h_uptime" class="muted">—</div>
        <div data-i18n="dash.health.bus_last_msg_age">bus.last_msg_age</div><div id="h_msg" class="muted">—</div>
        <div data-i18n="dash.health.bus_last_heartbeat_age">bus.last_heartbeat_age</div><div id="h_hb" class="muted">—</div>
      </div>
    </div>

    <div class="card">
      <h3>Obstacle</h3>
      <div class="kv">
        <div>present</div><div id="obs_present" class="muted">—</div>
        <div>confidence</div><div id="obs_conf" class="muted">—</div>
        <div>edge_pct</div><div id="obs_edge" class="muted">—</div>
      </div>
    </div>

    <div class="card">
      <h3>ROI histogram — edges</h3>
      <canvas id="binsCanvas" width="300" height="140"></canvas>
      <div class="legend">
        <span><i class="dot edge"></i><span id="binsLegendTxt">LOW/HIGH: — / — • edge_pct: —</span></span>
      </div>
    </div>

    <div class="card">
      <h3 data-i18n="dash.camera_proc.title">Kamera — PROC</h3>
      <div class="thumb">
        <img id="img_proc" class="cam-img" src="/camera/placeholder" alt="processed camera" decoding="async" loading="lazy">
      </div>
      <div class="legend">
        <span><i class="dot proc"></i><span id="leg_proc_txt">PROC • age: —</span></span>
      </div>
    </div>
  </div>

  <!-- RZĄD 3: API Metrics -->
  <div class="grid" style="margin-top:18px">
    <div class="card">
      <h3>API Metrics</h3>
      <div class="kv">
        <div>Control</div><div id="metric_control">—</div>
        <div>Navigator</div><div id="metric_navigator">—</div>
        <div>Voice</div><div id="metric_voice">—</div>
        <div>GoogleHome</div><div id="metric_google_home">—</div>
        <div>Chat</div><div id="metric_chat">—</div>
        <div>Face</div><div id="metric_face">—</div>
        <div style="font-weight:bold;margin-top:4px">Total Errors</div><div id="metric_total_errors" class="bad" style="font-weight:bold;margin-top:4px">—</div>
      </div>
      <div class="hint" style="margin-top:6px;opacity:.7">Interactive API call metrics (OK / Error)</div>
    </div>

    <div class="card">
      <h3>Snap freshness</h3>
      <div class="kv">
        <div>raw.age</div><div id="age_raw" class="muted">—</div>
        <div>proc.age</div><div id="age_proc" class="muted">—</div>
      </div>
      <div class="hint" style="margin-top:6px;opacity:.7">Źródło: <code>/vision/snap-info</code></div>
    </div>

    <div class="card">
      <h3 data-i18n="dash.repo.title">Repozytorium</h3>
      <div class="kv">
        <div data-i18n="dash.repo.name">projekt</div><div><a href="https://github.com/mpieniak01/Rider-Pi" target="_blank">Rider-Pi</a></div>
        <div data-i18n="dash.repo.github">GitHub</div><div><a href="https://github.com/mpieniak01" target="_blank">@mpieniak01</a></div>
      </div>
    </div>

    <div class="card">
      <h3>Camera — OBST (annot)</h3>
      <div class="thumb">
        <img id="img_obst" class="cam-img" src="/camera/placeholder" alt="obstacle annotated" decoding="async" loading="lazy">
      </div>
      <div class="legend">
        <span><i class="dot obst"></i><span id="leg_obst_txt">OBST • ROI overlay</span></span>
      </div>
    </div>
  </div>

  <!-- RZĄD 4: Info + Linki + TRACKER w jednym rzędzie -->
  <div class="grid" style="margin-top:18px">
    <div class="card" style="grid-column: span 2">
      <h3>Info</h3>
      <div class="hint" style="opacity:.8">
        Tracker stream pokazuje wykrywaną twarz lub dłoń z zaznaczonym okręgiem oraz aktualnym FPS przetwarzania.
        Minimalna akceptowalna wartość FPS to 10. Użyj endpointu /api/vision/tracking/mode aby włączyć tryb Follow Me (face/hand).
      </div>
    </div>

    <div class="card">
      <h3 data-i18n="dash.links.title">Linki</h3>
      <div class="kv">
        <div data-i18n="dash.links.events">zdarzenia (SSE)</div><div><a href="/events" target="_blank">/events</a></div>
        <div data-i18n="dash.links.metrics">metryki</div><div><a href="/metrics" target="_blank">/metrics</a></div>
        <div>system dashboard</div><div><a href="/system/" target="_blank">/system/</a></div>
        <div data-i18n="dash.links.control">sterowanie</div><div><a href="/control">/control</a></div>
        <div data-i18n="dash.links.home">google.home</div><div><a href="/home">/home</a></div>
      </div>
    </div>

    <div class="card">
      <h3>Camera — TRACKER (Follow Me)</h3>
      <div class="thumb">
        <img id="img_tracker" class="cam-img" src="/camera/placeholder" alt="tracker with FPS and detection" decoding="async" loading="lazy">
      </div>
      <div class="legend">
        <span><i class="dot raw"></i><span id="leg_tracker_txt">TRACKER • FPS + detection circle</span></span>
      </div>
    </div>
  </div>

  <div class="statusbar" id="statusbar">
    <span class="pill" id="sb_presence"><span data-i18n="dash.status.vision_prefix">VISION:</span>&nbsp;<span id="sb_presence_state">—</span></span>
    <span class="sep">•</span>
    <span id="sb_mode" class="muted">mode: —</span>
    <span class="sep">•</span>
    <span id="sb_conf" class="muted">conf: —</span>
    <span class="sep">•</span>
    <span class="pill" id="sb_cam">CAM: —</span>
    <span id="sb_cam_meta" class="muted">fps: —</span>
  </div>
</div>

<script type="module">
import { initI18n, applyDom, t } from '/web/assets/i18n.js?v=3';

const REFRESH_MS = 2000;
const SNAP_STALE_S = 5;

const el = id=>document.getElementById(id);
const setTxt=(id,txt)=>{const e=el(id); if(e) e.textContent=txt};
const setCls=(id,cls)=>{const e=el(id); if(e) e.className=cls};
const fmt=(n,d=1)=> (n==null? '—' : (typeof n==='number'? Number(n).toFixed(d): n));

/* --- black preview helper --- */
const BLACK_SVG='data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 360"><rect width="100%" height="100%" fill="black"/></svg>';
function blackify(imgEl,on=true){ if(!imgEl) return; const box=imgEl.closest('.thumb'); if(on){ imgEl.src=BLACK_SVG; box&&box.classList.add('blank'); } else { box&&box.classList.remove('blank'); } }

/* i18n */
const urlLang=new URLSearchParams(location.search).get('lang');
const saved=localStorage.getItem('lang');
const browser=(navigator.language||'').slice(0,2).toLowerCase();
const pick=v=>v&&v.toLowerCase().startsWith('en')?'en':(v&&v.toLowerCase().startsWith('pl')?'pl':null);
const lang=pick(urlLang)||pick(saved)||pick(browser)||'pl';
if(urlLang) localStorage.setItem('lang',lang);
await initI18n(lang); applyDom();
function syncLangMeta(code){
  document.documentElement.setAttribute('lang',code);
  document.title=t('dash.page_title');
}
syncLangMeta(lang);
window.addEventListener('dashboard:langchange',ev=>{
  const next=ev?.detail?.lang;
  if(next) syncLangMeta(next);
});

/* wykres CPU/MEM */
function drawChart(cpuArr=[], memArr=[]){
  const c=el('chart'); if(!c) return; const ctx=c.getContext('2d');
  ctx.clearRect(0,0,c.width,c.height);
  const padL=30,padT=10,padR=10,padB=10; const W=c.width-padL-padR,H=c.height-padT-padB;
  ctx.strokeStyle='#1d3548'; ctx.strokeRect(padL,padT,W,H);
  ctx.fillStyle='#8aa'; ctx.font='10px sans-serif'; ctx.textAlign='right';
  [0,50,100].forEach(yv=>{const y=padT+H-((yv/100)*H); ctx.beginPath(); ctx.moveTo(padL-4,y); ctx.lineTo(padL,y); ctx.strokeStyle='#1d3548'; ctx.stroke(); ctx.fillText(String(yv),padL-6,y+3);});
  function plot(arr,color){ if(!arr||arr.length<2) return; ctx.beginPath(); ctx.lineWidth=1.2; ctx.strokeStyle=color; const n=arr.length; for(let i=0;i<n;i++){ const x=padL+(i*(W/(n-1))); const v=Math.max(0,Math.min(100,Number(arr[i]||0))); const y=padT+H-((v/100)*H); if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);} ctx.stroke(); }
  plot(cpuArr,'#6db3ff'); plot(memArr,'#ffd36d');
}

/* ===== KAMERY ===== */
let lastCamReq=0,lastProcReq=0,lastObstReq=0,lastTrackerReq=0;
let lastSnapAges={raw:null,proc:null,tracker:null};
let lastCamState={vision_enabled:undefined,on:undefined,res:null,fps:null};
let lastObstacle={present:null,confidence:null};
let lastCameraResource=null;
let lastLcdResource=null;
let lastTrackingInfo={};

function formatResourceHolders(list){
  if(!Array.isArray(list) || !list.length) return '';
  return list.map(h=>{
    const pid = h?.pid != null ? String(h.pid) : '?';
    const cmd = h?.cmd || 'proc';
    const svc = h?.service ? ` (${h.service})` : '';
    return `${cmd}#${pid}${svc}`;
  }).join(', ');
}

function cameraResourceSummary(){
  if(!lastCameraResource) return null;
  if(lastCameraResource.error){
    return {state:'error', text:t('dash.camera.resource_error_badge'), tooltip:lastCameraResource.error};
  }
  const holdersTxt = formatResourceHolders(lastCameraResource.holders);
  if(lastCameraResource.free){
    return {state:'free', text:t('dash.camera.resource_free_badge'), tooltip:holdersTxt, holders:holdersTxt};
  }
  return {
    state:'busy',
    text: holdersTxt ? t('dash.camera.resource_busy_with_holder',{holder:holdersTxt}) : t('dash.camera.resource_busy_badge'),
    tooltip: holdersTxt,
    holders: holdersTxt,
  };
}

function lcdResourceSummary(){
  if(!lastLcdResource) return null;
  if(lastLcdResource.error){
    return {state:'error', tooltip:lastLcdResource.error};
  }
  const holdersTxt = formatResourceHolders(lastLcdResource.holders);
  if(lastLcdResource.free){
    return {state:'free', tooltip:holdersTxt, holders:holdersTxt};
  }
  return {state:'busy', tooltip:holdersTxt, holders:holdersTxt};
}

function setCamBadgeAndMeta(cam){
  const camBadge=el('camBadge');
  const resourceInfo=cameraResourceSummary();
  if(camBadge){
    if(resourceInfo){
      let cls='cam-badge';
      if(resourceInfo.state==='busy') cls+=' on';
      camBadge.className=cls.trim();
      camBadge.textContent=resourceInfo.text;
      if(resourceInfo.tooltip) camBadge.title=resourceInfo.tooltip;
      else camBadge.removeAttribute('title');
    }else{
      const visionOn = cam?.vision_enabled !== false;
      camBadge.textContent = visionOn ? t('dash.camera.vision_on') : t('dash.camera.vision_off');
      camBadge.className   = 'cam-badge' + (visionOn ? ' on' : '');
      camBadge.removeAttribute('title');
    }
  }
  const sbMeta=el('sb_cam_meta');
  if(sbMeta){
    const fpsVal = (cam && cam.fps!=null) ? cam.fps : lastCamState.fps;
    const fpsTxt = fpsVal!=null ? `${fmt(fpsVal,1)} fps` : 'fps: —';
    const extra = resourceInfo && resourceInfo.tooltip ? ` • ${resourceInfo.tooltip}` : '';
    sbMeta.textContent = `${fpsTxt}${extra}`;
  }
}
function setImageSafely(imgEl,url,tagStore){
  const tag=Date.now(); tagStore.value=tag;
  const loader=new Image(); loader.decoding='async'; loader.loading='eager';
  loader.onload=()=>{ if(tagStore.value!==tag) return; imgEl.src=url; blackify(imgEl,false); };
  loader.onerror=()=>{ if(tagStore.value!==tag) return; blackify(imgEl,true); };
  loader.src=url;
}
function refreshCamLegends(){
  const partsRaw=['RAW']; if(lastCamState.res) partsRaw.push(lastCamState.res);
  if(lastCamState.fps!=null) partsRaw.push(`${fmt(lastCamState.fps,1)} fps`);
  if(lastSnapAges.raw!=null) partsRaw.push(`age: ${fmt(lastSnapAges.raw,1)}s`);
  setTxt('leg_cam_txt',partsRaw.join(' • '));

  const partsProc=['PROC']; if(lastCamState.res) partsProc.push(lastCamState.res);
  if(lastSnapAges.proc!=null) partsProc.push(`age: ${fmt(lastSnapAges.proc,1)}s`);
  setTxt('leg_proc_txt',partsProc.join(' • '));

  const partsObst=['OBST','ROI overlay'];
  if(lastObstacle.present!=null) partsObst.push(`present: ${String(lastObstacle.present)}`);
  if(lastObstacle.confidence!=null) partsObst.push(`conf: ${fmt(lastObstacle.confidence,3)}`);
  setTxt('leg_obst_txt',partsObst.join(' • '));

  const partsTracker=[t('dash.tracker.legend')];
  if(lastTrackingInfo && typeof lastTrackingInfo.offset === 'number'){
    partsTracker.push(`${t('dash.tracker.offset')}: ${fmt(lastTrackingInfo.offset,3)}`);
  }else{
    partsTracker.push(t('dash.tracker.offset_none'));
  }
  if(lastTrackingInfo && lastTrackingInfo.mode){
    partsTracker.push(`${t('dash.tracker.mode')}: ${lastTrackingInfo.mode}`);
  }
  if(lastSnapAges.tracker!=null){
    partsTracker.push(`${t('dash.tracker.age')}: ${fmt(lastSnapAges.tracker,1)}s`);
  }
  setTxt('leg_tracker_txt',partsTracker.join(' • '));
}
function visionOff(){
  return (lastCamState.vision_enabled===false)||(lastCamState.on===false);
}
function feedTooOld(kind){
  const age=lastSnapAges[kind];
  return age!=null && age>SNAP_STALE_S;
}
function shouldBlankFeed(kind){
  if(visionOff()) return true;
  if(!kind) return false;
  return feedTooOld(kind);
}
function refreshFeed(imgEl,url,kind,tagStore){
  if(!imgEl) return;
  if(shouldBlankFeed(kind)){ blackify(imgEl,true); return; }
  setImageSafely(imgEl, url, tagStore);
}
async function refreshCamera(){
  const imgCam=el('img_cam'), imgProc=el('img_proc'), imgObst=el('img_obst'), imgTracker=el('img_tracker');
  const bust=Date.now();
  refreshFeed(imgCam, `/vision/cam?t=${bust}`, 'raw', {get value(){return lastCamReq;}, set value(v){lastCamReq=v;}});
  refreshFeed(imgProc, `/vision/edge?t=${bust}`, 'proc', {get value(){return lastProcReq;}, set value(v){lastProcReq=v;}});
  refreshFeed(imgObst, `/snapshots/obst_annot.jpg?t=${bust}`, null, {get value(){return lastObstReq;}, set value(v){lastObstReq=v;}});
  refreshFeed(imgTracker, `/vision/tracker?t=${bust}`, 'tracker', {get value(){return lastTrackerReq;}, set value(v){lastTrackerReq=v;}});
}

async function refreshCameraResource(){
  try{
    const r = await fetch('/api/resource/camera',{cache:'no-store'});
    const data = await r.json().catch(()=>null);
    if(!r.ok) throw new Error((data && data.error) || `HTTP ${r.status}`);
    lastCameraResource = data;
  }catch(e){
    lastCameraResource = {error: String(e.message || e)};
  }
  setCamBadgeAndMeta(lastState?.camera || {});
  try{ applyDevices({state:lastState, health:lastHealth}); }catch{}
}

async function refreshLcdResource(){
  try{
    const r = await fetch('/api/resource/lcd',{cache:'no-store'});
    const data = await r.json().catch(()=>null);
    if(!r.ok) throw new Error((data && data.error) || `HTTP ${r.status}`);
    lastLcdResource = data;
  }catch(e){
    lastLcdResource = {error: String(e.message || e)};
  }
  try{ applyDevices({state:lastState, health:lastHealth}); }catch{}
}

/* ===== HEALTH ===== */
function updateHealth(h){
  const ok=!!(h && (h.ok===true || h.status==='ok' || h.state==='ok'));
  setTxt('h_status', ok? t('meta.ok'):'degraded'); setCls('h_status', ok?'ok':'bad');

  if(h && h.uptime_s!=null){
    const s=Math.max(0,Math.floor(h.uptime_s));
    const HH=Math.floor(s/3600), MM=String(Math.floor((s%3600)/60)).padStart(2,'0'), SS=String(s%60).padStart(2,'0');
    setTxt('h_uptime',`${HH}:${MM}:${SS}`);
  } else setTxt('h_uptime','—');

  const msg=h?.bus?.last_msg_age_s ?? h?.bus?.last_msg_age;
  if(msg!=null) setTxt('h_msg',`${Number(msg).toFixed(1)} s`);

  let hb=h?.bus?.last_heartbeat_age_s ?? h?.bus?.last_hb_age_s ?? h?.bus?.heartbeat_age_s ?? null;
  if(hb==null){
    const ts=h?.bus?.last_heartbeat_ts ?? h?.bus?.heartbeat_ts ?? null;
    if(ts!=null) hb=Math.max(0,(Date.now()/1000)-Number(ts));
  }
  if(hb!=null) setTxt('h_hb',`${Number(hb).toFixed(1)} s`);
}
async function busHeartbeatFallback(){
  try{
    const r=await fetch('/api/bus/health',{cache:'no-store'}); if(!r.ok) return;
    const j=await r.json().catch(()=>null); if(!j) return;
    const lag=j?.bus?.last_msg_age_s ?? j?.bus?.last_msg_age;
    if(lag!=null) setTxt('h_msg',`${Number(lag).toFixed(1)} s`);
    let hb=j?.bus?.last_heartbeat_age_s ?? j?.bus?.last_hb_age_s ?? j?.bus?.heartbeat_age_s;
    if(hb==null){ const ts=j?.bus?.last_heartbeat_ts ?? j?.bus?.heartbeat_ts; if(ts!=null) hb=Math.max(0,(Date.now()/1000)-Number(ts)); }
    if(hb!=null) setTxt('h_hb',`${Number(hb).toFixed(1)} s`);
  }catch{}
}

/* ===== STATE ===== */
let lastHealth=null, lastState=null;
// PC panel nie trzyma flagi z backendu, więc domyślnie zakładamy, że adapter REST jest dostępny.
let adapterConnected = true;

function updateStateUI(s){
  setTxt('p_present',String(!!s.present)); setCls('p_present',s.present?'ok':'bad');
  setTxt('p_conf',fmt(s.confidence,3)); setTxt('p_mode',s.mode||'—');
  setTxt('p_ts',s.ts? new Date(s.ts*1000).toLocaleTimeString():'—');
  setTxt('p_age',(s.age_s!=null? fmt(s.age_s,1)+' s':'—'));
  setTxt('sb_presence_state',s.present? t('dash.status.present'): t('dash.status.idle'));
  setCls('sb_presence','pill '+(s.present?'ok':'bad'));
  setTxt('sb_mode',`${t('dash.status.mode')}: ${s.mode||'—'}`);
  setTxt('sb_conf',`${t('dash.status.conf')}: ${fmt(s.confidence,3)}`);

  lastCamState.vision_enabled = s?.camera?.vision_enabled;
  lastCamState.on = s?.camera?.on;
  const resArr=s?.camera?.res;
  lastCamState.res=(Array.isArray(resArr)&&resArr.length===2)?`${resArr[0]}×${resArr[1]}`:null;
  lastCamState.fps=(s?.camera?.fps!=null)? Number(s.camera.fps):null;

  lastTrackingInfo = s?.tracking || {};
  setCamBadgeAndMeta(s?.camera||{});
  refreshCamLegends();
}

/* ===== DEVICES ===== */
function textFromLCD(lcd){
  if(!lcd) return '—';
  const parts=[]; parts.push(lcd.on?'ON':'OFF');
  if(lcd.rot!=null) parts.push('rot '+lcd.rot);
  if(lcd.presenting) parts.push('presenting');
  if(lcd.no_draw) parts.push('no_draw');
  return parts.join(' · ');
}
function applyDevices({state,health}){
  // Merge camera info from /state (preview metadata) with richer device snapshot from /healthz.
  const camMerged = {
    ...(health?.devices?.camera || {}),
    ...(state?.devices?.camera || {}),
    ...(state?.camera || {}),
  };
  const resArr = Array.isArray(camMerged.res) && camMerged.res.length===2 ? camMerged.res : null;
  const resTxt = resArr ? `${resArr[0]}×${resArr[1]}` : (lastCamState.res || '');
  const fpsVal = camMerged.fps!=null ? camMerged.fps : lastCamState.fps;
  const resourceInfo = cameraResourceSummary();
  const holdersTxt = resourceInfo?.holders || formatResourceHolders(lastCameraResource?.holders);
  const camParts=[];
  let camStatus = typeof camMerged.on === 'boolean' ? camMerged.on : (resourceInfo ? resourceInfo.state==='busy' : null);
  if(!adapterConnected){ camStatus = camMerged.on===false ? false : null; }
  if(camStatus !== null){
    camParts.push(camStatus ? 'ON' : 'OFF');
  }
  if(camMerged.mode) camParts.push(camMerged.mode);
  if(resTxt) camParts.push(resTxt);
  if(fpsVal!=null) camParts.push(`${fmt(fpsVal,1)} fps`);
  if(resourceInfo){
    if(resourceInfo.state==='busy') camParts.push(t('dash.camera.resource_busy_badge'));
    else if(resourceInfo.state==='free') camParts.push(t('dash.camera.resource_free_badge'));
    else if(resourceInfo.state==='error') camParts.push(t('dash.camera.resource_error_badge'));
  }
  if(holdersTxt) camParts.push(holdersTxt);
  setTxt('d_cam', camParts.filter(Boolean).join(' · ') || '—');
  let camClass='muted';
  if(camStatus === true) camClass='ok';
  else if(camStatus === false) camClass='muted';
  else if(resourceInfo){
    if(resourceInfo.state==='busy') camClass='ok';
    else if(resourceInfo.state==='error') camClass='bad';
    else camClass='muted';
  }
  setCls('d_cam', camClass);

  const lcd = state?.lcd ?? state?.devices?.lcd ?? health?.devices?.lcd ?? null;
  const lcdTxtParts=[textFromLCD(lcd)];
  const lcdRes=lcdResourceSummary();
  if(lcdRes?.state){
    if(lcdRes.state==='free') lcdTxtParts.push(t('dash.camera.resource_free_badge'));
    else if(lcdRes.state==='busy') lcdTxtParts.push(t('dash.camera.resource_busy_badge'));
  }
  const lcdTxt=lcdTxtParts.filter(Boolean).join(' · ');
  setTxt('d_lcd',lcdTxt||'—');
  setCls('d_lcd',(lcd && lcd.on)?'ok':'muted');

  const xgo = state?.xgo ?? state?.devices?.xgo ?? health?.devices?.xgo ?? {};
  const imuTxt=(xgo.on?'ON':'OFF') + (xgo.imu_ok===true?' · OK':(xgo.on?' · ?':''));
  setTxt('d_xgo_imu',imuTxt); setCls('d_xgo_imu',(xgo.on && xgo.imu_ok)?'ok':'muted');

  const poseParts=[];
  if(Array.isArray(xgo.pose) && xgo.pose.some(v=>v!=null)){
    poseParts.push(xgo.pose.filter(v=>v!=null).map(v=>Number(v).toFixed(1)).join('°, ')+'°');
  }
  if(typeof xgo.pose==='string' && xgo.pose.trim()) poseParts.push(xgo.pose.trim());
  if(xgo.roll!=null)  poseParts.push(`r ${fmt(xgo.roll,1)}°`);
  if(xgo.pitch!=null) poseParts.push(`p ${fmt(xgo.pitch,1)}°`);
  if(xgo.yaw!=null)   poseParts.push(`y ${fmt(xgo.yaw,1)}°`);
  setTxt('d_xgo_pose',poseParts.length? poseParts.join(' · ') : '—');

  const battPct=(xgo.battery_pct ?? xgo.batt_pct ?? xgo.battery?.pct ?? xgo.battery);
  setTxt('d_xgo_batt',(battPct!=null? `${Number(battPct).toFixed(0)}%`:'—'));
  setCls('d_xgo_batt',(battPct!=null?'ok':'muted'));

  const fw = xgo.fw ?? state?.fw ?? health?.devices?.xgo?.fw;
  if (fw) setTxt('ci_fw', fw);
}

/* ===== OBSTACLE + HISTOGRAM ===== */
function drawBinsCanvas({bins=null,edge_pct=null,low=null,high=null}={}){
  const c=el('binsCanvas'); if(!c) return; const ctx=c.getContext('2d');
  ctx.clearRect(0,0,c.width,c.height);
  const padL=30,padT=10,padR=10,padB=16; const W=c.width-padL-padR,H=c.height-padT-padB;
  ctx.strokeStyle='#1d3548'; ctx.strokeRect(padL,padT,W,H);
  ctx.fillStyle='#8aa'; ctx.font='10px sans-serif'; ctx.textAlign='right';
  [0,0.5,1].forEach(v=>{const y=padT+H-(v*H); ctx.beginPath(); ctx.moveTo(padL-4,y); ctx.lineTo(padL,y); ctx.strokeStyle='#1d3548'; ctx.stroke(); ctx.fillText(String(Math.round(v*100)),padL-6,y+3);});
  if(low!=null){ const y=padT+H-(Math.max(0,Math.min(1,low))*H); ctx.strokeStyle='#2b8a3e'; ctx.setLineDash([4,3]); ctx.beginPath(); ctx.moveTo(padL,y); ctx.lineTo(padL+W,y); ctx.stroke(); ctx.setLineDash([]);}
  if(high!=null){ const y=padT+H-(Math.max(0,Math.min(1,high))*H); ctx.strokeStyle='#d89d2b'; ctx.setLineDash([4,3]); ctx.beginPath(); ctx.moveTo(padL,y); ctx.lineTo(padL+W,y); ctx.stroke(); ctx.setLineDash([]);}
  if(Array.isArray(bins) && bins.length){
    const n=bins.length; const gap=2; const barW=(W-(gap*(n-1)))/n;
    ctx.fillStyle='#6db3ff';
    bins.forEach((v,i)=>{ const h=H*Math.max(0,Math.min(1,Number(v)||0)); const x=padL+i*(barW+gap); const y=padT+H-h; ctx.fillRect(x,y,Math.max(1,barW),h);});
  }else if(edge_pct!=null){
    const h=H*Math.max(0,Math.min(1,Number(edge_pct)||0)); ctx.fillStyle='#6db3ff';
    ctx.fillRect(padL+W*0.25,padT+H-h,W*0.5,h);
  }
}
function applyObstacle(o){
  const present=!!o.present;
  const conf=(o.confidence!=null)? Number(o.confidence).toFixed(3):null;
  const pct=(o.edge_pct!=null)? Number(o.edge_pct).toFixed(3):'—';
  const cls=present?'ok':'bad';
  const set=(id,txt,c)=>{const e=document.getElementById(id); if(!e) return; e.textContent=txt; if(c) e.className=c;};
  set('obs_present',String(present),cls);
  set('obs_conf',conf!=null?conf:'—');
  set('obs_edge',pct);

  lastObstacle.present=present;
  lastObstacle.confidence=(conf!=null? Number(conf):null);
  refreshCamLegends();

  const low=o?.diag?.t_low ?? null;
  const high=o?.diag?.t_high ?? null;
  const bins=o?.diag?.bins ?? null;
  const edge_raw=o?.diag?.edge_pct_raw ?? o?.edge_pct ?? null;

  drawBinsCanvas({bins,edge_pct:edge_raw,low,high});
  const txt=document.getElementById('binsLegendTxt');
  if(txt){
    const lowTxt=low!=null? Number(low).toFixed(2):'—';
    const highTxt=high!=null? Number(high).toFixed(2):'—';
    const epTxt=edge_raw!=null? Number(edge_raw).toFixed(3):'—';
    txt.textContent=`LOW/HIGH: ${lowTxt} / ${highTxt} • edge_pct: ${epTxt}`;
  }
}
async function fetchObstacle(){
  try{ const r=await fetch('/vision/obstacle',{cache:'no-store'}); if(!r.ok) return;
       const j=await r.json().catch(()=>null); if(j) applyObstacle(j);}catch{}
}

/* ===== SNAP INFO ===== */
function applySnapInfo(si){
  const rawAge=si?.raw?.age_s; const procAge=si?.proc?.age_s; const trackerAge=si?.tracker?.age_s;
  lastSnapAges.raw=rawAge ?? null; lastSnapAges.proc=procAge ?? null; lastSnapAges.tracker=trackerAge ?? null;
  setTxt('age_raw',rawAge!=null? fmt(rawAge,1)+' s':'—');
  setTxt('age_proc',procAge!=null? fmt(procAge,1)+' s':'—');
  setTxt('age_tracker',trackerAge!=null? fmt(trackerAge,1)+' s':'—');
  const ok=(rawAge!=null && rawAge<=SNAP_STALE_S);
  setCls('sb_cam','pill '+(ok?'ok':'bad'));
  const camText='CAM: '+(rawAge!=null? fmt(rawAge,1)+'s':'—')+' / '+(procAge!=null? fmt(procAge,1)+'s':'—');
  const trackerText=trackerAge!=null? ' • TRK: '+fmt(trackerAge,1)+'s':'';
  setTxt('sb_cam',camText+trackerText);
  const imgCam=el('img_cam'); const imgProc=el('img_proc');
  if(rawAge!=null && rawAge>SNAP_STALE_S) blackify(imgCam,true); else blackify(imgCam,false);
  if(procAge!=null && procAge>SNAP_STALE_S) blackify(imgProc,true); else blackify(imgProc,false);
  refreshCamLegends();
}
async function refreshSnapInfo(){
  try{ const r=await fetch('/vision/snap-info',{cache:'no-store'}); if(!r.ok) return;
       const j=await r.json().catch(()=>null); if(j) applySnapInfo(j);}catch{}
}

/* ===== SYSINFO ===== */
function applySysinfo(si){
  if(!si) return;
  setTxt('ci_cpu', si.cpu_pct!=null? fmt(si.cpu_pct,1)+'%':'—');
  setTxt('ci_load', `${fmt(si.load1,2)}/${fmt(si.load5,2)}/${fmt(si.load15,2)}`);
  const mb=v=> (v==null ? '—' : Number(v).toFixed(1)+' MB');
  if(si.mem_total_mb!=null && si.mem_used_mb!=null){
    const pct=si.mem_pct!=null? ` (${fmt(si.mem_pct,1)}%)`:'';
    setTxt('ci_mem', `${mb(si.mem_used_mb)} / ${mb(si.mem_total_mb)}${pct}`);
  } else setTxt('ci_mem','—');
  const gb=v=> (v==null ? '—' : Number(v).toFixed(1)+' GB');
  if(si.disk_total_gb!=null && si.disk_used_gb!=null){
    const pct=si.disk_pct!=null? ` (${fmt(si.disk_pct,1)}%)`:'';
    setTxt('ci_disk', `${gb(si.disk_used_gb)} / ${gb(si.disk_total_gb)}${pct}`);
  } else setTxt('ci_disk','—');
  setTxt('ci_os', si.os_release || si.platform || '—');
  setTxt('d_temp', (si.temp_c!=null ? fmt(si.temp_c,1)+' °C' : '—'));
  const fw = si.fw || si.fw_version || si.firmware || si.version;
  if (fw) setTxt('ci_fw', fw);
  drawChart(si.hist_cpu || [], si.hist_mem || []);
}

/* ===== API Metrics ===== */
async function refreshApiMetrics(){
  try{
    const r = await fetch('/api/app-metrics', {cache:'no-store'});
    if(!r.ok) return;
    const j = await r.json().catch(()=>null);
    if(!j || !j.metrics) return;
    
    const m = j.metrics;
    
    // Format: "OK / Error"
    setTxt('metric_control', `${m.control?.ok ?? 0} / ${m.control?.error ?? 0}`);
    setTxt('metric_navigator', `${m.navigator?.ok ?? 0} / ${m.navigator?.error ?? 0}`);
    setTxt('metric_voice', `${m.voice?.ok ?? 0} / ${m.voice?.error ?? 0}`);
    setTxt('metric_google_home', `${m.google_home?.ok ?? 0} / ${m.google_home?.error ?? 0}`);
    setTxt('metric_chat', `${m.chat?.ok ?? 0} / ${m.chat?.error ?? 0}`);
    setTxt('metric_face', `${m.face?.ok ?? 0} / ${m.face?.error ?? 0}`);
    
    // Total Errors - highlighted
    const totalErr = j.total_errors ?? 0;
    setTxt('metric_total_errors', totalErr);
    setCls('metric_total_errors', totalErr > 0 ? 'bad' : 'ok');
  }catch{}
}

/* ===== Poll ===== */
async function tick(){
  try{ lastHealth = await (await fetch('/healthz',{cache:'no-store'})).json(); updateHealth(lastHealth);}catch{}
  try{ await busHeartbeatFallback(); }catch{}
  try{ lastState  = await (await fetch('/state',{cache:'no-store'})).json(); updateStateUI(lastState);}catch{}
  try{ applyDevices({state:lastState, health:lastHealth}); }catch{}
  try{ await refreshCameraResource(); }catch{}
  try{ await refreshLcdResource(); }catch{}

  try{ const si = await (await fetch('/sysinfo',{cache:'no-store'})).json(); applySysinfo(si);}catch{}

  try{ await refreshSnapInfo(); }catch{}
  try{ await refreshCamera(); }catch{}
}

/* lekkie SSE */
function startSSE(){ try{ const es=new EventSource('/events'); es.onmessage=()=>{}; es.onerror=()=>{}; }catch{} }

setInterval(tick, REFRESH_MS); tick();
setInterval(fetchObstacle, REFRESH_MS); fetchObstacle();
setInterval(refreshApiMetrics, REFRESH_MS); refreshApiMetrics();
startSSE();
</script>
<script type="module" src="/web/assets/menu.js"></script>
</body>
</html>
