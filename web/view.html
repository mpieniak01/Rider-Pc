<!doctype html>
<html lang="pl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title data-i18n="dash.page_title">Rider-PC — mini dashboard</title>
<link rel="stylesheet" href="/web/assets/dashboard-common.css">
<link rel="stylesheet" href="/web/assets/view.css">
</head>
<body data-page="view">
<div data-dashboard-menu-target></div>
<div class="wrap">
<h1>
  <span class="brand-accent" data-i18n="nav.brand_title">Rider-PC</span>
  <span data-i18n="dash.page_title_suffix">— mini dashboard</span>
</h1>
  <div class="c-hint">
    <span data-i18n="dash.hint_prefix">Auto-refresh co ≈ 2 s.</span>
    <span data-i18n="dash.hint_endpoints">Endpointy:</span>
    <a href="/healthz">/healthz</a>, <a href="/state">/state</a>, <a href="/sysinfo">/sysinfo</a>, <a href="/vision/snap-info">/vision/snap-info</a>
  </div>

  <!-- RZĄD 1 -->
  <div class="l-grid">
    <div class="c-card">
      <h3 data-i18n="dash.system.title">System</h3>
      <div class="c-kv">
        <div data-i18n="dash.system.cpu_est">cpu (szac.)</div><div id="ci_cpu" class="muted">—</div>
        <div data-i18n="dash.system.load">load (1/5/15)</div><div id="ci_load" class="muted">—</div>
        <div data-i18n="dash.system.mem">pamięć</div><div id="ci_mem" class="muted">—</div>
        <div data-i18n="dash.system.disk">dysk</div><div id="ci_disk" class="muted">—</div>
        <div data-i18n="dash.system.os">os</div><div id="ci_os" class="muted">—</div>
        <div data-i18n="dash.system.fw">fw</div><div id="ci_fw" class="muted">—</div>
      </div>
    </div>

    <div class="c-card">
      <h3 data-i18n="dash.devices.title">Urządzenia</h3>
      <div class="c-kv">
        <div data-i18n="dash.devices.camera">kamera</div><div id="d_cam" class="muted">—</div>
        <div data-i18n="dash.devices.lcd">lcd</div><div id="d_lcd" class="muted">—</div>
        <div data-i18n="dash.devices.xgo_imu">xgo.imu</div><div id="d_xgo_imu" class="muted">—</div>
        <div data-i18n="dash.devices.xgo_pose">xgo.pozycja</div><div id="d_xgo_pose" class="muted">—</div>
        <div data-i18n="dash.devices.xgo_battery">xgo.bateria</div><div id="d_xgo_batt" class="muted">—</div>
        <div data-i18n="dash.devices.temp">temp</div><div id="d_temp" class="muted">—</div>
      </div>
    </div>

    <div class="c-card">
      <h3 data-i18n="dash.history.title">Historia (60 s) — CPU / MEM</h3>
      <canvas id="chart" width="300" height="140"></canvas>
      <div class="c-legend">
        <span><i class="c-legend__dot cpu"></i><span data-i18n="dash.history.cpu">cpu%</span></span>
        <span><i class="c-legend__dot mem"></i><span data-i18n="dash.history.mem">mem%</span></span>
      </div>
    </div>

    <div class="c-card">
      <h3 class="cam-card-title" data-i18n="dash.camera.title">
        Kamera
        <span id="camBadge" class="cam-badge">…</span>
      </h3>
      <div class="c-thumb">
        <img id="img_cam" class="cam-img" src="/camera/placeholder" alt="kamera" decoding="async" loading="lazy">
      </div>
      <div class="c-legend">
        <span><i class="c-legend__dot raw"></i><span id="leg_cam_txt">RAW • age: —</span></span>
      </div>
    </div>
  </div>

  <!-- RZĄD 2 -->
  <div class="l-grid">
    <div class="c-card">
      <h3 data-i18n="dash.health.title">Health</h3>
      <div class="c-kv">
        <div data-i18n="dash.health.status">status</div><div id="h_status" class="ok">OK</div>
        <div data-i18n="dash.health.uptime">uptime</div><div id="h_uptime" class="muted">—</div>
        <div data-i18n="dash.health.bus_last_msg_age">bus.last_msg_age</div><div id="h_msg" class="muted">—</div>
        <div data-i18n="dash.health.bus_last_heartbeat_age">bus.last_heartbeat_age</div><div id="h_hb" class="muted">—</div>
      </div>
    </div>

    <div class="c-card">
      <h3>Obstacle</h3>
      <div class="c-kv">
        <div>present</div><div id="obs_present" class="muted">—</div>
        <div>confidence</div><div id="obs_conf" class="muted">—</div>
        <div>edge_pct</div><div id="obs_edge" class="muted">—</div>
      </div>
    </div>

    <div class="c-card">
      <h3>ROI histogram — edges</h3>
      <canvas id="binsCanvas" width="300" height="140"></canvas>
      <div class="c-legend">
        <span><i class="c-legend__dot edge"></i><span id="binsLegendTxt">LOW/HIGH: — / — • edge_pct: —</span></span>
      </div>
    </div>

    <div class="c-card">
      <h3 data-i18n="dash.camera_proc.title">Kamera — PROC</h3>
      <div class="c-thumb">
        <img id="img_proc" class="cam-img" src="/camera/placeholder" alt="processed camera" decoding="async" loading="lazy">
      </div>
      <div class="c-legend">
        <span><i class="c-legend__dot proc"></i><span id="leg_proc_txt">PROC • age: —</span></span>
      </div>
    </div>
  </div>

  <!-- RZĄD 3: API Metrics -->
  <div class="l-grid">
    <div class="c-card">
      <h3>API Metrics</h3>
      <div class="c-kv">
        <div>Control</div><div id="metric_control">—</div>
        <div>Navigator</div><div id="metric_navigator">—</div>
        <div>Voice</div><div id="metric_voice">—</div>
        <div>GoogleHome</div><div id="metric_google_home">—</div>
        <div>Chat</div><div id="metric_chat">—</div>
        <div>Face</div><div id="metric_face">—</div>
        <div class="metric-highlight">Total Errors</div><div id="metric_total_errors" class="bad metric-highlight">—</div>
      </div>
      <div class="c-hint c-hint--sub">Interactive API call metrics (OK / Error)</div>
    </div>

    <div class="c-card">
      <h3>Snap freshness</h3>
      <div class="c-kv">
        <div>raw.age</div><div id="age_raw" class="muted">—</div>
        <div>proc.age</div><div id="age_proc" class="muted">—</div>
      </div>
      <div class="c-hint c-hint--sub">Źródło: <code>/vision/snap-info</code></div>
    </div>

    <div class="c-card">
      <h3 data-i18n="dash.repo.title">Repozytorium</h3>
      <div class="c-kv">
        <div data-i18n="dash.repo.name">projekt</div><div><a href="https://github.com/mpieniak01/Rider-Pc" target="_blank">Rider-PC</a></div>
        <div data-i18n="dash.repo.github">GitHub</div><div><a href="https://github.com/mpieniak01" target="_blank">@mpieniak01</a></div>
      </div>
    </div>

    <div class="c-card">
      <h3>Camera — OBST (annot)</h3>
      <div class="c-thumb">
        <img id="img_obst" class="cam-img" src="/camera/placeholder" alt="obstacle annotated" decoding="async" loading="lazy">
      </div>
      <div class="c-legend">
        <span><i class="c-legend__dot obst"></i><span id="leg_obst_txt">OBST • ROI overlay</span></span>
      </div>
    </div>
  </div>

  <!-- RZĄD 4: Info + Linki + TRACKER w jednym rzędzie -->
  <div class="l-grid">
    <div class="c-card">
      <h3>System PC</h3>
      <div class="c-kv">
        <div>Host</div><div id="pcHostInfo">—</div>
        <div>Adres panelu</div><div id="pcOriginInfo">—</div>
        <div>Status (live)</div><div><span id="pcLiveStatus" class="pc-status">—</span></div>
        <div>Status (ready)</div><div><span id="pcReadyStatus" class="pc-status">—</span></div>
        <div>CPU (%)</div><div id="pcCpu">—</div>
        <div>Load (1/5/15)</div><div id="pcLoad">—</div>
        <div>Pamięć</div><div id="pcMem">—</div>
        <div>Dysk</div><div id="pcDisk">—</div>
        <div>Temperatura</div><div id="pcTemp">—</div>
        <div>Uptime</div><div id="pcUptime">—</div>
        <div>Ost. aktualizacja</div><div id="pcUpdatedTs">—</div>
      </div>
      <div class="c-hint c-hint--sub">Dane z /health/* i /status/system-pc lokalnego serwera Rider-PC.</div>
    </div>

    <div class="c-card">
      <h3>Usługi PC</h3>
      <div id="pcServiceList" class="pc-service-list">
        <div class="muted">Trwa sprawdzanie...</div>
      </div>
      <div class="c-hint c-hint--sub">Status lokalnych endpointów Rider-PC.</div>
    </div>

    <div class="c-card">
      <h3 data-i18n="dash.links.title">Linki</h3>
      <div class="c-kv">
        <div data-i18n="dash.links.events">zdarzenia (SSE)</div><div><a href="/events" target="_blank">/events</a></div>
        <div data-i18n="dash.links.metrics">metryki</div><div><a href="/metrics" target="_blank">/metrics</a></div>
        <div>system dashboard</div><div><a href="/system/" target="_blank">/system/</a></div>
        <div data-i18n="dash.links.control">sterowanie</div><div><a href="/control">/control</a></div>
        <div data-i18n="dash.links.home">google.home</div><div><a href="/home">/home</a></div>
      </div>
    </div>

    <div class="c-card">
      <h3>Camera — TRACKER (Follow Me)</h3>
      <div class="c-thumb">
        <img id="img_tracker" class="cam-img" src="/camera/placeholder" alt="tracker with FPS and detection" decoding="async" loading="lazy">
      </div>
      <div class="c-legend">
        <span><i class="c-legend__dot raw"></i><span id="leg_tracker_txt">TRACKER • FPS + detection circle</span></span>
      </div>
    </div>
  </div>

  <div class="c-statusbar" id="statusbar">
    <span class="c-pill" id="sb_presence"><span data-i18n="dash.status.vision_prefix">VISION:</span>&nbsp;<span id="sb_presence_state">—</span></span>
    <span class="u-sep">•</span>
    <span id="sb_mode" class="muted">mode: —</span>
    <span class="u-sep">•</span>
    <span id="sb_conf" class="muted">conf: —</span>
    <span class="u-sep">•</span>
    <span class="c-pill" id="sb_cam">CAM: —</span>
    <span id="sb_cam_meta" class="muted">fps: —</span>
  </div>
</div>

<script type="module">
import { initI18n, applyDom, t } from '/web/assets/i18n.js?v=3';

const REFRESH_MS = 2000;
const SNAP_STALE_S = 5;
const PC_SYSTEM_REFRESH_MS = 5000;
const PC_SERVICE_REFRESH_MS = 7000;
const PC_SERVICE_CHECKS = [
  { label: 'Panel /health/live', url: '/health/live', noCors: false },
  { label: 'Panel /metrics', url: '/metrics', noCors: false },
  { label: 'Prometheus 9090', url: 'http://127.0.0.1:9090/-/ready', noCors: true },
  { label: 'Grafana 3000', url: 'http://127.0.0.1:3000/api/health', noCors: true },
  { label: 'Redis 6379', url: 'redis://127.0.0.1:6379', skip: true },
];

const el = id=>document.getElementById(id);
const setTxt=(id,txt)=>{const e=el(id); if(e) e.textContent=txt}
const setCls=(id,cls)=>{const e=el(id); if(e) e.className=cls}
const fmt=(n,d=1)=> (n==null? '—' : (typeof n==='number'? Number(n).toFixed(d): n));
const formatDuration=(seconds)=>{
  if(seconds==null) return '—';
  const s=Math.max(0,Math.floor(seconds));
  const HH=Math.floor(s/3600);
  const MM=String(Math.floor((s%3600)/60)).padStart(2,'0');
  const SS=String(s%60).padStart(2,'0');
  return `${HH}:${MM}:${SS}`;
};

/* --- black preview helper --- */
const BLACK_SVG='data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 360"><rect width="100%" height="100%" fill="black"/></svg>';
function blackify(imgEl,on=true){ if(!imgEl) return; const box=imgEl.closest('.thumb'); if(on){ imgEl.src=BLACK_SVG; box&&box.classList.add('blank'); } else { box&&box.classList.remove('blank'); } }

/* i18n */
const urlLang=new URLSearchParams(location.search).get('lang');
const saved=localStorage.getItem('lang');
const browser=(navigator.language||'').slice(0,2).toLowerCase();
const pick=v=>v&&v.toLowerCase().startsWith('en')?'en':(v&&v.toLowerCase().startsWith('pl')?'pl':null);
const lang=pick(urlLang)||pick(saved)||pick(browser)||'pl';
if(urlLang) localStorage.setItem('lang',lang);
await initI18n(lang); applyDom();
function syncLangMeta(code){
  document.documentElement.setAttribute('lang',code);
  document.title=t('dash.page_title');
}
syncLangMeta(lang);
setTxt('pcHostInfo', window.location.host || '—');
setTxt('pcOriginInfo', window.location.origin || '—');
window.addEventListener('dashboard:langchange',ev=>{
  const next=ev?.detail?.lang;
  if(next) syncLangMeta(next);
});

/* wykres CPU/MEM */
function drawChart(cpuArr=[], memArr=[]){
  const c=el('chart'); if(!c) return; const ctx=c.getContext('2d');
  ctx.clearRect(0,0,c.width,c.height);
  const padL=30,padT=10,padR=10,padB=10; const W=c.width-padL-padR,H=c.height-padT-padB;
  ctx.strokeStyle='#1d3548'; ctx.strokeRect(padL,padT,W,H);
  ctx.fillStyle='#8aa'; ctx.font='10px sans-serif'; ctx.textAlign='right';
  [0,50,100].forEach(yv=>{const y=padT+H-((yv/100)*H); ctx.beginPath(); ctx.moveTo(padL-4,y); ctx.lineTo(padL,y); ctx.strokeStyle='#1d3548'; ctx.stroke(); ctx.fillText(String(yv),padL-6,y+3);});
  function plot(arr,color){ if(!arr||arr.length<2) return; ctx.beginPath(); ctx.lineWidth=1.2; ctx.strokeStyle=color; const n=arr.length; for(let i=0;i<n;i++){ const x=padL+(i*(W/(n-1))); const v=Math.max(0,Math.min(100,Number(arr[i]||0))); const y=padT+H-((v/100)*H); if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);} ctx.stroke(); }
  plot(cpuArr,'#6db3ff'); plot(memArr,'#ffd36d');
}

/* ===== KAMERY ===== */
let lastCamReq=0,lastProcReq=0,lastObstReq=0,lastTrackerReq=0;
let lastSnapAges={raw:null,proc:null,tracker:null};
let lastCamState={vision_enabled:undefined,on:undefined,res:null,fps:null};
let lastObstacle={present:null,confidence:null};
let lastCameraResource=null;
let lastTrackingInfo={};

function formatResourceHolders(list){
  if(!Array.isArray(list) || !list.length) return '';
  return list.map(h=>{
    const pid = h?.pid != null ? String(h.pid) : '?';
    const cmd = h?.cmd || 'proc';
    const svc = h?.service ? ` (${h.service})` : '';
    return `${cmd}#${pid}${svc}`;
  }).join(', ');
}

function cameraResourceSummary(){
  if(!lastCameraResource) return null;
  if(lastCameraResource.error){
    return {state:'error', text:t('dash.camera.resource_error_badge'), tooltip:lastCameraResource.error};
  }
  const holdersTxt = formatResourceHolders(lastCameraResource.holders);
  if(lastCameraResource.free){
    return {state:'free', text:t('dash.camera.resource_free_badge'), tooltip:holdersTxt, holders:holdersTxt};
  }
  return {
    state:'busy',
    text: holdersTxt ? t('dash.camera.resource_busy_with_holder',{holder:holdersTxt}) : t('dash.camera.resource_busy_badge'),
    tooltip: holdersTxt,
    holders: holdersTxt,
  };
}

/* ===== PC SELF STATUS ===== */
function setPcStatus(id, state){
  const node = el(id);
  if(!node) return;
  node.textContent = state?.label || '—';
  node.className = 'pc-status ' + (state?.ok ? 'ok' : 'off');
}

function defaultPort(proto){
  return proto === 'https:' ? '443' : '80';
}

async function refreshPcHealth(){
  const info = {
    live: { ok: false, label: 'offline' },
    ready: { ok: false, label: 'offline' },
  };

  try{
    const r = await fetch('/health/live', { cache: 'no-store' });
    if (r.ok) {
      const j = await r.json().catch(() => null);
      info.live = { ok: true, label: j?.status || 'online' };
    } else {
      info.live = { ok: false, label: `HTTP ${r.status}` };
    }
  } catch {
    info.live = { ok: false, label: 'offline' };
  }

  try{
    const r = await fetch('/health/ready', { cache: 'no-store' });
    const j = await r.json().catch(() => null);
    const ok = r.ok && j?.status === 'ready';
    info.ready = { ok, label: j?.status || (r.ok ? 'ready' : `HTTP ${r.status}`) };
  } catch {
    info.ready = { ok: false, label: 'offline' };
  }

  setPcStatus('pcLiveStatus', info.live);
  setPcStatus('pcReadyStatus', info.ready);
}

function applyPcSystemMetrics(data){
  if(!data) return;
  setTxt('pcCpu', data.cpu_pct != null ? `${fmt(data.cpu_pct,1)}%` : '—');
  if(data.load1 != null && data.load5 != null && data.load15 != null){
    setTxt('pcLoad', `${fmt(data.load1,2)}/${fmt(data.load5,2)}/${fmt(data.load15,2)}`);
  } else {
    setTxt('pcLoad','—');
  }
  if(data.mem_total_mb != null && data.mem_used_mb != null){
    const pct = data.mem_pct != null ? ` (${fmt(data.mem_pct,1)}%)` : '';
    setTxt('pcMem', `${fmt(data.mem_used_mb,1)} / ${fmt(data.mem_total_mb,1)} MB${pct}`);
  } else {
    setTxt('pcMem','—');
  }
  if(data.disk_total_gb != null && data.disk_used_gb != null){
    const pct = data.disk_pct != null ? ` (${fmt(data.disk_pct,1)}%)` : '';
    setTxt('pcDisk', `${fmt(data.disk_used_gb,2)} / ${fmt(data.disk_total_gb,2)} GB${pct}`);
  } else {
    setTxt('pcDisk','—');
  }
  setTxt('pcTemp', data.temp_c != null ? `${fmt(data.temp_c,1)} °C` : '—');
  setTxt('pcUptime', data.uptime_s != null ? formatDuration(data.uptime_s) : '—');
  setTxt('pcUpdatedTs', new Date().toLocaleTimeString());
}

async function refreshPcSystemMetrics(){
  try{
    const r = await fetch('/status/system-pc', { cache: 'no-store' });
    if(!r.ok) throw new Error(`HTTP ${r.status}`);
    const j = await r.json().catch(() => null);
    if(j) applyPcSystemMetrics(j);
  } catch {
    setTxt('pcCpu','—');
    setTxt('pcLoad','—');
    setTxt('pcMem','—');
    setTxt('pcDisk','—');
    setTxt('pcTemp','—');
    setTxt('pcUptime','—');
    setTxt('pcUpdatedTs','błąd');
  }
}

function renderPcServices(items){
  const list = el('pcServiceList');
  if(!list) return;
  if(!items.length){
    list.innerHTML = '<div class="muted">Brak danych</div>';
    return;
  }
  list.innerHTML = '';
  items.forEach((svc) => {
    const row = document.createElement('div');
    row.className = 'pc-service';
    const dot = document.createElement('span');
    let stateCls = 'off';
    if (svc.ok === true) stateCls = 'ok';
    if (svc.ok === null) stateCls = '';
    dot.className = 'pc-service-dot ' + stateCls;
    row.appendChild(dot);

    const body = document.createElement('div');
    body.className = 'pc-service-body';
    const name = document.createElement('div');
    name.className = 'pc-service-name';
    name.textContent = svc.label;
    const meta = document.createElement('div');
    meta.className = 'pc-service-meta';
    meta.textContent = svc.meta + (svc.ok === null ? ' • brak automatycznej kontroli' : '');
    body.appendChild(name);
    body.appendChild(meta);
    row.appendChild(body);
    list.appendChild(row);
  });
}

async function refreshPcServices(){
  const statuses = [];
  for (const svc of PC_SERVICE_CHECKS) {
    const isSkip = svc.skip;
    const target = svc.url.startsWith('http') ? new URL(svc.url) : new URL(svc.url, window.location.origin);
    const meta = `${target.hostname}:${target.port || defaultPort(target.protocol)}${target.pathname}`;
    let ok = null;
    if (!isSkip) {
      try{
        const controller = new AbortController();
        const timeout = setTimeout(() => controller.abort(), 2500);
        const opts = { cache: 'no-store', signal: controller.signal };
        if (svc.noCors) opts.mode = 'no-cors';
        const resp = await fetch(target.toString(), opts);
        clearTimeout(timeout);
        ok = svc.noCors ? true : resp.ok;
      }catch{
        ok = false;
      }
    }
    statuses.push({ label: svc.label, meta, ok });
  }
  renderPcServices(statuses);
}

function setCamBadgeAndMeta(cam){
  const camBadge=el('camBadge');
  const resourceInfo=cameraResourceSummary();
  if(camBadge){
    if(resourceInfo){
      let cls='cam-badge';
      if(resourceInfo.state==='busy') cls+=' on';
      camBadge.className=cls.trim();
      camBadge.textContent=resourceInfo.text;
      if(resourceInfo.tooltip) camBadge.title=resourceInfo.tooltip;
      else camBadge.removeAttribute('title');
    }else{
      const visionOn = cam?.vision_enabled !== false;
      camBadge.textContent = visionOn ? t('dash.camera.vision_on') : t('dash.camera.vision_off');
      camBadge.className   = 'cam-badge' + (visionOn ? ' on' : '');
      camBadge.removeAttribute('title');
    }
  }
  const sbMeta=el('sb_cam_meta');
  if(sbMeta){
    const fpsVal = (cam && cam.fps!=null) ? cam.fps : lastCamState.fps;
    const fpsTxt = fpsVal!=null ? `${fmt(fpsVal,1)} fps` : 'fps: —';
    const extra = resourceInfo && resourceInfo.tooltip ? ` • ${resourceInfo.tooltip}` : '';
    sbMeta.textContent = `${fpsTxt}${extra}`;
  }
}
function setImageSafely(imgEl,url,tagStore){
  const tag=Date.now(); tagStore.value=tag;
  const loader=new Image(); loader.decoding='async'; loader.loading='eager';
  loader.onload=()=>{ if(tagStore.value!==tag) return; imgEl.src=url; blackify(imgEl,false); };
  loader.onerror=()=>{ if(tagStore.value!==tag) return; blackify(imgEl,true); };
  loader.src=url;
}
function refreshCamLegends(){
  const partsRaw=['RAW']; if(lastCamState.res) partsRaw.push(lastCamState.res);
  if(lastCamState.fps!=null) partsRaw.push(`${fmt(lastCamState.fps,1)} fps`);
  if(lastSnapAges.raw!=null) partsRaw.push(`age: ${fmt(lastSnapAges.raw,1)}s`);
  setTxt('leg_cam_txt',partsRaw.join(' • '));

  const partsProc=['PROC']; if(lastCamState.res) partsProc.push(lastCamState.res);
  if(lastSnapAges.proc!=null) partsProc.push(`age: ${fmt(lastSnapAges.proc,1)}s`);
  setTxt('leg_proc_txt',partsProc.join(' • '));

  const partsObst=['OBST','ROI overlay'];
  if(lastObstacle.present!=null) partsObst.push(`present: ${String(lastObstacle.present)}`);
  if(lastObstacle.confidence!=null) partsObst.push(`conf: ${fmt(lastObstacle.confidence,3)}`);
  setTxt('leg_obst_txt',partsObst.join(' • '));

  const partsTracker=[t('dash.tracker.legend')];
  if(lastTrackingInfo && typeof lastTrackingInfo.offset === 'number'){
    partsTracker.push(`${t('dash.tracker.offset')}: ${fmt(lastTrackingInfo.offset,3)}`);
  }else{
    partsTracker.push(t('dash.tracker.offset_none'));
  }
  if(lastTrackingInfo && lastTrackingInfo.mode){
    partsTracker.push(`${t('dash.tracker.mode')}: ${lastTrackingInfo.mode}`);
  }
  if(lastSnapAges.tracker!=null){
    partsTracker.push(`${t('dash.tracker.age')}: ${fmt(lastSnapAges.tracker,1)}s`);
  }
  setTxt('leg_tracker_txt',partsTracker.join(' • '));
}
function visionOff(){
  return (lastCamState.vision_enabled===false)||(lastCamState.on===false);
}
function feedTooOld(kind){
  const age=lastSnapAges[kind];
  return age!=null && age>SNAP_STALE_S;
}
function shouldBlankFeed(kind){
  if(visionOff()) return true;
  if(!kind) return false;
  return feedTooOld(kind);
}
function refreshFeed(imgEl,url,kind,tagStore){
  if(!imgEl) return;
  if(shouldBlankFeed(kind)){ blackify(imgEl,true); return; }
  setImageSafely(imgEl, url, tagStore);
}
async function refreshCamera(){
  const imgCam=el('img_cam'), imgProc=el('img_proc'), imgObst=el('img_obst'), imgTracker=el('img_tracker');
  const bust=Date.now();
  refreshFeed(imgCam, `/vision/cam?t=${bust}`, 'raw', {get value(){return lastCamReq;}, set value(v){lastCamReq=v;}});
  refreshFeed(imgProc, `/vision/edge?t=${bust}`, 'proc', {get value(){return lastProcReq;}, set value(v){lastProcReq=v;}});
  refreshFeed(imgObst, `/snapshots/obst_annot.jpg?t=${bust}`, null, {get value(){return lastObstReq;}, set value(v){lastObstReq=v;}});
  refreshFeed(imgTracker, `/vision/tracker?t=${bust}`, 'tracker', {get value(){return lastTrackerReq;}, set value(v){lastTrackerReq=v;}});
}

async function refreshCameraResource(){
  try{
    const r = await fetch('/api/resource/camera',{cache:'no-store'});
    const data = await r.json().catch(()=>null);
    if(!r.ok) throw new Error((data && data.error) || `HTTP ${r.status}`);
    lastCameraResource = data;
  }catch(e){
    lastCameraResource = {error: String(e.message || e)};
  }
  setCamBadgeAndMeta(lastState?.camera || {});
  try{ applyDevices({state:lastState, health:lastHealth}); }catch{}
}

/* ===== HEALTH ===== */
function updateHealth(h){
  const ok=!!(h && (h.ok===true || h.status==='ok' || h.state==='ok'));
  setTxt('h_status', ok? t('meta.ok'):'degraded'); setCls('h_status', ok?'ok':'bad');

  setTxt('h_uptime', formatDuration(h?.uptime_s));

  const msg=h?.bus?.last_msg_age_s ?? h?.bus?.last_msg_age;
  if(msg!=null) setTxt('h_msg',`${Number(msg).toFixed(1)} s`);

  let hb=h?.bus?.last_heartbeat_age_s ?? h?.bus?.last_hb_age_s ?? h?.bus?.heartbeat_age_s ?? null;
  if(hb==null){
    const ts=h?.bus?.last_heartbeat_ts ?? h?.bus?.heartbeat_ts ?? null;
    if(ts!=null) hb=Math.max(0,(Date.now()/1000)-Number(ts));
  }
  if(hb!=null) setTxt('h_hb',`${Number(hb).toFixed(1)} s`);
}
async function busHeartbeatFallback(){
  try{
    const r=await fetch('/api/bus/health',{cache:'no-store'}); if(!r.ok) return;
    const j=await r.json().catch(()=>null); if(!j) return;
    const lag=j?.bus?.last_msg_age_s ?? j?.bus?.last_msg_age;
    if(lag!=null) setTxt('h_msg',`${Number(lag).toFixed(1)} s`);
    let hb=j?.bus?.last_heartbeat_age_s ?? j?.bus?.last_hb_age_s ?? j?.bus?.heartbeat_age_s;
    if(hb==null){ const ts=j?.bus?.last_heartbeat_ts ?? j?.bus?.heartbeat_ts; if(ts!=null) hb=Math.max(0,(Date.now()/1000)-Number(ts)); }
    if(hb!=null) setTxt('h_hb',`${Number(hb).toFixed(1)} s`);
  }catch{}
}

/* ===== STATE ===== */
let lastHealth=null, lastState=null;

function updateStateUI(s){
  setTxt('p_present',String(!!s.present)); setCls('p_present',s.present?'ok':'bad');
  setTxt('p_conf',fmt(s.confidence,3)); setTxt('p_mode',s.mode||'—');
  setTxt('p_ts',s.ts? new Date(s.ts*1000).toLocaleTimeString():'—');
  setTxt('p_age',(s.age_s!=null? fmt(s.age_s,1)+' s':'—'));
  setTxt('sb_presence_state',s.present? t('dash.status.present'): t('dash.status.idle'));
  setCls('sb_presence','c-pill '+(s.present?'ok':'bad'));
  setTxt('sb_mode',`${t('dash.status.mode')}: ${s.mode||'—'}`);
  setTxt('sb_conf',`${t('dash.status.conf')}: ${fmt(s.confidence,3)}`);

  lastCamState.vision_enabled = s?.camera?.vision_enabled;
  lastCamState.on = s?.camera?.on;
  const resArr=s?.camera?.res;
  lastCamState.res=(Array.isArray(resArr)&&resArr.length===2)?`${resArr[0]}×${resArr[1]}`:null;
  lastCamState.fps=(s?.camera?.fps!=null)? Number(s.camera.fps):null;

  lastTrackingInfo = s?.tracking || {};
  setCamBadgeAndMeta(s?.camera||{});
  refreshCamLegends();
}

/* ===== DEVICES ===== */
function textFromLCD(lcd){
  if(!lcd) return '—';
  const parts=[]; parts.push(lcd.on?'ON':'OFF');
  if(lcd.rot!=null) parts.push('rot '+lcd.rot);
  if(lcd.presenting) parts.push('presenting');
  if(lcd.no_draw) parts.push('no_draw');
  return parts.join(' · ');
}
function applyDevices({state,health}){
  const cam = state?.camera ?? health?.devices?.camera ?? {};
  const resArr = Array.isArray(cam.res) && cam.res.length===2 ? cam.res : null;
  const resTxt = resArr ? `${resArr[0]}×${resArr[1]}` : (lastCamState.res || '');
  const fpsVal = cam.fps!=null ? cam.fps : lastCamState.fps;
  const resourceInfo = cameraResourceSummary();
  const holdersTxt = resourceInfo?.holders || formatResourceHolders(lastCameraResource?.holders);
  const camParts=[];
  const camStatus = typeof cam.on === 'boolean' ? cam.on : (resourceInfo ? resourceInfo.state==='busy' : null);
  if(camStatus !== null){
    camParts.push(camStatus ? 'ON' : 'OFF');
  }
  if(cam.mode) camParts.push(cam.mode);
  if(resTxt) camParts.push(resTxt);
  if(fpsVal!=null) camParts.push(`${fmt(fpsVal,1)} fps`);
  if(resourceInfo){
    if(resourceInfo.state==='busy') camParts.push(t('dash.camera.resource_busy_badge'));
    else if(resourceInfo.state==='free') camParts.push(t('dash.camera.resource_free_badge'));
    else if(resourceInfo.state==='error') camParts.push(t('dash.camera.resource_error_badge'));
  }
  if(holdersTxt) camParts.push(holdersTxt);
  setTxt('d_cam', camParts.filter(Boolean).join(' · ') || '—');
  let camClass='muted';
  if(camStatus === true) camClass='ok';
  else if(camStatus === false) camClass='muted';
  else if(resourceInfo){
    if(resourceInfo.state==='busy') camClass='ok';
    else if(resourceInfo.state==='error') camClass='bad';
    else camClass='muted';
  }
  setCls('d_cam', camClass);

  const lcd = state?.lcd ?? health?.devices?.lcd ?? null;
  const lcdTxt=textFromLCD(lcd);
  setTxt('d_lcd',lcdTxt); setCls('d_lcd',(lcd && lcd.on)?'ok':'muted');

  const xgo = state?.xgo ?? health?.devices?.xgo ?? {};
  const imuTxt=(xgo.on?'ON':'OFF') + (xgo.imu_ok===true?' · OK':(xgo.on?' · ?':''));
  setTxt('d_xgo_imu',imuTxt); setCls('d_xgo_imu',(xgo.on && xgo.imu_ok)?'ok':'muted');

  const poseParts=[];
  if(Array.isArray(xgo.pose) && xgo.pose.some(v=>v!=null)){
    poseParts.push(xgo.pose.filter(v=>v!=null).map(v=>Number(v).toFixed(1)).join('°, ')+'°');
  }
  if(typeof xgo.pose==='string' && xgo.pose.trim()) poseParts.push(xgo.pose.trim());
  if(xgo.roll!=null)  poseParts.push(`r ${fmt(xgo.roll,1)}°`);
  if(xgo.pitch!=null) poseParts.push(`p ${fmt(xgo.pitch,1)}°`);
  if(xgo.yaw!=null)   poseParts.push(`y ${fmt(xgo.yaw,1)}°`);
  setTxt('d_xgo_pose',poseParts.length? poseParts.join(' · ') : '—');

  const battPct=(xgo.battery_pct ?? xgo.batt_pct ?? xgo.battery?.pct ?? xgo.battery);
  setTxt('d_xgo_batt',(battPct!=null? `${Number(battPct).toFixed(0)}%`:'—'));
  setCls('d_xgo_batt',(battPct!=null?'ok':'muted'));

  const fw = xgo.fw ?? state?.fw ?? health?.devices?.xgo?.fw;
  if (fw) setTxt('ci_fw', fw);
}

/* ===== OBSTACLE + HISTOGRAM ===== */
function drawBinsCanvas({bins=null,edge_pct=null,low=null,high=null}={}){
  const c=el('binsCanvas'); if(!c) return; const ctx=c.getContext('2d');
  ctx.clearRect(0,0,c.width,c.height);
  const padL=30,padT=10,padR=10,padB=16; const W=c.width-padL-padR,H=c.height-padT-padB;
  ctx.strokeStyle='#1d3548'; ctx.strokeRect(padL,padT,W,H);
  ctx.fillStyle='#8aa'; ctx.font='10px sans-serif'; ctx.textAlign='right';
  [0,0.5,1].forEach(v=>{const y=padT+H-(v*H); ctx.beginPath(); ctx.moveTo(padL-4,y); ctx.lineTo(padL,y); ctx.strokeStyle='#1d3548'; ctx.stroke(); ctx.fillText(String(Math.round(v*100)),padL-6,y+3);});
  if(low!=null){ const y=padT+H-(Math.max(0,Math.min(1,low))*H); ctx.strokeStyle='#2b8a3e'; ctx.setLineDash([4,3]); ctx.beginPath(); ctx.moveTo(padL,y); ctx.lineTo(padL+W,y); ctx.stroke(); ctx.setLineDash([]);}
  if(high!=null){ const y=padT+H-(Math.max(0,Math.min(1,high))*H); ctx.strokeStyle='#d89d2b'; ctx.setLineDash([4,3]); ctx.beginPath(); ctx.moveTo(padL,y); ctx.lineTo(padL+W,y); ctx.stroke(); ctx.setLineDash([]);}
  if(Array.isArray(bins) && bins.length){
    const n=bins.length; const gap=2; const barW=(W-(gap*(n-1)))/n;
    ctx.fillStyle='#6db3ff';
    bins.forEach((v,i)=>{ const h=H*Math.max(0,Math.min(1,Number(v)||0)); const x=padL+i*(barW+gap); const y=padT+H-h; ctx.fillRect(x,y,Math.max(1,barW),h);});
  }else if(edge_pct!=null){
    const h=H*Math.max(0,Math.min(1,Number(edge_pct)||0)); ctx.fillStyle='#6db3ff';
    ctx.fillRect(padL+W*0.25,padT+H-h,W*0.5,h);
  }
}
function applyObstacle(o){
  const present=!!o.present;
  const conf=(o.confidence!=null)? Number(o.confidence).toFixed(3):null;
  const pct=(o.edge_pct!=null)? Number(o.edge_pct).toFixed(3):'—';
  const cls=present?'ok':'bad';
  const set=(id,txt,c)=>{const e=document.getElementById(id); if(!e) return; e.textContent=txt; if(c) e.className=c;};
  set('obs_present',String(present),cls);
  set('obs_conf',conf!=null?conf:'—');
  set('obs_edge',pct);

  lastObstacle.present=present;
  lastObstacle.confidence=(conf!=null? Number(conf):null);
  refreshCamLegends();

  const low=o?.diag?.t_low ?? null;
  const high=o?.diag?.t_high ?? null;
  const bins=o?.diag?.bins ?? null;
  const edge_raw=o?.diag?.edge_pct_raw ?? o?.edge_pct ?? null;

  drawBinsCanvas({bins,edge_pct:edge_raw,low,high});
  const txt=document.getElementById('binsLegendTxt');
  if(txt){
    const lowTxt=low!=null? Number(low).toFixed(2):'—';
    const highTxt=high!=null? Number(high).toFixed(2):'—';
    const epTxt=edge_raw!=null? Number(edge_raw).toFixed(3):'—';
    txt.textContent=`LOW/HIGH: ${lowTxt} / ${highTxt} • edge_pct: ${epTxt}`;
  }
}
async function fetchObstacle(){
  try{ const r=await fetch('/vision/obstacle',{cache:'no-store'}); if(!r.ok) return;
       const j=await r.json().catch(()=>null); if(j) applyObstacle(j);}catch{}
}

/* ===== SNAP INFO ===== */
function applySnapInfo(si){
  const rawAge=si?.raw?.age_s; const procAge=si?.proc?.age_s; const trackerAge=si?.tracker?.age_s;
  lastSnapAges.raw=rawAge ?? null; lastSnapAges.proc=procAge ?? null; lastSnapAges.tracker=trackerAge ?? null;
  setTxt('age_raw',rawAge!=null? fmt(rawAge,1)+' s':'—');
  setTxt('age_proc',procAge!=null? fmt(procAge,1)+' s':'—');
  setTxt('age_tracker',trackerAge!=null? fmt(trackerAge,1)+' s':'—');
  const ok=(rawAge!=null && rawAge<=SNAP_STALE_S);
  setCls('sb_cam','c-pill '+(ok?'ok':'bad'));
  const camText='CAM: '+(rawAge!=null? fmt(rawAge,1)+'s':'—')+' / '+(procAge!=null? fmt(procAge,1)+'s':'—');
  const trackerText=trackerAge!=null? ' • TRK: '+fmt(trackerAge,1)+'s':'';
  setTxt('sb_cam',camText+trackerText);
  const imgCam=el('img_cam'); const imgProc=el('img_proc');
  if(rawAge!=null && rawAge>SNAP_STALE_S) blackify(imgCam,true); else blackify(imgCam,false);
  if(procAge!=null && procAge>SNAP_STALE_S) blackify(imgProc,true); else blackify(imgProc,false);
  refreshCamLegends();
}
async function refreshSnapInfo(){
  try{ const r=await fetch('/vision/snap-info',{cache:'no-store'}); if(!r.ok) return;
       const j=await r.json().catch(()=>null); if(j) applySnapInfo(j);}catch{}
}

/* ===== SYSINFO ===== */
function applySysinfo(si){
  if(!si) return;
  setTxt('ci_cpu', si.cpu_pct!=null? fmt(si.cpu_pct,1)+'%':'—');
  setTxt('ci_load', `${fmt(si.load1,2)}/${fmt(si.load5,2)}/${fmt(si.load15,2)}`);
  const mb=v=> (v==null ? '—' : Number(v).toFixed(1)+' MB');
  if(si.mem_total_mb!=null && si.mem_used_mb!=null){
    const pct=si.mem_pct!=null? ` (${fmt(si.mem_pct,1)}%)`:'';
    setTxt('ci_mem', `${mb(si.mem_used_mb)} / ${mb(si.mem_total_mb)}${pct}`);
  } else setTxt('ci_mem','—');
  const gb=v=> (v==null ? '—' : Number(v).toFixed(1)+' GB');
  if(si.disk_total_gb!=null && si.disk_used_gb!=null){
    const pct=si.disk_pct!=null? ` (${fmt(si.disk_pct,1)}%)`:'';
    setTxt('ci_disk', `${gb(si.disk_used_gb)} / ${gb(si.disk_total_gb)}${pct}`);
  } else setTxt('ci_disk','—');
  setTxt('ci_os', si.os_release || si.platform || '—');
  setTxt('d_temp', (si.temp_c!=null ? fmt(si.temp_c,1)+' °C' : '—'));
  const fw = si.fw || si.fw_version || si.firmware || si.version;
  if (fw) setTxt('ci_fw', fw);
  drawChart(si.hist_cpu || [], si.hist_mem || []);
}

/* ===== API Metrics ===== */
async function refreshApiMetrics(){
  try{
    const r = await fetch('/api/app-metrics', {cache:'no-store'});
    if(!r.ok) return;
    const j = await r.json().catch(()=>null);
    if(!j || !j.metrics) return;
    
    const m = j.metrics;
    
    // Format: "OK / Error"
    setTxt('metric_control', `${m.control?.ok ?? 0} / ${m.control?.error ?? 0}`);
    setTxt('metric_navigator', `${m.navigator?.ok ?? 0} / ${m.navigator?.error ?? 0}`);
    setTxt('metric_voice', `${m.voice?.ok ?? 0} / ${m.voice?.error ?? 0}`);
    setTxt('metric_google_home', `${m.google_home?.ok ?? 0} / ${m.google_home?.error ?? 0}`);
    setTxt('metric_chat', `${m.chat?.ok ?? 0} / ${m.chat?.error ?? 0}`);
    setTxt('metric_face', `${m.face?.ok ?? 0} / ${m.face?.error ?? 0}`);
    
    // Total Errors - highlighted
    const totalErr = j.total_errors ?? 0;
    setTxt('metric_total_errors', totalErr);
    setCls('metric_total_errors', totalErr > 0 ? 'bad' : 'ok');
  }catch{}
}

/* ===== Poll ===== */
async function tick(){
  try{ lastHealth = await (await fetch('/healthz',{cache:'no-store'})).json(); updateHealth(lastHealth);}catch{}
  try{ await busHeartbeatFallback(); }catch{}
  try{ lastState  = await (await fetch('/state',{cache:'no-store'})).json(); updateStateUI(lastState);}catch{}
  try{ applyDevices({state:lastState, health:lastHealth}); }catch{}
  try{ await refreshCameraResource(); }catch{}

  try{ const si = await (await fetch('/sysinfo',{cache:'no-store'})).json(); applySysinfo(si);}catch{}

  try{ await refreshSnapInfo(); }catch{}
  try{ await refreshCamera(); }catch{}
}

/* lekkie SSE */
function startSSE(){ try{ const es=new EventSource('/events'); es.onmessage=()=>{}; es.onerror=()=>{}; }catch{} }

setInterval(tick, REFRESH_MS); tick();
setInterval(fetchObstacle, REFRESH_MS); fetchObstacle();
setInterval(refreshApiMetrics, REFRESH_MS); refreshApiMetrics();
setInterval(refreshPcHealth, PC_SYSTEM_REFRESH_MS); refreshPcHealth();
setInterval(refreshPcSystemMetrics, PC_SYSTEM_REFRESH_MS); refreshPcSystemMetrics();
setInterval(refreshPcServices, PC_SERVICE_REFRESH_MS); refreshPcServices();
startSSE();
</script>
<script type="module" src="/web/assets/menu.js"></script>
</body>
</html>
