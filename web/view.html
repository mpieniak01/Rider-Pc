<!doctype html>
<!--
  Migrated to dashboard_base.html template structure
  Uses shared layout classes: .layout-header, .layout-main, .layout-footer
-->
<html lang="pl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Rider-PC: Przegląd</title>
<link rel="stylesheet" href="/web/assets/dashboard-common.css">
  <link rel="stylesheet" href="/web/assets/pages/view.css">
</head>
<body data-page="view" class="page page-view">
  <!-- Header with Menu -->
  <header class="layout-header" data-dashboard-menu-target></header>

  <!-- Main content -->
  <main class="layout-main">
  <header class="page-header">
    <div class="page-header__titles">
      <h1 class="page-title"><span class="brand-accent">Rider-PC</span>: <span class="page-title-text" data-i18n="dash.page_title">Przegląd</span></h1>
    </div>
  </header>
  <div class="c-hint text-legend">
    <span data-i18n="dash.hint_prefix">Auto-refresh co ≈ 2 s.</span>
    <span data-i18n="dash.hint_endpoints">Endpointy:</span>
    <a href="/healthz">/healthz</a>, <a href="/state">/state</a>, <a href="/sysinfo">/sysinfo</a>, <a href="/vision/snap-info">/vision/snap-info</a>
  </div>

  <!-- RZĄD 1 -->
  <div class="l-grid l-grid--4 view-row view-row--1">
    <div class="c-card">
      <h3 data-i18n="dash.system.title">System</h3>
      <div class="c-kv">
        <div data-i18n="dash.system.host">Host</div><div id="ci_host" class="muted">—</div>
        <div data-i18n="dash.system.cpu_est">cpu (szac.)</div><div id="ci_cpu" class="muted">—</div>
        <div data-i18n="dash.system.load">load (1/5/15)</div><div id="ci_load" class="muted">—</div>
        <div data-i18n="dash.system.mem">pamięć</div><div id="ci_mem" class="muted">—</div>
        <div data-i18n="dash.system.disk">dysk</div><div id="ci_disk" class="muted">—</div>
        <div data-i18n="dash.system.os">system</div><div id="ci_os" class="muted">—</div>
        <div data-i18n="dash.system.fw">fw</div><div id="ci_fw" class="muted">—</div>
      </div>
    </div>

    <div class="c-card">
      <h3 data-i18n="dash.devices.title">Urządzenia</h3>
      <div class="c-kv">
        <div data-i18n="dash.devices.camera">kamera</div><div id="d_cam" class="muted">—</div>
        <div data-i18n="dash.devices.lcd">lcd</div><div id="d_lcd" class="muted">—</div>
        <div data-i18n="dash.devices.xgo_imu">xgo.imu</div><div id="d_xgo_imu" class="muted">—</div>
        <div data-i18n="dash.devices.xgo_pose">xgo.pozycja</div><div id="d_xgo_pose" class="muted">—</div>
        <div data-i18n="dash.devices.xgo_battery">xgo.bateria</div><div id="d_xgo_batt" class="muted">—</div>
        <div data-i18n="dash.devices.temp">temp</div><div id="d_temp" class="muted">—</div>
      </div>
    </div>

    <div class="c-card">
      <h3 data-i18n="dash.history.title">Historia (60 s) — CPU / MEM</h3>
      <canvas id="chart" width="300" height="140"></canvas>
      <div class="c-legend">
        <span><i class="c-legend__dot cpu"></i><span class="text-legend" data-i18n="dash.history.cpu">cpu%</span></span>
        <span><i class="c-legend__dot mem"></i><span class="text-legend" data-i18n="dash.history.mem">mem%</span></span>
      </div>
    </div>

    <div class="c-card">
      <h3 class="cam-card-title" data-i18n="dash.camera.title">
        Kamera
        <span id="camBadge" class="cam-badge">…</span>
      </h3>
      <div class="c-thumb">
        <img id="img_cam" class="cam-img" src="/camera/placeholder" alt="kamera" decoding="async" loading="lazy">
      </div>
      <div class="c-legend">
        <span><i class="c-legend__dot raw"></i><span class="text-legend" id="leg_cam_txt">RAW • age: —</span></span>
      </div>
    </div>
  </div>

  <!-- RZĄD 2 -->
  <div class="l-grid l-grid--4 view-row view-row--2">
    <div class="c-card">
      <h3 data-i18n="dash.health.title">Health</h3>
      <div class="c-kv">
        <div data-i18n="dash.health.status">status</div><div id="h_status" class="ok">OK</div>
        <div data-i18n="dash.health.uptime">uptime</div><div id="h_uptime" class="muted">—</div>
        <div data-i18n="dash.health.bus_last_msg_age">bus.last_msg_age</div><div id="h_msg" class="muted">—</div>
        <div data-i18n="dash.health.bus_last_heartbeat_age">bus.last_heartbeat_age</div><div id="h_hb" class="muted">—</div>
      </div>
    </div>

    <div class="c-card">
      <h3 data-i18n="dash.obstacle.title">Obstacle</h3>
      <div class="c-kv">
        <div data-i18n="dash.obstacle.present">present</div><div id="obs_present" class="muted">—</div>
        <div data-i18n="dash.obstacle.confidence">confidence</div><div id="obs_conf" class="muted">—</div>
        <div data-i18n="dash.obstacle.edge_pct">edge_pct</div><div id="obs_edge" class="muted">—</div>
      </div>
    </div>

    <div class="c-card">
      <h3 data-i18n="dash.roi_edges.title">ROI histogram — edges</h3>
      <canvas id="binsCanvas" width="300" height="140"></canvas>
      <div class="c-legend">
        <span><i class="c-legend__dot edge"></i><span id="binsLegendTxt">LOW/HIGH: — / — • edge_pct: —</span></span>
      </div>
    </div>

    <div class="c-card">
      <h3 data-i18n="dash.camera_proc.title">Kamera — PROC</h3>
      <div class="c-thumb">
        <img id="img_proc" class="cam-img" src="/camera/placeholder" alt="processed camera" decoding="async" loading="lazy">
      </div>
      <div class="c-legend">
        <span><i class="c-legend__dot proc"></i><span class="text-legend" id="leg_proc_txt">PROC • age: —</span></span>
      </div>
    </div>
  </div>

  <!-- RZĄD 3: API Metrics -->
  <div class="l-grid l-grid--4 view-row view-row--3">
    <div class="c-card">
      <h3 data-i18n="dash.api_metrics.title">API Metrics</h3>
      <div class="c-kv">
        <div data-i18n="dash.api_metrics.control">Control</div><div id="metric_control">—</div>
        <div data-i18n="dash.api_metrics.navigator">Navigator</div><div id="metric_navigator">—</div>
        <div data-i18n="dash.api_metrics.voice">Voice</div><div id="metric_voice">—</div>
        <div data-i18n="dash.api_metrics.google_home">GoogleHome</div><div id="metric_google_home">—</div>
        <div data-i18n="dash.api_metrics.chat">Chat</div><div id="metric_chat">—</div>
        <div data-i18n="dash.api_metrics.face">Face</div><div id="metric_face">—</div>
        <div class="metric-highlight" data-i18n="dash.api_metrics.total">Total Errors</div><div id="metric_total_errors" class="bad metric-highlight">—</div>
      </div>
      <div class="c-hint c-hint--sub" data-i18n="dash.api_metrics.hint">Interactive API call metrics (OK / Error)</div>
    </div>

    <div class="c-card">
      <h3 data-i18n="dash.snap.title">Snap freshness</h3>
      <div class="c-kv">
        <div data-i18n="dash.snap.raw_age">raw.age</div><div id="age_raw" class="muted">—</div>
        <div data-i18n="dash.snap.proc_age">proc.age</div><div id="age_proc" class="muted">—</div>
      </div>
      <div class="c-hint c-hint--sub"><span data-i18n="dash.snap.hint_prefix">Źródło:</span> <code>/vision/snap-info</code></div>
    </div>

    <div class="c-card">
      <h3 data-i18n="dash.repo.title">Repozytorium</h3>
      <div class="c-kv">
        <div data-i18n="dash.repo.name">projekt</div><div><a href="https://github.com/mpieniak01/Rider-Pc" target="_blank">Rider-PC</a></div>
        <div data-i18n="dash.repo.github">GitHub</div><div><a href="https://github.com/mpieniak01" target="_blank">@mpieniak01</a></div>
      </div>
    </div>

    <div class="c-card">
      <h3 data-i18n="dash.camera_obst.title">Camera — OBST (annot)</h3>
      <div class="c-thumb">
        <img id="img_obst" class="cam-img" src="/camera/placeholder" alt="obstacle annotated" decoding="async" loading="lazy">
      </div>
      <div class="c-legend">
        <span><i class="c-legend__dot obst"></i><span class="text-legend" id="leg_obst_txt">OBST • ROI overlay</span></span>
      </div>
    </div>
  </div>

  <!-- RZĄD 4: System PC / Usługi / Historia / TRACKER -->
  <div class="l-grid l-grid--4 view-row view-row--4">
    <div class="c-card">
      <h3 data-i18n="dash.pc_system.title">System PC</h3>
      <div class="c-kv">
        <div data-i18n="dash.pc_system.host">Host</div><div id="pcHostInfo">—</div>
        <div data-i18n="dash.pc_system.cpu">CPU (%)</div><div id="pcCpu">—</div>
        <div data-i18n="dash.pc_system.load">Load (1/5/15)</div><div id="pcLoad">—</div>
        <div data-i18n="dash.pc_system.mem">Pamięć</div><div id="pcMem">—</div>
        <div data-i18n="dash.pc_system.disk">Dysk</div><div id="pcDisk">—</div>
        <div data-i18n="dash.pc_system.os">System</div><div id="pcOs">—</div>
        <div data-i18n="dash.pc_system.distro">Dystrybucja</div><div id="pcDistro">—</div>
        <div data-i18n="dash.pc_system.uptime">Uptime</div><div id="pcUptime">—</div>
      </div>
      <div class="c-hint c-hint--sub" data-i18n="dash.pc_system.hint">Dane z /status/system-pc lokalnego serwera Rider-PC.</div>
    </div>

    <div class="c-card">
      <h3 data-i18n="dash.pc_services.title">Usługi PC</h3>
      <div id="pcServiceList" class="pc-service-list">
        <div class="muted" data-i18n="dash.pc_services.loading">Trwa sprawdzanie...</div>
      </div>
      <div class="c-hint c-hint--sub" data-i18n="dash.pc_services.hint">Status lokalnych endpointów Rider-PC.</div>
    </div>

    <div class="c-card">
      <h3 data-i18n="dash.history_pc_title">Historia (60 s) — PC CPU / MEM</h3>
      <canvas id="chartPc" width="300" height="140"></canvas>
      <div class="c-legend">
        <span><i class="c-legend__dot cpu"></i><span>cpu%</span></span>
        <span><i class="c-legend__dot mem"></i><span>mem%</span></span>
      </div>
    </div>

    <div class="c-card">
      <h3 data-i18n="dash.camera_tracker.title">Camera — TRACKER (Follow Me)</h3>
      <div class="c-thumb">
        <img id="img_tracker" class="cam-img" src="/camera/placeholder" alt="tracker with FPS and detection" decoding="async" loading="lazy">
      </div>
      <div class="c-legend">
        <span><i class="c-legend__dot raw"></i><span class="text-legend" id="leg_tracker_txt">TRACKER • FPS + detection circle</span></span>
      </div>
    </div>
  </div>

  <!-- RZĄD 5: MCP Tools -->
  <div class="l-grid l-grid--4 view-row view-row--5">
    <div class="c-card">
      <h3 data-i18n="dash.mcp.title">MCP Tools</h3>
      <div class="c-kv">
        <div data-i18n="dash.mcp.total_tools">Narzędzia</div><div id="mcpTotalTools" class="muted">—</div>
        <div data-i18n="dash.mcp.invocations">Wywołania</div><div id="mcpInvocations" class="muted">—</div>
        <div data-i18n="dash.mcp.last_tool">Ostatnie</div><div id="mcpLastTool" class="muted">—</div>
        <div data-i18n="dash.mcp.status">Status</div><div id="mcpStatus" class="ok">aktywny</div>
      </div>
      <div class="c-hint c-hint--sub" data-i18n="dash.mcp.hint">Model Context Protocol – narzędzia AI.</div>
    </div>

    <div class="c-card">
      <h3 data-i18n="dash.mcp.tools_list">Lista narzędzi</h3>
      <div id="mcpToolsList" class="mcp-tools-list">
        <div class="muted" data-i18n="dash.mcp.loading">Ładowanie...</div>
      </div>
    </div>

    <div class="c-card">
      <h3 data-i18n="dash.mcp.recent_calls">Ostatnie wywołania</h3>
      <div id="mcpRecentCalls" class="mcp-recent-calls">
        <div class="muted" data-i18n="dash.mcp.no_calls">Brak wywołań</div>
      </div>
    </div>

    <div class="c-card">
      <h3 data-i18n="dash.mcp.config">Konfiguracja MCP</h3>
      <div class="c-kv">
        <div data-i18n="dash.mcp.standalone">Standalone</div><div id="mcpStandalone" class="muted">—</div>
        <div data-i18n="dash.mcp.port">Port</div><div id="mcpPort" class="muted">—</div>
      </div>
      <div class="c-hint c-hint--sub" data-i18n="dash.mcp.config_hint">Ustawienia MCP z /api/mcp/resources.</div>
    </div>
  </div>

  </main>

  <!-- Footer -->
  <footer class="layout-footer" data-dashboard-footer-target></footer>

<script type="module">
import { initI18n, applyDom, t } from '/web/assets/i18n.js?v=3';

const REFRESH_MS = 2000;
const SNAP_STALE_S = 5;
const PC_SYSTEM_REFRESH_MS = 5000;
const PC_SERVICE_REFRESH_MS = 7000;
const PC_SERVICE_CHECKS = [
  { label: 'Panel /health/live', url: '/health/live', noCors: false },
  { label: 'Panel /metrics', url: '/metrics', noCors: false },
  { label: 'Prometheus 9090', url: 'http://127.0.0.1:9090/-/ready', noCors: true },
  { label: 'Grafana 3000', url: 'http://127.0.0.1:3000/api/health', noCors: true },
  { label: 'Redis 6379', url: 'redis://127.0.0.1:6379', skip: true },
];

const el = id=>document.getElementById(id);
const setTxt=(id,txt)=>{const e=el(id); if(e) e.textContent=txt}
const setCls=(id,cls)=>{const e=el(id); if(e) e.className=cls}
const fmt=(n,d=1)=> (n==null? '—' : (typeof n==='number'? Number(n).toFixed(d): n));
const formatDuration=(seconds)=>{
  if(seconds==null) return '—';
  const s=Math.max(0,Math.floor(seconds));
  const HH=Math.floor(s/3600);
  const MM=String(Math.floor((s%3600)/60)).padStart(2,'0');
  const SS=String(s%60).padStart(2,'0');
  return `${HH}:${MM}:${SS}`;
};

function pushFooterUpdate(partial){
  if (window.dashboardFooter?.update) {
    window.dashboardFooter.update(partial);
    return;
  }
  if (!Array.isArray(window.__footerPending)) {
    window.__footerPending = [];
  }
  window.__footerPending.push(partial);
}

/* --- black preview helper --- */
const BLACK_SVG='data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 360"><rect width="100%" height="100%" fill="black"/></svg>';
function blackify(imgEl,on=true){ if(!imgEl) return; const box=imgEl.closest('.thumb'); if(on){ imgEl.src=BLACK_SVG; box&&box.classList.add('blank'); } else { box&&box.classList.remove('blank'); } }

/* i18n */
const urlLang=new URLSearchParams(location.search).get('lang');
const saved=localStorage.getItem('lang');
const browser=(navigator.language||'').slice(0,2).toLowerCase();
const pick=v=>v&&v.toLowerCase().startsWith('en')?'en':(v&&v.toLowerCase().startsWith('pl')?'pl':null);
const lang=pick(urlLang)||pick(saved)||pick(browser)||'pl';
if(urlLang) localStorage.setItem('lang',lang);
await initI18n(lang); applyDom();
function syncLangMeta(code){
  document.documentElement.setAttribute('lang',code);
  document.title=`Rider-PC: ${t('dash.page_title')}`;
}
syncLangMeta(lang);
const hostWithPort = window.location.host || '—';
setTxt('pcHostInfo', hostWithPort.split(':')[0]);
window.addEventListener('dashboard:langchange',ev=>{
  const next=ev?.detail?.lang;
  if(next) syncLangMeta(next);
});

/* wykres CPU/MEM */
function drawChart(cpuArr=[], memArr=[], canvasId='chart'){
  const c=el(canvasId); if(!c) return; const ctx=c.getContext('2d');
  ctx.clearRect(0,0,c.width,c.height);
  const padL=30,padT=10,padR=10,padB=10; const W=c.width-padL-padR,H=c.height-padT-padB;
  ctx.strokeStyle='#1d3548'; ctx.strokeRect(padL,padT,W,H);
  ctx.fillStyle='#8aa'; ctx.font='10px sans-serif'; ctx.textAlign='right';
  [0,50,100].forEach(yv=>{const y=padT+H-((yv/100)*H); ctx.beginPath(); ctx.moveTo(padL-4,y); ctx.lineTo(padL,y); ctx.strokeStyle='#1d3548'; ctx.stroke(); ctx.fillText(String(yv),padL-6,y+3);});
  function plot(arr,color){ if(!arr||arr.length<2) return; ctx.beginPath(); ctx.lineWidth=1.2; ctx.strokeStyle=color; const n=arr.length; for(let i=0;i<n;i++){ const x=padL+(i*(W/(n-1))); const v=Math.max(0,Math.min(100,Number(arr[i]||0))); const y=padT+H-((v/100)*H); if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);} ctx.stroke(); }
  plot(cpuArr,'#6db3ff'); plot(memArr,'#ffd36d');
}

/* ===== KAMERY ===== */
let lastCamReq=0,lastProcReq=0,lastObstReq=0,lastTrackerReq=0;
let lastSnapAges={raw:null,proc:null,tracker:null};
let lastCamState={vision_enabled:undefined,on:undefined,res:null,fps:null};
let lastObstacle={present:null,confidence:null};
let lastCameraResource=null;
let lastTrackingInfo={};

function formatResourceHolders(list){
  if(!Array.isArray(list) || !list.length) return '';
  return list.map(h=>{
    const pid = h?.pid != null ? String(h.pid) : '?';
    const cmd = h?.cmd || 'proc';
    const svc = h?.service ? ` (${h.service})` : '';
    return `${cmd}#${pid}${svc}`;
  }).join(', ');
}

function cameraResourceSummary(){
  if(!lastCameraResource) return null;
  if(lastCameraResource.error){
    return {state:'error', text:t('dash.camera.resource_error_badge'), tooltip:lastCameraResource.error};
  }
  const holdersTxt = formatResourceHolders(lastCameraResource.holders);
  if(lastCameraResource.free){
    return {state:'free', text:t('dash.camera.resource_free_badge'), tooltip:holdersTxt, holders:holdersTxt};
  }
  return {
    state:'busy',
    text: holdersTxt ? t('dash.camera.resource_busy_with_holder',{holder:holdersTxt}) : t('dash.camera.resource_busy_badge'),
    tooltip: holdersTxt,
    holders: holdersTxt,
  };
}

/* ===== PC SELF STATUS ===== */
function defaultPort(proto){
  return proto === 'https:' ? '443' : '80';
}

function applyPcSystemMetrics(data){
  if(!data) return;
  const primaryOs = data.platform || data.os || data.kernel || data.version;
  setTxt('pcOs', primaryOs || '—');
  const distroPrimary = data.os_release || data.distribution || data.distribution_name;
  const distroVersion = data.distribution_version;
  const distroParts=[];
  if(distroPrimary) distroParts.push(distroPrimary);
  if(distroVersion && (!distroParts.length || distroVersion!==distroParts[distroParts.length-1])) distroParts.push(distroVersion);
  setTxt('pcDistro', distroParts.join(' · ') || '—');
  const cpuPct = data.cpu_pct != null ? Number(data.cpu_pct) : null;
  if(cpuPct!=null) setTxt('pcCpu', `${fmt(cpuPct,1)}%`);
  else setTxt('pcCpu','—');
  if(data.load1 != null && data.load5 != null && data.load15 != null){
    setTxt('pcLoad', `${fmt(data.load1,2)}/${fmt(data.load5,2)}/${fmt(data.load15,2)}`);
  } else {
    setTxt('pcLoad','—');
  }
  let memPct = null;
  if(data.mem_total_mb != null && data.mem_used_mb != null){
    memPct = data.mem_pct != null ? Number(data.mem_pct) : (data.mem_total_mb ? (data.mem_used_mb / data.mem_total_mb) * 100 : null);
    const pct = memPct != null ? ` (${fmt(memPct,1)}%)` : '';
    setTxt('pcMem', `${fmt(data.mem_used_mb,1)} / ${fmt(data.mem_total_mb,1)} MB${pct}`);
  } else {
    setTxt('pcMem','—');
  }
  if(data.disk_total_gb != null && data.disk_used_gb != null){
    const pct = data.disk_pct != null ? ` (${fmt(data.disk_pct,1)}%)` : '';
    setTxt('pcDisk', `${fmt(data.disk_used_gb,2)} / ${fmt(data.disk_total_gb,2)} GB${pct}`);
  } else {
    setTxt('pcDisk','—');
  }
  setTxt('pcUptime', data.uptime_s != null ? formatDuration(data.uptime_s) : '—');
  if(cpuPct!=null){
    pcHistCpu.push(Math.max(0, Math.min(100, cpuPct)));
    if(pcHistCpu.length>PC_HISTORY_LIMIT) pcHistCpu.shift();
  }
  if(memPct!=null){
    pcHistMem.push(Math.max(0, Math.min(100, memPct)));
    if(pcHistMem.length>PC_HISTORY_LIMIT) pcHistMem.shift();
  }
  drawChart(pcHistCpu, pcHistMem, 'chartPc');
}

async function refreshPcSystemMetrics(){
  try{
    const r = await fetch('/status/system-pc', { cache: 'no-store' });
    if(!r.ok) throw new Error(`HTTP ${r.status}`);
    const j = await r.json().catch(() => null);
    if(j) applyPcSystemMetrics(j);
  } catch {
    setTxt('pcCpu','—');
    setTxt('pcLoad','—');
    setTxt('pcMem','—');
    setTxt('pcDisk','—');
    setTxt('pcUptime','—');
    setTxt('pcOs','—');
    setTxt('pcDistro','—');
  }
}

function renderPcServices(items){
  const list = el('pcServiceList');
  if(!list) return;
  if(!items.length){
    list.innerHTML = `<div class="muted">${t('dash.pc_services.empty')}</div>`;
    return;
  }
  list.innerHTML = '';
  items.forEach((svc) => {
    const row = document.createElement('div');
    row.className = 'pc-service';
    const dot = document.createElement('span');
    let stateCls = 'off';
    if (svc.ok === true) stateCls = 'ok';
    if (svc.ok === null) stateCls = '';
    dot.className = 'pc-service-dot ' + stateCls;
    row.appendChild(dot);

    const body = document.createElement('div');
    body.className = 'pc-service-body';
    const name = document.createElement('div');
    name.className = 'pc-service-name';
    name.textContent = svc.label;
    const meta = document.createElement('div');
    meta.className = 'pc-service-meta';
    const suffix = svc.ok === null ? ` ${t('dash.pc_services.no_auto')}` : '';
    meta.textContent = svc.meta + suffix;
    body.appendChild(name);
    body.appendChild(meta);
    row.appendChild(body);
    list.appendChild(row);
  });
}

async function refreshPcServices(){
  const statuses = [];
  for (const svc of PC_SERVICE_CHECKS) {
    const isSkip = svc.skip;
    const target = svc.url.startsWith('http') ? new URL(svc.url) : new URL(svc.url, window.location.origin);
    const meta = `${target.hostname}:${target.port || defaultPort(target.protocol)}${target.pathname}`;
    let ok = null;
    if (!isSkip) {
      try{
        const controller = new AbortController();
        const timeout = setTimeout(() => controller.abort(), 2500);
        const opts = { cache: 'no-store', signal: controller.signal };
        if (svc.noCors) opts.mode = 'no-cors';
        const resp = await fetch(target.toString(), opts);
        clearTimeout(timeout);
        ok = svc.noCors ? true : resp.ok;
      }catch{
        ok = false;
      }
    }
    statuses.push({ label: svc.label, meta, ok });
  }
  renderPcServices(statuses);
}

function setCamBadgeAndMeta(cam){
  const camBadge=el('camBadge');
  const resourceInfo=cameraResourceSummary();
  if(camBadge){
    if(resourceInfo){
      let cls='cam-badge';
      if(resourceInfo.state==='busy') cls+=' on';
      camBadge.className=cls.trim();
      camBadge.textContent=resourceInfo.text;
      if(resourceInfo.tooltip) camBadge.title=resourceInfo.tooltip;
      else camBadge.removeAttribute('title');
    }else{
      const visionOn = cam?.vision_enabled !== false;
      camBadge.textContent = visionOn ? t('dash.camera.vision_on') : t('dash.camera.vision_off');
      camBadge.className   = 'cam-badge' + (visionOn ? ' on' : '');
      camBadge.removeAttribute('title');
    }
  }
}
function setImageSafely(imgEl,url,tagStore){
  const tag=Date.now(); tagStore.value=tag;
  const loader=new Image(); loader.decoding='async'; loader.loading='eager';
  loader.onload=()=>{ if(tagStore.value!==tag) return; imgEl.src=url; blackify(imgEl,false); };
  loader.onerror=()=>{ if(tagStore.value!==tag) return; blackify(imgEl,true); };
  loader.src=url;
}
function refreshCamLegends(){
  const partsRaw=['RAW']; if(lastCamState.res) partsRaw.push(lastCamState.res);
  if(lastCamState.fps!=null) partsRaw.push(`${fmt(lastCamState.fps,1)} fps`);
  if(lastSnapAges.raw!=null) partsRaw.push(`age: ${fmt(lastSnapAges.raw,1)}s`);
  setTxt('leg_cam_txt',partsRaw.join(' • '));

  const partsProc=['PROC']; if(lastCamState.res) partsProc.push(lastCamState.res);
  if(lastSnapAges.proc!=null) partsProc.push(`age: ${fmt(lastSnapAges.proc,1)}s`);
  setTxt('leg_proc_txt',partsProc.join(' • '));

  const partsObst=['OBST','ROI overlay'];
  if(lastObstacle.present!=null) partsObst.push(`present: ${String(lastObstacle.present)}`);
  if(lastObstacle.confidence!=null) partsObst.push(`conf: ${fmt(lastObstacle.confidence,3)}`);
  setTxt('leg_obst_txt',partsObst.join(' • '));

  const partsTracker=[t('dash.tracker.legend')];
  if(lastTrackingInfo && typeof lastTrackingInfo.offset === 'number'){
    partsTracker.push(`${t('dash.tracker.offset')}: ${fmt(lastTrackingInfo.offset,3)}`);
  }else{
    partsTracker.push(t('dash.tracker.offset_none'));
  }
  if(lastTrackingInfo && lastTrackingInfo.mode){
    partsTracker.push(`${t('dash.tracker.mode')}: ${lastTrackingInfo.mode}`);
  }
  if(lastSnapAges.tracker!=null){
    partsTracker.push(`${t('dash.tracker.age')}: ${fmt(lastSnapAges.tracker,1)}s`);
  }
  setTxt('leg_tracker_txt',partsTracker.join(' • '));
}
function visionOff(){
  return (lastCamState.vision_enabled===false)||(lastCamState.on===false);
}
function feedTooOld(kind){
  const age=lastSnapAges[kind];
  return age!=null && age>SNAP_STALE_S;
}
function shouldBlankFeed(kind){
  if(visionOff()) return true;
  if(!kind) return false;
  return feedTooOld(kind);
}
function refreshFeed(imgEl,url,kind,tagStore){
  if(!imgEl) return;
  if(shouldBlankFeed(kind)){ blackify(imgEl,true); return; }
  setImageSafely(imgEl, url, tagStore);
}
async function refreshCamera(){
  const imgCam=el('img_cam'), imgProc=el('img_proc'), imgObst=el('img_obst'), imgTracker=el('img_tracker');
  const bust=Date.now();
  refreshFeed(imgCam, `/vision/cam?t=${bust}`, 'raw', {get value(){return lastCamReq;}, set value(v){lastCamReq=v;}});
  refreshFeed(imgProc, `/vision/edge?t=${bust}`, 'proc', {get value(){return lastProcReq;}, set value(v){lastProcReq=v;}});
  refreshFeed(imgObst, `/snapshots/obst_annot.jpg?t=${bust}`, null, {get value(){return lastObstReq;}, set value(v){lastObstReq=v;}});
  refreshFeed(imgTracker, `/vision/tracker?t=${bust}`, 'tracker', {get value(){return lastTrackerReq;}, set value(v){lastTrackerReq=v;}});
}

async function refreshCameraResource(){
  try{
    const r = await fetch('/api/resource/camera',{cache:'no-store'});
    const data = await r.json().catch(()=>null);
    if(!r.ok) throw new Error((data && data.error) || `HTTP ${r.status}`);
    lastCameraResource = data;
  }catch(e){
    lastCameraResource = {error: String(e.message || e)};
  }
  setCamBadgeAndMeta(lastState?.camera || {});
  try{ applyDevices({state:lastState, health:lastHealth}); }catch{}
  pushFooterUpdate({ cameraResource: lastCameraResource || null });
}

/* ===== HEALTH ===== */
function updateHealth(h){
  const ok=!!(h && (h.ok===true || h.status==='ok' || h.state==='ok'));
  setTxt('h_status', ok? t('meta.ok'):'degraded'); setCls('h_status', ok?'ok':'bad');

  if(h && h.uptime_s!=null){
    const s=Math.max(0,Math.floor(h.uptime_s));
    const HH=Math.floor(s/3600), MM=String(Math.floor((s%3600)/60)).padStart(2,'0'), SS=String(s%60).padStart(2,'0');
    setTxt('h_uptime',`${HH}:${MM}:${SS}`);
  } else setTxt('h_uptime','—');

  const msg=h?.bus?.last_msg_age_s ?? h?.bus?.last_msg_age;
  if(msg!=null) setTxt('h_msg',`${Number(msg).toFixed(1)} s`);

  let hb=h?.bus?.last_heartbeat_age_s ?? h?.bus?.last_hb_age_s ?? h?.bus?.heartbeat_age_s ?? null;
  if(hb==null){
    const ts=h?.bus?.last_heartbeat_ts ?? h?.bus?.heartbeat_ts ?? null;
    if(ts!=null) hb=Math.max(0,(Date.now()/1000)-Number(ts));
  }
  if(hb!=null) setTxt('h_hb',`${Number(hb).toFixed(1)} s`);
}
async function busHeartbeatFallback(){
  try{
    const r=await fetch('/api/bus/health',{cache:'no-store'}); if(!r.ok) return;
    const j=await r.json().catch(()=>null); if(!j) return;
    const lag=j?.bus?.last_msg_age_s ?? j?.bus?.last_msg_age;
    if(lag!=null) setTxt('h_msg',`${Number(lag).toFixed(1)} s`);
    let hb=j?.bus?.last_heartbeat_age_s ?? j?.bus?.last_hb_age_s ?? j?.bus?.heartbeat_age_s;
    if(hb==null){ const ts=j?.bus?.last_heartbeat_ts ?? j?.bus?.heartbeat_ts; if(ts!=null) hb=Math.max(0,(Date.now()/1000)-Number(ts)); }
    if(hb!=null) setTxt('h_hb',`${Number(hb).toFixed(1)} s`);
  }catch{}
}

/* ===== STATE ===== */
let lastHealth=null, lastState=null;
const pcHistCpu = [];
const pcHistMem = [];
const PC_HISTORY_LIMIT = 60;

function updateStateUI(s){
  setTxt('p_present',String(!!s.present)); setCls('p_present',s.present?'ok':'bad');
  setTxt('p_conf',fmt(s.confidence,3)); setTxt('p_mode',s.mode||'—');
  setTxt('p_ts',s.ts? new Date(s.ts*1000).toLocaleTimeString():'—');
  setTxt('p_age',(s.age_s!=null? fmt(s.age_s,1)+' s':'—'));

  lastCamState.vision_enabled = s?.camera?.vision_enabled;
  lastCamState.on = s?.camera?.on;
  const resArr=s?.camera?.res;
  lastCamState.res=(Array.isArray(resArr)&&resArr.length===2)?`${resArr[0]}×${resArr[1]}`:null;
  lastCamState.fps=(s?.camera?.fps!=null)? Number(s.camera.fps):null;

  lastTrackingInfo = s?.tracking || {};
  setCamBadgeAndMeta(s?.camera||{});
  refreshCamLegends();
  pushFooterUpdate({ state: s || null });
}

/* ===== DEVICES ===== */
function textFromLCD(lcd){
  if(!lcd) return '—';
  const parts=[]; parts.push(lcd.on?'ON':'OFF');
  if(lcd.rot!=null) parts.push('rot '+lcd.rot);
  if(lcd.presenting) parts.push('presenting');
  if(lcd.no_draw) parts.push('no_draw');
  return parts.join(' · ');
}
function applyDevices({state,health}){
  const stateDevices = state?.devices ?? {};
  const healthDevices = health?.devices ?? {};
  const cam = state?.camera ?? stateDevices?.camera ?? healthDevices?.camera ?? {};
  const resArr = Array.isArray(cam.res) && cam.res.length===2 ? cam.res : null;
  const resTxt = resArr ? `${resArr[0]}×${resArr[1]}` : (lastCamState.res || '');
  const fpsVal = cam.fps!=null ? cam.fps : lastCamState.fps;
  const resourceInfo = cameraResourceSummary();
  const holdersTxt = resourceInfo?.holders || formatResourceHolders(lastCameraResource?.holders);
  const camParts=[];
  const camStatus = typeof cam.on === 'boolean' ? cam.on : (resourceInfo ? resourceInfo.state==='busy' : null);
  if(camStatus !== null){
    camParts.push(camStatus ? 'ON' : 'OFF');
  }
  if(cam.mode) camParts.push(cam.mode);
  if(resTxt) camParts.push(resTxt);
  if(fpsVal!=null) camParts.push(`${fmt(fpsVal,1)} fps`);
  if(resourceInfo){
    if(resourceInfo.state==='busy') camParts.push(t('dash.camera.resource_busy_badge'));
    else if(resourceInfo.state==='free') camParts.push(t('dash.camera.resource_free_badge'));
    else if(resourceInfo.state==='error') camParts.push(t('dash.camera.resource_error_badge'));
  }
  if(holdersTxt) camParts.push(holdersTxt);
  setTxt('d_cam', camParts.filter(Boolean).join(' · ') || '—');
  let camClass='muted';
  if(camStatus === true) camClass='ok';
  else if(camStatus === false) camClass='muted';
  else if(resourceInfo){
    if(resourceInfo.state==='busy') camClass='ok';
    else if(resourceInfo.state==='error') camClass='bad';
    else camClass='muted';
  }
  setCls('d_cam', camClass);

  const lcd = stateDevices?.lcd ?? healthDevices?.lcd ?? state?.lcd ?? null;
  const lcdTxt=textFromLCD(lcd);
  setTxt('d_lcd',lcdTxt); setCls('d_lcd',(lcd && lcd.on)?'ok':'muted');

  const xgo = stateDevices?.xgo ?? state?.xgo ?? healthDevices?.xgo ?? {};
  const imuTxt=(xgo.on?'ON':'OFF') + (xgo.imu_ok===true?' · OK':(xgo.on?' · ?':''));
  setTxt('d_xgo_imu',imuTxt); setCls('d_xgo_imu',(xgo.on && xgo.imu_ok)?'ok':'muted');

  const poseParts=[];
  const axes = {x:null,y:null,z:null};
  const axisSrc = {x:null,y:null,z:null};
  const setAxis=(axis,value,src)=>{
    if(value==null || axes[axis]!=null) return;
    axes[axis]=value;
    axisSrc[axis]=src;
  };
  if(Array.isArray(xgo.pose)){
    setAxis('x', xgo.pose[0], 'pose');
    setAxis('y', xgo.pose[1], 'pose');
    setAxis('z', xgo.pose[2], 'pose');
  }else if(xgo.pose && typeof xgo.pose==='object'){
    setAxis('x', xgo.pose.x ?? xgo.pose.X ?? null, 'pose');
    setAxis('y', xgo.pose.y ?? xgo.pose.Y ?? null, 'pose');
    setAxis('z', xgo.pose.z ?? xgo.pose.Z ?? null, 'pose');
  }
  setAxis('x', xgo.roll, 'roll');
  setAxis('y', xgo.pitch, 'pitch');
  setAxis('z', (xgo.yaw ?? xgo.yaw_raw), 'yaw');
  const fmtAngle=v=>{
    const num=Number(v);
    const base=Number.isFinite(num)? fmt(num,1):fmt(v,1);
    return `${base}°`;
  };
  const poseText = (() => {
    if(typeof xgo.pose==='string' && xgo.pose.trim()) return xgo.pose.trim();
    if(typeof xgo.pose_label==='string' && xgo.pose_label.trim()) return xgo.pose_label.trim();
    return null;
  })();
  if(poseText){
    poseParts.push(poseText);
  }else{
    ['x','y','z'].forEach(axis=>{
      const val=axes[axis];
      if(val!=null) poseParts.push(`${axis} ${fmtAngle(val)}`);
    });
  }
  if(xgo.roll!=null && axisSrc.x!=='roll')  poseParts.push(`r ${fmtAngle(xgo.roll)}`);
  if(xgo.pitch!=null && axisSrc.y!=='pitch') poseParts.push(`p ${fmtAngle(xgo.pitch)}`);
  if(xgo.yaw!=null && axisSrc.z!=='yaw')   poseParts.push(`y ${fmtAngle(xgo.yaw)}`);
  setTxt('d_xgo_pose',poseParts.length? poseParts.join(' · ') : '—');

  const battPct=(xgo.battery_pct ?? xgo.batt_pct ?? xgo.battery?.pct ?? xgo.battery);
  setTxt('d_xgo_batt',(battPct!=null? `${Number(battPct).toFixed(0)}%`:'—'));
  setCls('d_xgo_batt',(battPct!=null?'ok':'muted'));

  const fw = xgo.fw ?? state?.fw ?? health?.devices?.xgo?.fw;
  if (fw) setTxt('ci_fw', fw);
}

/* ===== OBSTACLE + HISTOGRAM ===== */
function drawBinsCanvas({bins=null,edge_pct=null,low=null,high=null}={}){
  const c=el('binsCanvas'); if(!c) return; const ctx=c.getContext('2d');
  ctx.clearRect(0,0,c.width,c.height);
  const padL=30,padT=10,padR=10,padB=16; const W=c.width-padL-padR,H=c.height-padT-padB;
  ctx.strokeStyle='#1d3548'; ctx.strokeRect(padL,padT,W,H);
  ctx.fillStyle='#8aa'; ctx.font='10px sans-serif'; ctx.textAlign='right';
  [0,0.5,1].forEach(v=>{const y=padT+H-(v*H); ctx.beginPath(); ctx.moveTo(padL-4,y); ctx.lineTo(padL,y); ctx.strokeStyle='#1d3548'; ctx.stroke(); ctx.fillText(String(Math.round(v*100)),padL-6,y+3);});
  if(low!=null){ const y=padT+H-(Math.max(0,Math.min(1,low))*H); ctx.strokeStyle='#2b8a3e'; ctx.setLineDash([4,3]); ctx.beginPath(); ctx.moveTo(padL,y); ctx.lineTo(padL+W,y); ctx.stroke(); ctx.setLineDash([]);}
  if(high!=null){ const y=padT+H-(Math.max(0,Math.min(1,high))*H); ctx.strokeStyle='#d89d2b'; ctx.setLineDash([4,3]); ctx.beginPath(); ctx.moveTo(padL,y); ctx.lineTo(padL+W,y); ctx.stroke(); ctx.setLineDash([]);}
  if(Array.isArray(bins) && bins.length){
    const n=bins.length; const gap=2; const barW=(W-(gap*(n-1)))/n;
    ctx.fillStyle='#6db3ff';
    bins.forEach((v,i)=>{ const h=H*Math.max(0,Math.min(1,Number(v)||0)); const x=padL+i*(barW+gap); const y=padT+H-h; ctx.fillRect(x,y,Math.max(1,barW),h);});
  }else if(edge_pct!=null){
    const h=H*Math.max(0,Math.min(1,Number(edge_pct)||0)); ctx.fillStyle='#6db3ff';
    ctx.fillRect(padL+W*0.25,padT+H-h,W*0.5,h);
  }
}
function applyObstacle(o){
  const present=!!o.present;
  const conf=(o.confidence!=null)? Number(o.confidence).toFixed(3):null;
  const pct=(o.edge_pct!=null)? Number(o.edge_pct).toFixed(3):'—';
  const cls=present?'ok':'bad';
  const set=(id,txt,c)=>{const e=document.getElementById(id); if(!e) return; e.textContent=txt; if(c) e.className=c;};
  set('obs_present',String(present),cls);
  set('obs_conf',conf!=null?conf:'—');
  set('obs_edge',pct);

  lastObstacle.present=present;
  lastObstacle.confidence=(conf!=null? Number(conf):null);
  refreshCamLegends();

  const low=o?.diag?.t_low ?? null;
  const high=o?.diag?.t_high ?? null;
  const bins=o?.diag?.bins ?? null;
  const edge_raw=o?.diag?.edge_pct_raw ?? o?.edge_pct ?? null;

  drawBinsCanvas({bins,edge_pct:edge_raw,low,high});
  const txt=document.getElementById('binsLegendTxt');
  if(txt){
    const lowTxt=low!=null? Number(low).toFixed(2):'—';
    const highTxt=high!=null? Number(high).toFixed(2):'—';
    const epTxt=edge_raw!=null? Number(edge_raw).toFixed(3):'—';
    txt.textContent=`LOW/HIGH: ${lowTxt} / ${highTxt} • edge_pct: ${epTxt}`;
  }
}
async function fetchObstacle(){
  try{ const r=await fetch('/vision/obstacle',{cache:'no-store'}); if(!r.ok) return;
       const j=await r.json().catch(()=>null); if(j) applyObstacle(j);}catch{}
}

/* ===== SNAP INFO ===== */
function applySnapInfo(si){
  const rawAge=si?.raw?.age_s; const procAge=si?.proc?.age_s; const trackerAge=si?.tracker?.age_s;
  lastSnapAges.raw=rawAge ?? null; lastSnapAges.proc=procAge ?? null; lastSnapAges.tracker=trackerAge ?? null;
  setTxt('age_raw',rawAge!=null? fmt(rawAge,1)+' s':'—');
  setTxt('age_proc',procAge!=null? fmt(procAge,1)+' s':'—');
  setTxt('age_tracker',trackerAge!=null? fmt(trackerAge,1)+' s':'—');
  const imgCam=el('img_cam'); const imgProc=el('img_proc');
  if(rawAge!=null && rawAge>SNAP_STALE_S) blackify(imgCam,true); else blackify(imgCam,false);
  if(procAge!=null && procAge>SNAP_STALE_S) blackify(imgProc,true); else blackify(imgProc,false);
  refreshCamLegends();
  pushFooterUpdate({ snapInfo: si || null });
}
async function refreshSnapInfo(){
  try{ const r=await fetch('/vision/snap-info',{cache:'no-store'}); if(!r.ok) return;
       const j=await r.json().catch(()=>null); if(j) applySnapInfo(j);}catch{}
}

/* ===== SYSINFO ===== */
function applySysinfo(si){
  if(!si) return;
  const fallbackHost =
    (typeof window !== 'undefined' && window.location && window.location.hostname)
      ? window.location.hostname
      : null;
  const hostValue = si.host || si.hostname || fallbackHost;
  setTxt('ci_host', hostValue || '—');
  setTxt('ci_cpu', si.cpu_pct!=null? fmt(si.cpu_pct,1)+'%':'—');
  setTxt('ci_load', `${fmt(si.load1,2)}/${fmt(si.load5,2)}/${fmt(si.load15,2)}`);
  const mb=v=> (v==null ? '—' : Number(v).toFixed(1)+' MB');
  if(si.mem_total_mb!=null && si.mem_used_mb!=null){
    const pct=si.mem_pct!=null? ` (${fmt(si.mem_pct,1)}%)`:'';
    setTxt('ci_mem', `${mb(si.mem_used_mb)} / ${mb(si.mem_total_mb)}${pct}`);
  } else setTxt('ci_mem','—');
  const gb=v=> (v==null ? '—' : Number(v).toFixed(1)+' GB');
  if(si.disk_total_gb!=null && si.disk_used_gb!=null){
    const pct=si.disk_pct!=null? ` (${fmt(si.disk_pct,1)}%)`:'';
    setTxt('ci_disk', `${gb(si.disk_used_gb)} / ${gb(si.disk_total_gb)}${pct}`);
  } else setTxt('ci_disk','—');
  setTxt('ci_os', si.os_release || si.platform || '—');
  setTxt('d_temp', (si.temp_c!=null ? fmt(si.temp_c,1)+' °C' : '—'));
  const fw = si.fw || si.fw_version || si.firmware || si.version;
  if (fw) setTxt('ci_fw', fw);
  drawChart(si.hist_cpu || [], si.hist_mem || []);
}

/* ===== API Metrics ===== */
async function refreshApiMetrics(){
  try{
    const r = await fetch('/api/app-metrics', {cache:'no-store'});
    if(!r.ok) return;
    const j = await r.json().catch(()=>null);
    if(!j || !j.metrics) return;
    
    const m = j.metrics;
    
    // Format: "OK / Error"
    setTxt('metric_control', `${m.control?.ok ?? 0} / ${m.control?.error ?? 0}`);
    setTxt('metric_navigator', `${m.navigator?.ok ?? 0} / ${m.navigator?.error ?? 0}`);
    setTxt('metric_voice', `${m.voice?.ok ?? 0} / ${m.voice?.error ?? 0}`);
    setTxt('metric_google_home', `${m.google_home?.ok ?? 0} / ${m.google_home?.error ?? 0}`);
    setTxt('metric_chat', `${m.chat?.ok ?? 0} / ${m.chat?.error ?? 0}`);
    setTxt('metric_face', `${m.face?.ok ?? 0} / ${m.face?.error ?? 0}`);
    
    // Total Errors - highlighted
    const totalErr = j.total_errors ?? 0;
    setTxt('metric_total_errors', totalErr);
    setCls('metric_total_errors', totalErr > 0 ? 'bad' : 'ok');
  }catch{}
}

/* ===== Poll ===== */
async function tick(){
  try{ lastHealth = await (await fetch('/healthz',{cache:'no-store'})).json(); updateHealth(lastHealth);}catch{}
  try{ await busHeartbeatFallback(); }catch{}
  try{ lastState  = await (await fetch('/state',{cache:'no-store'})).json(); updateStateUI(lastState);}catch{}
  try{ applyDevices({state:lastState, health:lastHealth}); }catch{}
  try{ await refreshCameraResource(); }catch{}

  try{ const si = await (await fetch('/sysinfo',{cache:'no-store'})).json(); applySysinfo(si);}catch{}

  try{ await refreshSnapInfo(); }catch{}
  try{ await refreshCamera(); }catch{}
}

/* ===== MCP Tools ===== */
async function refreshMcpStats(){
  try{
    const r = await fetch('/api/mcp/stats', {cache:'no-store'});
    if(!r.ok) return;
    const j = await r.json().catch(()=>null);
    if(j && j.stats){
      setTxt('mcpTotalTools', j.stats.total_tools || 0);
      setTxt('mcpInvocations', j.stats.invocation_count || 0);
      setTxt('mcpLastTool', j.stats.last_invoked_tool || '—');
      setCls('mcpStatus', 'ok');
      setTxt('mcpStatus', 'aktywny');
    }
  }catch{
    setCls('mcpStatus', 'bad');
    setTxt('mcpStatus', 'błąd');
  }
}

async function refreshMcpResources(){
  try{
    const r = await fetch('/api/mcp/resources', {cache:'no-store'});
    if(!r.ok) return;
    const j = await r.json().catch(()=>null);
    if(j && j.resources && j.resources.config){
      const cfg = j.resources.config;
      setTxt('mcpStandalone', cfg.mcp_standalone ? 'tak' : 'nie');
      setTxt('mcpPort', cfg.mcp_port || 8210);
    }
  }catch{}
}

async function refreshMcpToolsList(){
  try{
    const r = await fetch('/api/mcp/tools', {cache:'no-store'});
    if(!r.ok) return;
    const j = await r.json().catch(()=>null);
    if(j && j.tools){
      const list = el('mcpToolsList');
      if(!list) return;
      if(!j.tools.length){
        list.innerHTML = '<div class="muted">Brak narzędzi</div>';
        return;
      }
      list.innerHTML = '';
      j.tools.slice(0, 8).forEach(tool => {
        const row = document.createElement('div');
        row.className = 'mcp-tool-item';
        row.innerHTML = `<span class="mcp-tool-name">${tool.name}</span>`;
        row.title = tool.description || '';
        list.appendChild(row);
      });
      if(j.tools.length > 8){
        const more = document.createElement('div');
        more.className = 'muted';
        more.textContent = `... i ${j.tools.length - 8} więcej`;
        list.appendChild(more);
      }
    }
  }catch{}
}

async function refreshMcp(){
  await refreshMcpStats();
  await refreshMcpResources();
  await refreshMcpToolsList();
}

/* lekkie SSE */
function startSSE(){ try{ const es=new EventSource('/events'); es.onmessage=()=>{}; es.onerror=()=>{}; }catch{} }

setInterval(tick, REFRESH_MS); tick();
setInterval(fetchObstacle, REFRESH_MS); fetchObstacle();
setInterval(refreshApiMetrics, REFRESH_MS); refreshApiMetrics();
setInterval(refreshPcSystemMetrics, PC_SYSTEM_REFRESH_MS); refreshPcSystemMetrics();
setInterval(refreshPcServices, PC_SERVICE_REFRESH_MS); refreshPcServices();
setInterval(refreshMcp, PC_SERVICE_REFRESH_MS); refreshMcp();
startSSE();
</script>
<script type="module" src="/web/assets/menu.js"></script>
<script type="module" src="/web/assets/footer.js"></script>
</body>
</html>
