<!doctype html>
<!--
  Migrated to dashboard_base.html template structure
  Uses shared layout classes: .layout-header, .layout-main, .layout-footer
-->
<html lang="pl">
<head>
<meta charset="utf-8">
<title>Rider-PC: Chat</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="/web/assets/dashboard-common.css">
<link rel="stylesheet" href="/web/assets/pages/chat.css">
</head>
<body data-page="chat" class="page page-chat">
  <!-- Header with Menu -->
  <header class="layout-header" data-dashboard-menu-target></header>

  <!-- Main content -->
  <main class="layout-main">
    <header class="l-row chat-head">
      <h1 class="page-title"><span class="brand-accent">Rider-PC</span>: <span class="page-title-text">Chat</span></h1>
      <div class="links">
        <a href="/view">dashboard</a>
        <span class="u-sep">·</span>
        <a href="/home">Google&nbsp;Home</a>
      </div>
    </header>

    <div class="status c-status-msg" id="status">Gotowy</div>

    <div class="board c-card" id="board" aria-live="polite"></div>

    <div class="l-row compose-row">
      <textarea id="input" placeholder="Napisz wiadomość… (Enter = wyślij, Shift+Enter = nowa linia)"></textarea>
      <div class="side">
        <button class="c-btn" id="sendBtn">Wyślij</button>
        <div class="controls">
          <input type="checkbox" id="tts" />
          <label for="tts">Czytaj odpowiedzi (TTS)</label>
        </div>
        <div class="controls">
          <label for="ttsProvider">Provider TTS</label>
          <select id="ttsProvider"></select>
        </div>
        <div class="c-hint">Chat API: <code>/api/chat/send</code> · TTS: <code>/api/voice/tts</code></div>
      </div>
    </div>
    <div id="providerHint" class="provider-hint c-status-msg" hidden>Ładuję listę providerów…</div>

    <section class="providers-card c-card l-stack" aria-labelledby="providerTitle">
      <div class="providers-head l-row">
        <h2 id="providerTitle">Providerzy TTS</h2>
        <div class="u-spacer"></div>
        <div class="providers-actions">
          <button class="c-btn c-btn-sm" id="btnReloadProviders">Odśwież listę</button>
          <button class="c-btn c-btn-sm" id="btnTestAll">Testuj wszystkie</button>
        </div>
      </div>
      <div id="providerList" class="provider-list" aria-live="polite">
        <div class="provider-empty c-status-msg">Ładowanie…</div>
      </div>
      <div class="c-hint">Kliknij „Test”, by wykonać próbę TTS i sprawdzić działanie usług.</div>
    </section>

    <div class="meta" id="latency"></div>
  </main>

  <!-- Footer -->
  <footer class="layout-footer" data-dashboard-footer-target></footer>

<script>
(function(){
  const board    = document.getElementById('board');
  const input    = document.getElementById('input');
  const sendBtn  = document.getElementById('sendBtn');
  const status   = document.getElementById('status');
  const latency  = document.getElementById('latency');
  const ttsChk   = document.getElementById('tts');
  const providerSelect = document.getElementById('ttsProvider');
  const providerHint   = document.getElementById('providerHint');
  const providerListEl = document.getElementById('providerList');
  const btnTestAll     = document.getElementById('btnTestAll');
  const btnReloadProviders = document.getElementById('btnReloadProviders');

  const FALLBACK_PROVIDERS = [
    { id: 'local',  label: 'Piper (lokalny)',         backend: 'piper',  voice: 'pl_PL-gosia-medium.onnx', description: 'Offline TTS Rider-PC.', service: 'voice-web' },
    { id: 'openai', label: 'OpenAI gpt-4o-mini-tts', backend: 'openai', voice: 'alloy', model: 'gpt-4o-mini-tts', description: 'Chmurowy TTS OpenAI.', service: null },
    { id: 'google', label: 'Google Gemini Kore',     backend: 'google', voice: 'Kore',  model: 'gemini-2.5-flash-preview-tts', description: 'Chmurowy TTS Gemini.', service: null },
  ];
  let providerCatalog = [];

  // prosty storage historii w sesji
  const history = JSON.parse(sessionStorage.getItem('chat_history') || '[]');
  for (const item of history) appendMessage(item.role, item.text, item.error);

  function save(role, text, error){
    history.push({role, text, error: !!error});
    if (history.length > 200) history.shift();
    sessionStorage.setItem('chat_history', JSON.stringify(history));
  }

  const statusVariants = {
    ok: 'is-ok',
    warn: 'is-warn',
    err: 'is-err'
  };

  function setStatus(text, state){
    status.textContent = text;
    const variant = statusVariants[state] || '';
    status.className = `status c-status-msg ${variant}`.trim();
  }

  function appendMessage(role, text, isError){
    const el = document.createElement('div');
    el.className = 'msg ' + (isError ? 'err' : (role === 'you' ? 'you' : 'bot'));
    el.textContent = text;
    board.appendChild(el);
    board.scrollTop = board.scrollHeight;
  }

  function normalizeReply(data){
    // obsłuż kilka potencjalnych kształtów odpowiedzi z glue/fallbacku
    return (
      data?.reply ??
      data?.echo ??
      data?.text ??
      data?.message ??
      data?.content ??
      data?.item?.msg ??
      (data?.choices && data.choices[0]?.message?.content) ??
      JSON.stringify(data)
    );
  }

  async function callChat(promptText){
    const t0 = performance.now();
    const res = await fetch('/api/chat/send', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({ msg: promptText, user: 'web' })
    });
    const t1 = performance.now();
    latency.textContent = `Czas odpowiedzi: ${(t1 - t0).toFixed(0)} ms`;
    if (!res.ok){
      const errText = await res.text().catch(()=>`${res.status} ${res.statusText}`);
      throw new Error(`Chat HTTP ${res.status}: ${errText}`);
    }
    return res.json();
  }

  function getProviderById(id){
    return providerCatalog.find((p)=>p.id === id);
  }

  function providerStateClass(state){
    if (state === 'ok') return 'c-pill is-ok';
    if (state === 'error') return 'c-pill is-err';
    return 'c-pill is-warn';
  }

  function serviceStateSummary(provider){
    const state = provider?.service_state;
    if (!state) return 'brak danych';
    if (state.error) return `błąd (${state.error})`;
    const parts = [];
    if (state.active) parts.push(state.active);
    if (state.sub && (!parts.length || state.sub !== parts[parts.length - 1])) {
      parts.push(state.sub);
    }
    if (!parts.length && state.enabled) parts.push(state.enabled);
    return parts.join(' / ') || 'n/a';
  }

  function isServiceActive(provider){
    const state = provider?.service_state;
    if (!state) return false;
    const active = (state.active || '').toLowerCase();
    const sub = (state.sub || '').toLowerCase();
    return active === 'active' || sub === 'running';
  }

  function setProviderHint(provider){
    if (!provider){
      providerHint.textContent = 'Brak providerów TTS – używam trybu domyślnego.';
      providerHint.hidden = false;
      return;
    }
    const state = provider.status?.state || 'unknown';
    const detail = provider.status?.detail ? ` — ${provider.status.detail}` : '';
    const latencyText = typeof provider.status?.latency_ms === 'number' ? ` (${provider.status.latency_ms} ms)` : '';
    let label = 'Brak danych';
    if (state === 'ok') label = 'OK';
    else if (state === 'error') label = 'Błąd';
    const parts = [`${provider.label}: ${label}${detail}${latencyText}`];
    if (provider.service){
      parts.push(`Usługa ${provider.service}: ${serviceStateSummary(provider)}`);
    }
    providerHint.textContent = parts.join(' • ');
    providerHint.hidden = false;
  }

  function renderProviderSelect(){
    providerSelect.innerHTML = '';
    if (!providerCatalog.length){
      providerSelect.disabled = true;
      setProviderHint(null);
      return;
    }
    providerSelect.disabled = false;
    for (const provider of providerCatalog){
      const opt = document.createElement('option');
      opt.value = provider.id;
      opt.textContent = provider.label;
      providerSelect.appendChild(opt);
    }
    const stored = localStorage.getItem('chat_tts_provider');
    let current = stored && getProviderById(stored);
    if (!current){
      current = providerCatalog.find((p)=>p.status?.state === 'ok') || providerCatalog[0];
    }
    providerSelect.value = current?.id || providerCatalog[0].id;
    localStorage.setItem('chat_tts_provider', providerSelect.value);
    setProviderHint(getSelectedProvider());
  }

  function renderProviderList(){
    providerListEl.innerHTML = '';
    if (!providerCatalog.length){
    const empty = document.createElement('div');
    empty.className = 'provider-empty c-status-msg';
      empty.textContent = 'Brak danych o providerach.';
      providerListEl.appendChild(empty);
      return;
    }
    for (const provider of providerCatalog){
      const row = document.createElement('div');
      row.className = 'provider-row c-card';

      const info = document.createElement('div');
      info.className = 'provider-info';
      const name = document.createElement('div');
      name.className = 'provider-name';
      name.textContent = provider.label;
      const desc = document.createElement('div');
      desc.className = 'provider-desc';
      desc.textContent = provider.description || '';
      info.appendChild(name);
      info.appendChild(desc);

      const meta = document.createElement('div');
      meta.className = 'provider-meta';
      const pill = document.createElement('span');
      const state = provider.status?.state || 'unknown';
      pill.className = providerStateClass(state);
      pill.textContent = state === 'ok' ? 'OK' : state === 'error' ? 'Błąd' : '—';
      meta.appendChild(pill);
      if (provider.status?.detail){
        const detail = document.createElement('div');
        detail.className = 'provider-detail';
        detail.textContent = provider.status.detail;
        meta.appendChild(detail);
      }
      if (typeof provider.status?.latency_ms === 'number'){
        const latencyInfo = document.createElement('div');
        latencyInfo.className = 'provider-latency';
        latencyInfo.textContent = `${provider.status.latency_ms} ms`;
        meta.appendChild(latencyInfo);
      }
      if (provider.service){
        const svcInfo = document.createElement('div');
        svcInfo.className = 'provider-service';
        svcInfo.innerHTML = `<strong>Usługa:</strong> ${provider.service} (${serviceStateSummary(provider)})`;
        meta.appendChild(svcInfo);
      }

      const actions = document.createElement('div');
      actions.className = 'provider-actions';
      const btn = document.createElement('button');
      btn.className = 'c-btn c-btn-sm';
      btn.textContent = 'Test';
      btn.addEventListener('click', ()=>{
        btn.disabled = true;
        btn.textContent = '…';
        runProviderChecks([provider.id])
          .catch((err)=>{ providerHint.textContent = `Test ${provider.label} nieudany: ${err.message || err}`; })
          .finally(()=>{
            btn.disabled = false;
            btn.textContent = 'Test';
          });
      });
      actions.appendChild(btn);
      if (provider.service){
        const startBtn = document.createElement('button');
        startBtn.className = 'c-btn c-btn-sm';
        startBtn.textContent = 'Start';
        if (isServiceActive(provider)) startBtn.disabled = true;
        startBtn.addEventListener('click', ()=>{
          handleServiceAction(provider, 'start', startBtn);
        });
        const stopBtn = document.createElement('button');
        stopBtn.className = 'c-btn c-btn-sm';
        stopBtn.textContent = 'Stop';
        if (!isServiceActive(provider)) stopBtn.disabled = true;
        stopBtn.addEventListener('click', ()=>{
          handleServiceAction(provider, 'stop', stopBtn);
        });
        actions.appendChild(startBtn);
        actions.appendChild(stopBtn);
      }

      row.appendChild(info);
      row.appendChild(meta);
      row.appendChild(actions);
      providerListEl.appendChild(row);
    }
  }

  function updateProviderStatus(providerId, result){
    if (!providerId) return;
    const provider = getProviderById(providerId);
    if (!provider) return;
    provider.status = provider.status || {};
    if (result?.state) provider.status.state = result.state;
    provider.status.state = provider.status.state || 'unknown';
    if (result?.detail || result?.error){
      provider.status.detail = result.detail || result.error;
    }
    if (typeof result?.latency_ms === 'number'){
      provider.status.latency_ms = Math.round(result.latency_ms);
    }
    provider.status.updated = Date.now();
    renderProviderList();
    if (getSelectedProvider()?.id === providerId){
      setProviderHint(provider);
    }
  }

  async function loadProviders(){
    providerHint.textContent = 'Ładuję listę providerów…';
    try{
      const res = await fetch('/api/voice/providers', { cache: 'no-store' });
      if (!res.ok){
        const errText = await res.text().catch(()=>`${res.status} ${res.statusText}`);
        throw new Error(errText);
      }
      const data = await res.json();
      providerCatalog = (data?.providers || []).map((item)=>({
        ...item,
        service_state: item.service_state || null,
      }));
      if (!providerCatalog.length){
        providerCatalog = FALLBACK_PROVIDERS.map((p)=>({
          ...p,
          status: p.status || { state: 'warn', detail: 'domyślny fallback' },
          service_state: p.service ? { unit: p.service, alias: p.service, active: 'inactive', sub: 'dead' } : null,
        }));
      }
      providerHint.textContent = 'Wybierz provider do czytania odpowiedzi.';
    }catch(err){
      console.warn('voice providers list failed', err);
      providerCatalog = FALLBACK_PROVIDERS.map((p)=>({
        ...p,
        status: { state: 'warn', detail: 'tryb offline' },
        service_state: p.service ? { unit: p.service, alias: p.service, active: 'inactive', sub: 'dead' } : null,
      }));
      providerHint.textContent = 'Nie udało się pobrać listy providerów (tryb offline).';
    }
    renderProviderSelect();
    renderProviderList();
  }

  function getSelectedProvider(){
    const currentId = providerSelect.value;
    if (!currentId) return undefined;
    return getProviderById(currentId);
  }

  function buildTtsPayload(text){
    const provider = getSelectedProvider();
    if (!provider){
      return { text, backend: 'piper', voice: 'pl_PL-gosia-medium.onnx' };
    }
    const payload = {
      text,
      backend: provider.backend || provider.id,
      provider: provider.id,
    };
    if (provider.voice) payload.voice = provider.voice;
    if (provider.model) payload.model = provider.model;
    return payload;
  }

  async function runProviderChecks(ids){
    if (!ids || !ids.length) return;
    const res = await fetch('/api/voice/providers/test', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({ providers: ids }),
    });
    if (!res.ok){
      const errText = await res.text().catch(()=>`${res.status} ${res.statusText}`);
      throw new Error(`Providers HTTP ${res.status}: ${errText}`);
    }
    const data = await res.json();
    for (const item of data.results || []){
      updateProviderStatus(item.id, item);
    }
    return data;
  }

  async function serviceAction(alias, action){
    if (!alias) throw new Error('Nieznany alias usługi');
    const res = await fetch(`/svc/${encodeURIComponent(alias)}`, {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({ action }),
    });
    if (!res.ok){
      const txt = await res.text().catch(()=>`${res.status} ${res.statusText}`);
      throw new Error(`svc ${alias} ${action}: ${txt}`);
    }
    return res.json();
  }

  async function handleServiceAction(provider, action, button){
    if (!provider?.service) return;
    const original = button.textContent;
    button.disabled = true;
    button.textContent = action === 'start' ? 'Startuję…' : 'Zatrzymuję…';
    try{
      const data = await serviceAction(provider.service, action);
      if (data?.status){
        provider.service_state = data.status;
      }
      setProviderHint(getSelectedProvider());
    }catch(err){
      providerHint.textContent = `Usługa ${provider.service}: ${err.message || err}`;
    }finally{
      button.disabled = false;
      button.textContent = original;
      renderProviderList();
    }
  }

  async function speak(text){
    const payload = buildTtsPayload(text);
    const t0 = performance.now();
    const res = await fetch('/api/voice/tts', {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify(payload),
    });
    if (!res.ok){
      const txt = await res.text().catch(()=>`${res.status} ${res.statusText}`);
      throw new Error(`TTS HTTP ${res.status}: ${txt}`);
    }
    const blob = await res.blob();
    const url = URL.createObjectURL(blob);
    const audio = new Audio(url);
    await audio.play().catch(()=>{});
    setTimeout(()=>URL.revokeObjectURL(url), 15000);
    if (payload.provider){
      updateProviderStatus(payload.provider, { id: payload.provider, state: 'ok', detail: 'Odtworzenie udane', latency_ms: Math.round(performance.now() - t0) });
    }
  }

  async function send(){
    const text = (input.value || '').trim();
    if (!text) return;
    input.value = '';
    setStatus('Wysyłam…','warn');
    sendBtn.disabled = true;

    appendMessage('you', text);
    save('you', text);

    try{
      const data = await callChat(text);
      const reply = normalizeReply(data) || '(pusta odpowiedź)';
      appendMessage('bot', reply);
      save('bot', reply);
      setStatus('OK','ok');

      if (ttsChk.checked){
        try {
          await speak(reply);
        } catch (e){
          const msg = e && e.message ? e.message : String(e);
          appendMessage('bot', '⚠︎ TTS: ' + msg, true);
          save('bot', 'TTS ERROR', true);
          const provider = getSelectedProvider();
          if (provider){
            updateProviderStatus(provider.id, { id: provider.id, state: 'error', detail: msg });
          }
        }
      }
    }catch(e){
      const msg = (e && e.message) ? e.message : String(e);
      appendMessage('bot', 'Błąd: ' + msg, true);
      save('bot', 'Błąd: ' + msg, true);
      setStatus('Błąd','err');
    }finally{
      sendBtn.disabled = false;
      input.focus();
    }
  }

  sendBtn.addEventListener('click', send);
  input.addEventListener('keydown', (ev)=>{
    if (ev.key === 'Enter' && !ev.shiftKey){
      ev.preventDefault();
      send();
    }
  });

  providerSelect.addEventListener('change', ()=>{
    const provider = getSelectedProvider();
    if (provider){
      localStorage.setItem('chat_tts_provider', provider.id);
    }
    setProviderHint(provider || null);
  });

  btnReloadProviders.addEventListener('click', (ev)=>{
    ev.preventDefault();
    btnReloadProviders.disabled = true;
    btnReloadProviders.textContent = 'Ładuję…';
    loadProviders().finally(()=>{
      btnReloadProviders.disabled = false;
      btnReloadProviders.textContent = 'Odśwież listę';
    });
  });

  btnTestAll.addEventListener('click', (ev)=>{
    ev.preventDefault();
    if (!providerCatalog.length) return;
    btnTestAll.disabled = true;
    btnTestAll.textContent = 'Testuję…';
    runProviderChecks(providerCatalog.map((p)=>p.id))
      .catch((err)=>{ providerHint.textContent = `Test zbiorczy nieudany: ${err.message || err}`; })
      .finally(()=>{
        btnTestAll.disabled = false;
        btnTestAll.textContent = 'Testuj wszystkie';
      });
  });

  setStatus('Gotowy','ok');
  input.focus();
  loadProviders();
})();
</script>
<script type="module" src="/web/assets/menu.js"></script>
<script type="module" src="/web/assets/footer.js"></script>
</body>
</html>
