<!doctype html>
<!--
  Migrated to dashboard_base.html template structure
  Uses shared layout classes: .layout-header, .layout-main, .layout-footer
-->
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Rider-PC: Sterowanie ruchem (REST /api)</title>
  <link rel="stylesheet" href="/web/assets/dashboard-common.css" />
  <link rel="stylesheet" href="/web/assets/control.css" />
</head>
<body data-page="control" class="page page-control">
  <!-- Header with Menu -->
  <header class="layout-header" data-dashboard-menu-target></header>

  <!-- Main content -->
  <main class="layout-main layout-main--wide">
    <!-- Page header -->
    <header class="l-cluster u-mb-lg">
      <h1 class="control-title">
        <span class="brand-accent">Rider-PC</span>
        <span class="page-title-text">: Sterowanie ruchem (REST /api)</span>
      </h1>
      <span
        id="apiStatus"
        class="u-muted control-status"
        data-i18n="header.api_status_checking"
      >(checking‚Ä¶)</span>
      <span
        id="obstBadge"
        class="c-pill is-warn control-badge"
        hidden
        data-i18n="header.obstacle_na"
      >Obstacle: n/a</span>
    </header>

    <div class="panel-row l-row">
      <!-- 1) KAMERA -->
      <div class="c-card cam-card">
        <h2 class="c-card__title" data-i18n="camera.title">PodglƒÖd kamery</h2>

        <div class="cam-actions cluster">
          <button id="camToggle" class="c-btn c-btn-sm" data-i18n="camera.auto_refresh_on">
            ‚ü≥ Auto-refresh (on)
          </button>
          <button id="btnUseEdge" class="c-btn c-btn-sm" data-i18n="camera.use_edge">Use EDGE</button>
          <button id="btnUseCam" class="c-btn c-btn-sm" data-i18n="camera.use_cam">Use CAM</button>
        </div>

        <div class="media-frame">
          <div>
          <img id="camPrev" class="cam" alt="camera preview" src="/camera/last?ts=0" />
          <div
            class="c-note cam-info"
            id="camInfo"
            data-i18n="camera.last_frame_na"
          >last frame: n/a ¬∑ source: n/a</div>
        </div>
      </div>
    </div>

    <!-- 2) STEROWANIE -->
    <div class="c-card control-card">
      <h2 class="c-card__title" data-i18n="motion.title">Sterowanie ruchem</h2>

      <div class="l-row control-range-row">
        <label>
          <span data-i18n="motion.turning_speed">Prƒôdko≈õƒá skrƒôtu</span>
          <span class="muted" data-i18n="motion.turning_range">(0..1)</span>:
          <input id="speedSpin" type="range" min="0" max="1" step="0.02" value="0.18" />
          <span id="speedSpinVal">0.18</span>
        </label>
        <label>
          <span data-i18n="motion.max_speed">Prƒôdko≈õƒá maksymalna</span>
          <span class="muted" data-i18n="motion.max_speed_range">(0..1)</span>:
          <input id="speedMax" type="range" min="0" max="1" step="0.05" value="0.10" />
          <span id="speedMaxVal">0.10</span>
        </label>
        <label>
          <span data-i18n="motion.pulse_time">Czas impulsu [s]</span>:
          <input id="durationSpin" type="number" min="0.05" step="0.05" value="0.10" />
        </label>
        <div class="u-spacer"></div>
        <button id="btnStop" class="c-btn motion-btn" data-i18n="motion.btn_stop">‚ñ† STOP</button>
      </div>

      <div class="motion-grid">
        <div></div>
        <button id="btnFwd" class="c-btn motion-btn" data-i18n="motion.btn_forward">‚Üë Forward</button>
        <div></div>
        <button id="btnLeft" class="c-btn motion-btn" data-i18n="motion.btn_left">‚Üê Left</button>
        <button id="btnStop2" class="c-btn motion-btn" data-i18n="motion.btn_stop_small">‚ñ† Stop</button>
        <button id="btnRight" class="c-btn motion-btn" data-i18n="motion.btn_right">Right ‚Üí</button>
        <div></div>
        <button id="btnBack" class="c-btn motion-btn" data-i18n="motion.btn_backward">‚Üì Backward</button>
        <div></div>
      </div>

      <div class="l-row">
        <span class="muted">
          <span data-i18n="motion.shortcuts_hint">Skr√≥ty</span>:
          <span class="kbd">W/S/A/D</span>
          <span data-i18n="motion.shortcuts_tail">lub strza≈Çki; Spacja = stop.</span>
        </span>
        <div class="u-spacer"></div>
      </div>

      <div class="balance-control-row">
        <div class="balance-control">
          <label for="balanceToggle">
            <span data-i18n="balance.toggle_label">Balans (stabilizacja)</span>
            <input id="balanceToggle" type="checkbox" />
          </label>
        </div>
        <div class="balance-control">
          <label for="heightSlider">
            <span data-i18n="balance.height_label">Wysoko≈õƒá</span>
            <input
              id="heightSlider"
              type="range"
              min="0"
              max="12"
              step="1"
              value="6"
            />
            <span id="heightValue">6</span>
          </label>
        </div>
      </div>
    </div>
  </div>

  <!-- FUNKCJE + ZASOBY -->
  <div class="panel-row feature-resource">
    <div class="c-card feature-card">
      <h2 class="c-card__title" data-i18n="motion.features_title">Funkcje</h2>
      <div class="feature-list" id="featureList">
        <div class="feature-row" data-feature="zero">
          <div class="feature-info">
            <div class="feature-head">
              <div
                class="feature-title"
                data-i18n="motion.zero_mode"
              >Stan 0 ‚Äì Sterowanie rƒôczne</div>
            </div>
            <div
              class="feature-desc"
              data-i18n="motion.feature_zero_desc"
            >Pozostawia tylko us≈Çugi bazowe (komunikacja + sterowanie rƒôczne), wy≈ÇƒÖczajƒÖc rekonesans i ≈õledzenie.</div>
          </div>
          <div class="feature-status">
            <span class="c-pill feature-pill" data-feature-pill="zero">n/a</span>
          </div>
          <div class="feature-actions">
            <button
              class="c-btn c-btn-sm"
              data-feature-action="start"
              data-i18n="motion.feature_zero_btn_reset"
            >Reset</button>
            <div class="feature-note" data-feature-note="zero"></div>
          </div>
        </div>

        <div class="feature-row" data-feature="tracking">
          <div class="feature-info">
            <div class="feature-head">
              <div
                class="feature-title"
                data-i18n="motion.tracking_mode_title"
              >≈öledzenie (twarz / d≈Ço≈Ñ)</div>
            </div>
            <div
              class="feature-desc"
              data-i18n="motion.feature_tracking_desc"
            >Uruchamia tracker oraz kontroler ruchu ‚Äì wybierz tryb ≈õledzenia poni≈ºej.</div>
            <div class="feature-select">
              <span data-i18n="motion.tracking_mode_label">Tryb ≈õledzenia</span>:
              <select id="trackingMode">
                <option value="face" data-i18n="motion.tracking_mode_face">Twarz</option>
                <option value="hand" data-i18n="motion.tracking_mode_hand">D≈Ço≈Ñ</option>
              </select>
            </div>
          </div>
          <div class="feature-status">
            <span class="c-pill feature-pill" data-feature-pill="tracking">n/a</span>
          </div>
          <div class="feature-actions">
            <button
              class="c-btn c-btn-sm"
              data-feature-action="start"
              data-i18n="motion.feature_btn_start"
            >Start</button>
            <button
              class="c-btn c-btn-sm"
              data-feature-action="stop"
              data-i18n="motion.feature_btn_stop"
            >Stop</button>
            <div class="feature-note" data-feature-note="tracking"></div>
          </div>
        </div>

        <div class="feature-row" data-feature="recon">
          <div class="feature-info">
            <div class="feature-head">
              <div
                class="feature-title"
                data-i18n="motion.recon_mode"
              >Tryb Rekonesans (autonomiczny)</div>
            </div>
            <div
              class="feature-desc"
              data-i18n="motion.feature_recon_desc"
            >W≈ÇƒÖcza odometriƒô, mapper oraz startuje navigatora.</div>
            <div class="feature-select">
              <span data-i18n="motion.recon_strategy">Strategia</span>:
              <select id="reconStrategy">
                <option value="STOP">STOP (zatrzymaj)</option>
                <option value="AVOID">AVOID (omijaj)</option>
              </select>
            </div>
          </div>
          <div class="feature-status">
            <span class="c-pill feature-pill" data-feature-pill="recon">n/a</span>
          </div>
          <div class="feature-actions">
            <button
              class="c-btn c-btn-sm"
              data-feature-action="start"
              data-i18n="motion.feature_btn_start"
            >Start</button>
            <button
              class="c-btn c-btn-sm"
              data-feature-action="stop"
              data-i18n="motion.feature_btn_stop"
            >Stop</button>
            <button
              class="c-btn c-btn-sm"
              id="btnReturnHome"
              data-feature-action="return-home"
              data-i18n="motion.return_home"
            >üè† Powr√≥t do Bazy</button>
            <div class="feature-note" data-feature-note="recon"></div>
          </div>
        </div>
      </div>
    </div>

    <div class="c-card resource-card">
      <h2 class="c-card__title" data-i18n="resources.title">Diagnostyka zasob√≥w</h2>
      <div id="resInfo" class="muted" data-i18n="meta.loading">≈Åadowanie‚Ä¶</div>
      <table class="svc-table" id="resTable">
        <thead>
        <tr>
          <th data-i18n="resources.column_name">Zas√≥b</th>
          <th data-i18n="resources.column_status">Status</th>
          <th data-i18n="resources.column_holders">BlokujƒÖce procesy</th>
          <th data-i18n="resources.column_actions">Akcje</th>
        </tr>
        </thead>
        <tbody id="resBody">
        <tr data-res="mic">
          <td data-i18n="resources.mic">Mikrofon</td>
          <td class="res-status">n/a</td>
          <td class="res-holders">-</td>
          <td class="svc-actions">
            <button class="c-btn c-btn-sm" data-res="mic" data-res-action="refresh">‚ü≥</button>
            <button
              class="c-btn c-btn-sm"
              data-res="mic"
              data-res-action="stop"
              data-i18n="resources.btn_stop_service"
            >Stop us≈Çugi</button>
            <button
              class="c-btn c-btn-sm"
              data-res="mic"
              data-res-action="release"
              data-i18n="resources.btn_release"
            >Zwolnij</button>
          </td>
        </tr>
        <tr data-res="speaker">
          <td data-i18n="resources.speaker">G≈Ço≈õnik</td>
          <td class="res-status">n/a</td>
          <td class="res-holders">-</td>
          <td class="svc-actions">
            <button class="c-btn c-btn-sm" data-res="speaker" data-res-action="refresh">‚ü≥</button>
            <button
              class="c-btn c-btn-sm"
              data-res="speaker"
              data-res-action="stop"
              data-i18n="resources.btn_stop_service"
            >Stop us≈Çugi</button>
            <button
              class="c-btn c-btn-sm"
              data-res="speaker"
              data-res-action="release"
              data-i18n="resources.btn_release"
            >Zwolnij</button>
          </td>
        </tr>
        <tr data-res="camera">
          <td data-i18n="resources.camera">Kamera</td>
          <td class="res-status">n/a</td>
          <td class="res-holders">-</td>
          <td class="svc-actions">
            <button class="c-btn c-btn-sm" data-res="camera" data-res-action="refresh">‚ü≥</button>
            <button
              class="c-btn c-btn-sm"
              data-res="camera"
              data-res-action="stop"
              data-i18n="resources.btn_stop_service"
            >Stop us≈Çugi</button>
            <button
              class="c-btn c-btn-sm"
              data-res="camera"
              data-res-action="release"
              data-i18n="resources.btn_release"
            >Zwolnij</button>
          </td>
        </tr>
        <tr data-res="lcd">
          <td data-i18n="resources.lcd">Ekran LCD 2"</td>
          <td class="res-status">n/a</td>
          <td class="res-holders">-</td>
          <td class="svc-actions">
            <button class="c-btn c-btn-sm" data-res="lcd" data-res-action="refresh">‚ü≥</button>
            <button
              class="c-btn c-btn-sm"
              data-res="lcd"
              data-res-action="stop"
              data-i18n="resources.btn_stop_service"
            >Stop us≈Çugi</button>
            <button
              class="c-btn c-btn-sm"
              data-res="lcd"
              data-res-action="release"
              data-i18n="resources.btn_release"
            >Zwolnij</button>
          </td>
        </tr>
        </tbody>
      </table>
    </div>
  </div>

  <div class="panel-row scenario-panel">
    <div class="c-card scenario-card">
      <h2 class="c-card__title">Scenariusze / targety</h2>
      <div class="feature-list scenario-list" id="scenarioList">
        <div class="muted" data-i18n="meta.loading">≈Åadowanie‚Ä¶</div>
      </div>
      <div id="scenarioInfo" class="muted"></div>
    </div>
  </div>

  <div class="c-card service-card">
    <details class="svc-diagnostics" open>
      <summary class="c-card__title svc-summary">
        <span data-i18n="services.title">Us≈Çugi (systemd)</span>
      </summary>
      <div class="svc-controls" aria-label="Us≈Çugi ‚Äì sterowanie listƒÖ">
        <button
          id="svcRefresh"
          class="c-btn c-btn-sm section-action"
          data-i18n="services.refresh"
          title="Rƒôcznie od≈õwie≈º listƒô us≈Çug"
        >‚ü≥ od≈õwie≈º</button>
        <label class="svc-control" title="Auto od≈õwie≈ºanie tabeli co 5 sekund">
          <span class="svc-icon" aria-hidden="true">‚ü≥</span>
          <input id="svcAutoRefresh" type="checkbox" />
          <span class="svc-label" data-i18n="services.auto_refresh">Auto (5s)</span>
        </label>
        <label class="svc-control" title="Filtruj wiersze po stanie us≈Çugi">
          <span class="svc-icon" aria-hidden="true">üîé</span>
          <span class="svc-label" data-i18n="services.filter">Filtr</span>
          <select id="svcFilter" class="svc-select">
            <option value="all" data-i18n="services.filter_all">Wszystkie</option>
            <option value="ok" data-i18n="services.filter_ok">Aktywne</option>
            <option value="warn" data-i18n="services.filter_warn">Ostrze≈ºenia</option>
            <option value="err" data-i18n="services.filter_err">B≈Çƒôdy</option>
            <option value="unknown" data-i18n="services.filter_unknown">Nieznane</option>
          </select>
        </label>
      </div>
      <div id="svcInfo" class="muted">
        <span data-i18n="meta.loading">≈Åadowanie‚Ä¶</span>
        <span id="svcTs"></span>
      </div>
      <table class="svc-table" id="svcTable" hidden>
        <thead>
        <tr>
          <th data-i18n="services.unit">Unit</th>
          <th data-i18n="services.desc">Opis</th>
          <th data-i18n="services.status">Status</th>
          <th data-i18n="services.autostart">Autostart</th>
          <th data-i18n="services.actions">Akcje</th>
        </tr>
        </thead>
        <tbody id="svcBody"></tbody>
      </table>
    </details>
  </div>

  <!-- LOG -->
  <div class="c-card log-card">
    <h2 class="c-card__title" data-i18n="events.title">Zdarzenia (SSE /events)</h2>
    <div id="log"></div>
  </div>

  <div class="c-card motion-queue-card">
    <h2 class="c-card__title">
      <span data-i18n="motion_queue.title">Kolejka ruchu</span>
      <button
        id="btnMotionQueueFlush"
        class="c-btn c-btn-sm section-action"
        data-i18n="motion_queue.btn_flush"
      >‚èπ stop &amp; wyczy≈õƒá</button>
    </h2>
    <div id="motionQueueInfo" class="muted" data-i18n="motion_queue.loading">
      Brak danych‚Ä¶
    </div>
    <table class="svc-table" id="motionQueueTable">
      <thead>
      <tr>
        <th data-i18n="motion_queue.column_source">≈πr√≥d≈Ço</th>
        <th data-i18n="motion_queue.column_vx">Vx</th>
        <th data-i18n="motion_queue.column_vy">Vy</th>
        <th data-i18n="motion_queue.column_yaw">Yaw</th>
        <th data-i18n="motion_queue.column_time">Czas [s]</th>
        <th data-i18n="motion_queue.column_status">Status</th>
        <th data-i18n="motion_queue.column_age">Wiek</th>
      </tr>
      </thead>
      <tbody id="motionQueueBody">
      <tr>
        <td
          colspan="7"
          class="u-muted"
          data-i18n="motion_queue.empty_placeholder"
        >Brak zlece≈Ñ ruchu.</td>
      </tr>
      </tbody>
    </table>
  </div>
  </main>

  <!-- Footer -->
  <footer class="layout-footer" data-dashboard-footer-target></footer>

<script type="module" src="/web/assets/menu.js"></script>
<script type="module" src="/web/assets/footer.js"></script>
<script type="module">
  import { initI18n, applyDom, t } from "/web/assets/i18n.js";

  // legacy endpoint string kept for compatibility with tests/tools
  const LEGACY_TRACKING_ENDPOINT = "/api/vision/tracking/mode";

  // --- i18n init ---
  const urlLang = new URLSearchParams(location.search).get("lang");
  const saved = localStorage.getItem("lang");
  const browser = (navigator.language || "").slice(0, 2).toLowerCase();
  const pick = (v) =>
    v && v.toLowerCase().startsWith("en")
      ? "en"
      : v && v.toLowerCase().startsWith("pl")
        ? "pl"
        : null;
  const lang = pick(urlLang) || pick(saved) || pick(browser) || "pl";
  if (urlLang) {
    localStorage.setItem("lang", lang);
  }

  async function fetchControlState() {
    try {
      const j = await fetchJson("/api/control/state");
      const balance = j.balance || {};
      if (balanceToggle && typeof balance.enabled === "boolean") {
        balanceToggle.checked = !!balance.enabled;
      }
      const heightState = j.height || {};
      if (typeof heightState.value === "number") {
        syncHeightValue(heightState.value);
      }

      lastControlState = j || {};
      const trackingState = getTrackingState();
      const trackingMode = normalizeTrackingMode(trackingState.mode);
      const trackingEnabled =
        !!trackingState.enabled && trackingMode !== "none";
      syncTrackingModeSelect(trackingMode);
      const trackingNote = trackingEnabled
        ? t("motion.feature_note_mode", { mode: trackingMode })
        : "";
      setFeatureStatus(
        "tracking",
        trackingEnabled ? "running" : "stopped",
        trackingNote,
      );

      const navigatorState = getNavigatorState();
      const reconRunning = !!navigatorState.active;
      const reconNote = navigatorState.state
        ? t("motion.feature_note_state", { state: navigatorState.state })
        : "";
      setFeatureStatus(
        "recon",
        reconRunning ? "running" : "stopped",
        reconRunning ? reconNote : "",
      );

      if (!trackingEnabled && !reconRunning) {
        setFeatureStatus(
          "zero",
          "running",
          t("motion.feature_zero_note_ready"),
        );
      } else {
        const active = [];
        if (trackingEnabled) {
          active.push(t("motion.zero_tracking_label"));
        }
        if (reconRunning) {
          active.push(t("motion.zero_recon_label"));
        }
        setFeatureStatus(
          "zero",
          "warn",
          t("motion.feature_zero_note_blocked", {
            list: active.join(" ¬∑ ") || "-",
          }),
        );
      }
    } catch (e) {
      appendLog(
        `/api/control/state :: ${e.message || e}`,
        "warn",
      );
    }
  }
  await initI18n(lang);
  applyDom();
  document.documentElement.setAttribute("lang", lang);
  document.title = t("meta.app_title");

  // ====== helpers ======
  const qs = (s) => document.querySelector(s);
  const logEl = qs("#log");
  const MAX_ERR_SNIPPET = 140;

  function formatHttpError(status, statusText, raw) {
    const txt = (raw || "").trim();
    if (!txt) {
      return `HTTP ${status} :: ${statusText || "error"}`;
    }
    const stripped = txt.replace(/<[^>]*>/g, " ").replace(/\s+/g, " ").trim();
    const preview = stripped || statusText || "error";
    return `HTTP ${status} :: ${preview.slice(0, MAX_ERR_SNIPPET)}`;
  }

  function appendLog(msg, cls = "") {
    if (!logEl) return;
    const line = document.createElement("div");
    if (cls) line.className = cls;
    line.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
    logEl.appendChild(line);
    logEl.scrollTop = logEl.scrollHeight;
  }

  window.addEventListener("error", (e) =>
    appendLog(
      `${t("events.log_js_err", { msg: e.message || e })}`,
      "err",
    ),
  );
  window.addEventListener("unhandledrejection", (e) =>
    appendLog(
      `${t("events.log_prom_err", { reason: e.reason || e })}`,
      "err",
    ),
  );

  const LIN_V_DEFAULT = 0.1;
  const LIN_T = 0.1;
  let linV = LIN_V_DEFAULT;
  function clamp(n, lo, hi) {
    n = Number(n) || 0;
    return Math.max(lo, Math.min(hi, n));
  }
  const spinEl = qs("#speedSpin");
  const spinVal = qs("#speedSpinVal");
  const speedMaxEl = qs("#speedMax");
  const speedMaxVal = qs("#speedMaxVal");
  const durSpinEl = qs("#durationSpin");

  if (spinEl && spinVal) {
    spinEl.addEventListener("input", () => {
      spinVal.textContent = Number(spinEl.value).toFixed(2);
    });
  }

  function updateLinearSpeed() {
    if (!speedMaxEl || !speedMaxVal) {
      linV = LIN_V_DEFAULT;
      return;
    }
    const val = clamp(speedMaxEl.value, 0, 1);
    linV = val;
    speedMaxVal.textContent = val.toFixed(2);
  }

  if (speedMaxEl) {
    updateLinearSpeed();
    speedMaxEl.addEventListener("input", updateLinearSpeed);
  }

  async function pingHealth() {
    try {
      const r = await fetch("/healthz", { cache: "no-store" });
      const j = await r.json().catch(() => ({}));
      const apiStatus = qs("#apiStatus");
      if (!apiStatus) return;
      const ok = !!j.ok;
      apiStatus.textContent = ok
        ? t("header.api_status_ok")
        : t("header.api_status_degraded");
      apiStatus.className = ok ? "ok" : "warn";
    } catch {
      const apiStatus = qs("#apiStatus");
      if (!apiStatus) return;
      apiStatus.textContent = t("header.api_status_down");
      apiStatus.className = "err";
    }
  }

  setInterval(pingHealth, 1000);
  pingHealth();

  const AI_MODE_ENDPOINT = "/api/system/ai-mode";
  const PROVIDER_STATE_ENDPOINT = "/api/providers/state";
  const PROVIDER_DOMAINS = ["vision", "voice", "text"];

  async function sendJson(url, body, method = "POST") {
    const r = await fetch(url, {
      method,
      headers: { "Content-Type": "application/json" },
      body: body ? JSON.stringify(body) : undefined,
      cache: "no-store",
    });
    const raw = await r.text();
    let j = null;
    try {
      j = raw ? JSON.parse(raw) : {};
    } catch {
      /* ignore */
    }
    if (!r.ok) {
      const snippet =
        (j && (j.error || j.stderr || j.stdout)) ||
        formatHttpError(r.status, r.statusText, raw);
      throw new Error(snippet);
    }
    if (!j) {
      throw new Error(`HTTP ${r.status}: invalid JSON`);
    }
    return j;
  }

  async function httpPost(url, body) {
    return sendJson(url, body, "POST");
  }

  async function fetchJson(url, options = {}) {
    const r = await fetch(url, { cache: "no-store", ...options });
    const raw = await r.text();
    if (!r.ok) {
      throw new Error(formatHttpError(r.status, r.statusText, raw));
    }
    if (!raw.trim()) {
      return {};
    }
    try {
      return JSON.parse(raw);
    } catch (err) {
      throw new Error(`invalid JSON :: ${err.message}`);
    }
  }

  async function apiControl(obj) {
    const payload = { ...obj };
    if (!payload.source) {
      payload.source = "pc-ui";
    }
    try {
      const j = await httpPost("/api/control", payload);
      appendLog(
        `api/control ‚Üí ${JSON.stringify(payload)} :: ${JSON.stringify(j)}`,
        "ok",
      );
      return j;
    } catch (e) {
      appendLog(
        `api/control ${JSON.stringify(payload)} :: ${e.message}`,
        "err",
      );
    }
  }

  async function doStop() {
    try {
      await apiControl({ cmd: "stop" });
    } catch {
      /* ignore */
    }
  }

  async function goF() {
    const tsec = Math.max(0.05, LIN_T);
    const v = clamp(linV, 0, 1);
    await apiControl({
      cmd: "move",
      dir: "forward",
      v,
      t: tsec,
    });
    setTimeout(() => {
      try {
        doStop();
      } catch {
        /* ignore */
      }
    }, Math.max(100, tsec * 1000));
  }

  async function goB() {
    const tsec = Math.max(0.05, LIN_T);
    const v = clamp(linV, 0, 1);
    await apiControl({
      cmd: "move",
      dir: "backward",
      v,
      t: tsec,
    });
    setTimeout(() => {
      try {
        doStop();
      } catch {
        /* ignore */
      }
    }, Math.max(100, tsec * 1000));
  }

  async function spin(dir) {
    if (!spinEl || !durSpinEl) return;
    const w = clamp(spinEl.value, 0, 1);
    const tsec = clamp(durSpinEl.value, 0.05, 5);
    await apiControl({
      cmd: "move",
      dir: dir === "left" ? "left" : "right",
      w,
      t: tsec,
    });
    setTimeout(() => {
      try {
        doStop();
      } catch {
        /* ignore */
      }
    }, Math.max(100, tsec * 1000));
  }

  qs("#btnFwd")?.addEventListener("click", () => {
    try {
      goF();
    } catch {
      /* ignore */
    }
  });
  qs("#btnBack")?.addEventListener("click", () => {
    try {
      goB();
    } catch {
      /* ignore */
    }
  });
  qs("#btnLeft")?.addEventListener("click", () => {
    try {
      spin("left");
    } catch {
      /* ignore */
    }
  });
  qs("#btnRight")?.addEventListener("click", () => {
    try {
      spin("right");
    } catch {
      /* ignore */
    }
  });
  qs("#btnStop")?.addEventListener("click", () => {
    try {
      doStop();
    } catch {
      /* ignore */
    }
  });
  qs("#btnStop2")?.addEventListener("click", () => {
    try {
      doStop();
    } catch {
      /* ignore */
    }
  });

  const pressed = new Set();
  const isArrow = (k) =>
    ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(k);

  window.addEventListener("keydown", (ev) => {
    try {
      if (ev.repeat) return;
      const k = ev.key;
      if (isArrow(k)) ev.preventDefault();
      pressed.add(k);
      if (k === " ") {
        ev.preventDefault();
        doStop();
        return;
      }
      if (k === "w" || k === "W" || k === "ArrowUp") goF();
      if (k === "s" || k === "S" || k === "ArrowDown") goB();
      if (k === "a" || k === "A" || k === "ArrowLeft") spin("left");
      if (k === "d" || k === "D" || k === "ArrowRight") spin("right");
    } catch {
      /* ignore */
    }
  });

  window.addEventListener("keyup", (ev) => {
    try {
      if (!pressed.has(ev.key)) return;
      pressed.delete(ev.key);
      if (
        [
          "w",
          "W",
          "ArrowUp",
          "s",
          "S",
          "ArrowDown",
          "a",
          "A",
          "ArrowLeft",
          "d",
          "D",
          "ArrowRight",
        ].includes(ev.key)
      ) {
        doStop();
      }
    } catch {
      /* ignore */
    }
  });

  document.addEventListener("visibilitychange", () => {
    if (document.hidden) {
      try {
        doStop();
      } catch {
        /* ignore */
      }
    }
  });

  window.addEventListener("beforeunload", () => {
    try {
      navigator.sendBeacon(
        "/api/control",
        new Blob(['{"cmd":"stop"}'], {
          type: "application/json",
        }),
      );
    } catch {
      /* ignore */
    }
  });

  // ==== FEATURES (via /api/logic/feature) ====
  const featureBusy = new Set();
  let trackingModeSelect = null;
  const svcCache = new Map();
  let lastControlState = {};
  let svcRefreshTimer = null;
  let svcFilterMode = "all";

  const FEATURE_STATUS = {
    running: { cls: "ok", key: "motion.feature_status_running" },
    stopped: { cls: "warn", key: "motion.feature_status_stopped" },
    warn: { cls: "warn", key: "motion.feature_status_warn" },
    error: { cls: "err", key: "motion.feature_status_error" },
    unknown: { cls: "warn", key: "motion.feature_status_unknown" },
    working: { cls: "warn", key: "motion.feature_status_working" },
  };

  function normalizeTrackingMode(mode) {
    const val = String(mode || "").toLowerCase();
    if (val === "hand") return "hand";
    if (val === "face") return "face";
    return "none";
  }

  function syncTrackingModeSelect(mode) {
    if (!trackingModeSelect) return;
    const normalized = mode === "hand" ? "hand" : mode === "face" ? "face" : "face";
    if (trackingModeSelect.value !== normalized) {
      trackingModeSelect.value = normalized;
    }
  }

  function selectedTrackingMode() {
    if (!trackingModeSelect) return "face";
    return trackingModeSelect.value === "hand" ? "hand" : "face";
  }

  const featureList = qs("#featureList");
  trackingModeSelect = qs("#trackingMode");
  if (featureList) {
    featureList.addEventListener("click", (ev) => {
      const btn = ev.target.closest("button[data-feature-action]");
      if (!btn) return;
      const row = btn.closest("[data-feature]");
      if (!row) return;
      const featureId = row.getAttribute("data-feature");
      const action = btn.getAttribute("data-feature-action");
      handleFeatureAction(featureId, action);
    });
  }

  const scenarioListEl = qs("#scenarioList");
  const scenarioInfoEl = qs("#scenarioInfo");
  const scenarioBusy = new Set();
  if (scenarioListEl) {
    scenarioListEl.addEventListener("click", (ev) => {
      const btn = ev.target.closest("button[data-scenario-action]");
      if (!btn) return;
      const row = btn.closest("[data-scenario]");
      if (!row) return;
      const featureName = row.getAttribute("data-scenario");
      const action = btn.getAttribute("data-scenario-action");
      handleScenarioAction(featureName, action);
    });
  }

  function setFeatureBusy(featureId, busy) {
    const row = document.querySelector(`[data-feature="${featureId}"]`);
    if (!row) return;
    if (busy) featureBusy.add(featureId);
    else featureBusy.delete(featureId);
    row.classList.toggle("busy", !!busy);
    row.querySelectorAll("button").forEach((btn) => {
      btn.disabled = !!busy;
    });
  }

  function setFeatureStatus(featureId, stateKey, noteText = "") {
    const pill = document.querySelector(
      `.feature-pill[data-feature-pill="${featureId}"]`,
    );
    const note = document.querySelector(
      `.feature-note[data-feature-note="${featureId}"]`,
    );
    const meta = FEATURE_STATUS[stateKey] || FEATURE_STATUS.unknown;
    if (pill) {
      pill.className = `c-pill feature-pill ${meta.cls}`;
      pill.textContent = t(meta.key);
    }
    if (note) {
      note.textContent = noteText || "";
    }
  }

  function scenarioStatusKey(feature) {
    if (feature.active) return "running";
    return feature.status === "partial" ? "warn" : "stopped";
  }

  function renderScenarioList(summary) {
    if (!scenarioListEl) return;
    const features = (summary && summary.features) || [];
    if (!features.length) {
      scenarioListEl.innerHTML =
        '<div class="muted" data-i18n="motion.features_empty">Brak danych</div>';
      return;
    }
    const frag = document.createDocumentFragment();
    features.forEach((feat) => {
      const row = document.createElement("div");
      row.className = "feature-row scenario-row";
      row.setAttribute("data-scenario", feat.name);

      const info = document.createElement("div");
      info.className = "feature-info";

      const head = document.createElement("div");
      head.className = "feature-head";
      const title = document.createElement("div");
      title.className = "feature-title";
      title.textContent = `${feat.scenario || ""} ‚Äì ${feat.title || feat.name}`;
      const desc = document.createElement("div");
      desc.className = "feature-desc";
      desc.textContent = feat.description || "";
      head.appendChild(title);
      head.appendChild(desc);

      const meta = document.createElement("div");
      meta.className = "feature-note muted";
      meta.textContent = `Us≈Çugi: ${
        feat.services_active ?? 0
      }/${feat.services_total ?? 0}`;

      info.appendChild(head);
      info.appendChild(meta);

      const statusCol = document.createElement("div");
      statusCol.className = "feature-status";
      const statusKey = scenarioStatusKey(feat);
      const pillMeta = FEATURE_STATUS[statusKey] || FEATURE_STATUS.unknown;
      const pill = document.createElement("span");
      pill.className = `c-pill feature-pill ${pillMeta.cls}`;
      pill.dataset.scenarioPill = feat.name;
      pill.textContent = t(pillMeta.key);
      statusCol.appendChild(pill);

      const actions = document.createElement("div");
      actions.className = "feature-actions";
      const startBtn = document.createElement("button");
      startBtn.className = "c-btn c-btn-sm";
      startBtn.dataset.scenarioAction = "start";
      startBtn.textContent = t("motion.feature_btn_start");
      const stopBtn = document.createElement("button");
      stopBtn.className = "c-btn c-btn-sm";
      stopBtn.dataset.scenarioAction = "stop";
      stopBtn.textContent = t("motion.feature_btn_stop");
      actions.appendChild(startBtn);
      actions.appendChild(stopBtn);

      row.appendChild(info);
      row.appendChild(statusCol);
      row.appendChild(actions);
      frag.appendChild(row);
    });
    scenarioListEl.innerHTML = "";
    scenarioListEl.appendChild(frag);
    if (scenarioInfoEl) {
      const counts = summary && summary.counts ? summary.counts : {};
      const total = counts.total ?? features.length;
      scenarioInfoEl.textContent = `Aktywne: ${counts.active ?? 0}/${total}`;
    }
  }

  function setScenarioBusy(row, busy) {
    if (!row) return;
    const name = row.getAttribute("data-scenario") || "";
    if (busy) scenarioBusy.add(name);
    else scenarioBusy.delete(name);
    row.classList.toggle("busy", !!busy);
    row.querySelectorAll("button").forEach((btn) => {
      btn.disabled = !!busy;
    });
  }

  async function refreshScenarioList(silent = false) {
    if (!scenarioListEl) return;
    try {
      const data = await fetchJson("/api/logic/summary");
      renderScenarioList(data.summary || {});
    } catch (e) {
      if (!silent) {
        appendLog(`[scenario] fetch failed :: ${e.message || e}`, "err");
      }
    }
  }

  async function handleScenarioAction(featureName, action) {
    if (!featureName || !action) return;
    const row = document.querySelector(
      `[data-scenario="${featureName}"]`,
    );
    if (!row) return;
    setScenarioBusy(row, true);
    try {
      await logicFeatureToggle(featureName, action === "start");
      appendLog(
        `[scenario ${featureName}] ${action}`,
        "ok",
      );
    } catch (e) {
      appendLog(
        `[scenario ${featureName}] ${action} :: ${e.message || e}`,
        "err",
      );
    } finally {
      setScenarioBusy(row, false);
      try {
        await refreshScenarioList(true);
      } catch {
        /* ignore */
      }
      try {
        await fetchControlState();
      } catch {
        /* ignore */
      }
    }
  }

  function getTrackingState() {
    return (lastControlState && lastControlState.tracking) || {};
  }

  function getNavigatorState() {
    return (lastControlState && lastControlState.navigator) || {};
  }

  function isTrackingActive() {
    const st = getTrackingState();
    return !!(st.enabled && normalizeTrackingMode(st.mode) !== "none");
  }

  function isReconActive() {
    const nav = getNavigatorState();
    return !!nav.active;
  }

  async function startZeroFeature() {
    await featureApiToggle("face_tracking", false);
    await featureApiToggle("recon", false);
    appendLog("[feature zero] minimal stack ready", "ok");
  }

  async function handleFeatureAction(featureId, action) {
    if (action === "return-home") {
      await runReturnHome();
      return;
    }
    setFeatureBusy(featureId, true);
    setFeatureStatus(
      featureId,
      "working",
      t("motion.feature_note_waiting"),
    );
    try {
      if (action === "start") {
        await startFeature(featureId);
      } else if (action === "stop") {
        await stopFeature(featureId);
      }
    } catch (e) {
      appendLog(
        `[feature ${featureId}] ${action} :: ${e.message || e}`,
        "err",
      );
      setFeatureStatus(featureId, "error", e.message || String(e));
    } finally {
      setFeatureBusy(featureId, false);
      try {
        await fetchControlState();
      } catch {
        /* ignore */
      }
      try {
        await fetchMotionQueue();
      } catch {
        /* ignore */
      }
      try {
        await refreshScenarioList(true);
      } catch {
        /* ignore */
      }
    }
  }

  async function startFeature(featureId) {
    if (featureId === "zero") return startZeroFeature();
    if (featureId === "tracking") return featureApiToggle("face_tracking", true);
    if (featureId === "recon") return featureApiToggle("recon", true);
    throw new Error(`unknown feature ${featureId}`);
  }

  async function stopFeature(featureId) {
    if (featureId === "zero") return startZeroFeature();
    if (featureId === "tracking") return featureApiToggle("face_tracking", false);
    if (featureId === "recon") return featureApiToggle("recon", false);
    throw new Error(`unknown feature ${featureId}`);
  }

  async function runReturnHome() {
    setFeatureBusy("recon", true);
    setFeatureStatus(
      "recon",
      "working",
      t("motion.feature_note_waiting"),
    );
    try {
      await httpPost("/api/navigator/return_home", {});
      appendLog("[feature recon] return_home", "ok");
    } catch (e) {
      appendLog(
        `[feature recon] return_home :: ${e.message || e}`,
        "err",
      );
      setFeatureStatus("recon", "error", e.message || String(e));
    } finally {
      setFeatureBusy("recon", false);
      try {
        await fetchControlState();
      } catch {
        /* ignore */
      }
      try {
        await fetchMotionQueue();
      } catch {
        /* ignore */
      }
    }
  }

  async function logicFeatureToggle(featureName, enabled) {
    return httpPost(`/api/logic/feature/${encodeURIComponent(featureName)}`, { enabled });
  }

  async function featureApiToggle(featureName, enabled) {
    const res = await logicFeatureToggle(featureName, enabled);
    const modeNote = featureName === "face_tracking" ? selectedTrackingMode() : "";
    const note = enabled
      ? featureName === "face_tracking"
        ? t("motion.feature_note_mode", { mode: modeNote })
        : ""
      : t("motion.feature_status_stopped");
    setFeatureStatus(
      featureName === "recon" ? "recon" : "tracking",
      res.ok ? "running" : "error",
      note,
    );
    appendLog(
      `[feature ${featureName}] ${enabled ? "start" : "stop"} :: ${JSON.stringify(res)}`,
      res.ok ? "ok" : "err",
    );
    return res;
  }

  async function fetchServices() {
    try {
      const data = await fetchJson("/svc");
      const services = Array.isArray(data?.services) ? data.services : [];
      const tbody = qs("#svcBody");
      const table = qs("#svcTable");
      const info = qs("#svcInfo");
      const ts = qs("#svcTs");
      if (!tbody || !table || !info) return;

      svcCache.clear();
      tbody.innerHTML = "";

      const normalizeSvcValue = (value) => String(value ?? "").trim().toLowerCase();

      function describeStatus(activeValue, subValue) {
        const activeNorm = normalizeSvcValue(activeValue);
        const subNorm = normalizeSvcValue(subValue);
        if (!activeNorm && !subNorm) {
          return { cls: "svc-state-unknown", text: t("services.status_unknown") };
        }
        if (
          activeNorm.includes("fail") ||
          activeNorm.includes("error") ||
          subNorm.includes("fail")
        ) {
          return { cls: "svc-state-err", text: t("services.status_failed") };
        }
        if (
          activeNorm.startsWith("inactive") ||
          activeNorm.startsWith("dead") ||
          subNorm.startsWith("dead") ||
          subNorm.startsWith("inactive")
        ) {
          return { cls: "svc-state-warn", text: t("services.status_inactive") };
        }
        if (
          activeNorm.includes("deactivat") ||
          activeNorm.includes("stopping") ||
          subNorm.includes("stopping")
        ) {
          return { cls: "svc-state-warn", text: t("services.status_stopping") };
        }
        if (
          activeNorm.startsWith("activating") ||
          activeNorm.includes("start") ||
          subNorm.includes("start")
        ) {
          return { cls: "svc-state-warn", text: t("services.status_starting") };
        }
        if (
          activeNorm === "active" &&
          (!subNorm || subNorm === "running" || subNorm === "listening")
        ) {
          return { cls: "svc-state-ok", text: t("services.status_active") };
        }
        if (activeNorm.includes("active")) {
          return { cls: "svc-state-ok", text: t("services.status_active") };
        }
        return { cls: "svc-state-unknown", text: t("services.status_unknown") };
      }

      function describeAutostart(rawValue, loadState) {
        const normalized = normalizeSvcValue(rawValue);
        if (!normalized) {
          return { cls: "svc-state-unknown", text: t("services.autostart_unknown") };
        }
        if (normalized.startsWith("enabled")) {
          return { cls: "svc-state-ok", text: t("services.autostart_enabled") };
        }
        if (normalized.startsWith("disabled")) {
          return { cls: "svc-state-warn", text: t("services.autostart_disabled") };
        }
        if (normalized.startsWith("masked")) {
          return { cls: "svc-state-err", text: t("services.autostart_masked") };
        }
        return { cls: "svc-state-unknown", text: rawValue || t("services.autostart_unknown") };
      }

      services.forEach((svc) => {
        const unit = svc.unit || svc.name || svc.id || "n/a";
        const desc = svc.desc || svc.description || "-";
        const activeRaw =
          svc.active ||
          svc.ActiveState ||
          svc.state ||
          svc.status ||
          "";
        const subRaw = svc.sub || svc.SubState || "";
        const enabledRaw =
          (typeof svc.enabled === "boolean"
            ? svc.enabled
              ? "enabled"
              : "disabled"
            : null) ||
          svc.enabled ||
          svc.autostart ||
          svc.UnitFileState ||
          "";
        const loadRaw = svc.load || svc.LoadState || "";
        const statusMeta = describeStatus(activeRaw, subRaw);
        const autostartMeta = describeAutostart(enabledRaw, loadRaw);
        const activeLabel =
          statusMeta.text +
          (subRaw &&
          !["running", "dead", "listening", ""].includes(
            normalizeSvcValue(subRaw),
          )
            ? ` (${subRaw})`
            : "");
        const stateAttr = statusMeta.cls.replace("svc-state-", "") || "unknown";

        svcCache.set(unit, {
          unit,
          description: desc,
          active: activeRaw,
          enabled: enabledRaw,
        });

        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td>${unit}</td>
          <td>${desc}</td>
          <td><span class="svc-state ${statusMeta.cls}">${activeLabel}</span></td>
          <td><span class="svc-state ${autostartMeta.cls}">${autostartMeta.text}</span></td>
          <td class="svc-actions">
            <button class="c-btn c-btn-sm" data-unit="${unit}" data-action="start" title="${t("services.btn_start")}">‚ñ∂</button>
            <button class="c-btn c-btn-sm" data-unit="${unit}" data-action="stop" title="${t("services.btn_stop")}">‚ñ†</button>
            <button class="c-btn c-btn-sm" data-unit="${unit}" data-action="restart" title="${t("services.btn_restart")}">‚Üª</button>
            <button class="c-btn c-btn-sm" data-unit="${unit}" data-action="enable" title="${t("services.btn_enable")}">Ôºã</button>
            <button class="c-btn c-btn-sm" data-unit="${unit}" data-action="disable" title="${t("services.btn_disable")}">Ôºç</button>
          </td>
        `;
        tr.dataset.state = stateAttr;
        tbody.appendChild(tr);
      });

      table.hidden = false;
      const stamp = new Date().toLocaleTimeString();
      info.textContent = `${t("services.loaded_at", { ts: stamp })}`;
      if (ts) {
        ts.textContent = `(${stamp})`;
      }
      applySvcFilter();
    } catch (e) {
      appendLog(
        `/svc fetch failed :: ${e.message || e}`,
        "err",
      );
    }
  }

  async function svcAction(unit, action) {
    try {
      const res = await httpPost(`/svc/${encodeURIComponent(unit)}`, { action });
      appendLog(
        `[svc] ${unit} ${action} :: ${JSON.stringify(res)}`,
        res.ok ? "ok" : "err",
      );
      await fetchServices();
      return res;
    } catch (e) {
      appendLog(
        `[svc] ${unit} ${action} :: ${e.message || e}`,
        "err",
      );
    }
  }

  function applySvcFilter() {
    const rows = document.querySelectorAll("#svcBody tr");
    rows.forEach((tr) => {
      const state = tr.dataset.state || "unknown";
      const visible =
        svcFilterMode === "all" ||
        state === svcFilterMode ||
        (svcFilterMode === "warn" && state === "unknown");
      tr.hidden = !visible;
    });
  }

  async function flushMotionQueue(reason = "manual-ui") {
    try {
      await apiControl({ cmd: "stop", reason, clear: true });
      await fetchMotionQueue();
      appendLog(
        `[motion queue] flushed (${reason})`,
        "ok",
      );
    } catch (e) {
      appendLog(
        `[motion queue] flush failed :: ${e.message || e}`,
        "warn",
      );
    }
  }

  qs("#svcRefresh")?.addEventListener("click", () => {
    fetchServices();
  });
  const svcAutoRefreshToggle = qs("#svcAutoRefresh");
  if (svcAutoRefreshToggle) {
    svcAutoRefreshToggle.addEventListener("change", () => {
      const enabled = !!svcAutoRefreshToggle.checked;
      if (svcRefreshTimer) {
        clearInterval(svcRefreshTimer);
        svcRefreshTimer = null;
      }
      if (enabled) {
        svcRefreshTimer = setInterval(() => {
          fetchServices().catch(() => {});
        }, 5000);
      }
    });
  }
  const svcFilterSel = qs("#svcFilter");
  if (svcFilterSel) {
    svcFilterSel.addEventListener("change", () => {
      svcFilterMode = svcFilterSel.value || "all";
      applySvcFilter();
    });
  }
  qs("#svcTable")?.addEventListener("click", (ev) => {
    const btn = ev.target.closest("button[data-unit][data-action]");
    if (!btn) return;
    const unit = btn.getAttribute("data-unit");
    const action = btn.getAttribute("data-action");
    svcAction(unit, action);
  });

  // === AI MODE (UI) ===
  async function fetchAiModeStatus() {
    try {
      const j = await fetchJson(AI_MODE_ENDPOINT);
      const badge = qs("#aiModeCurrentBadge");
      const status = qs("#aiModeStatus");
      const ts = qs("#aiModeChangedTime");
      if (badge) {
        badge.classList.remove("warn", "ok");
        badge.classList.add("ok");
        badge.textContent = j.mode === "pc_offload" ? "PC Offload" : "Local";
      }
      if (status) {
        status.textContent = t("ai_mode.status_ok");
        status.className = "muted";
      }
      if (ts && j.ts) {
        ts.textContent = new Date(j.ts * 1000).toLocaleTimeString();
      }
    } catch (e) {
      appendLog(
        `/api/ai-mode :: ${e.message || e}`,
        "warn",
      );
    }
  }

  async function setAiMode(mode) {
    try {
      await sendJson(AI_MODE_ENDPOINT, { mode }, "PUT");
      appendLog(`[ai_mode] set ${mode}`, "ok");
      await fetchAiModeStatus();
    } catch (e) {
      appendLog(
        `[ai_mode] set ${mode} :: ${e.message || e}`,
        "err",
      );
    }
  }

  qs("#btnAiModeLocal")?.addEventListener("click", () => {
    setAiMode("local");
  });
  qs("#btnAiModeOffload")?.addEventListener("click", () => {
    setAiMode("pc_offload");
  });

  // === PROVIDER CONTROL ===
  function providerModeLabel(mode) {
    return mode === "pc" ? t("provider.mode_pc") : t("provider.mode_local");
  }

  function providerStatusLabel(status) {
    if (!status) {
      return t("provider.status_unknown");
    }
    const key = `provider.status_${status}`;
    const text = t(key);
    return typeof text === "string" && text !== key ? text : `${t("provider.status_unknown")} (${status})`;
  }

  function formatChangedTs(ts) {
    if (!ts || Number.isNaN(Number(ts))) {
      return t("provider.changed_unknown");
    }
    const epochMs = Number(ts) * 1000;
    if (!Number.isFinite(epochMs)) {
      return t("provider.changed_unknown");
    }
    return new Date(epochMs).toLocaleTimeString();
  }

  function updateProviderPcBadge(health = {}) {
    const badge = qs("#providerPcStatus");
    if (!badge) return;
    const reachable = !!health.reachable;
    let cls = "warn";
    let key = "provider.pc_status_unknown";
    if (reachable) {
      cls = "ok";
      key = "provider.pc_status_online";
    } else if (health.status === "offline") {
      cls = "err";
      key = "provider.pc_status_offline";
    } else if (health.reason === "not_initialized") {
      cls = "warn";
      key = "provider.pc_status_pending";
    }
    badge.className = `c-pill ${cls}`;
    const latency = typeof health.latency_ms === "number" ? ` (${Math.round(health.latency_ms)} ms)` : "";
    badge.textContent = `${t(key)}${latency}`;
  }

  function renderProviderDomain(domain, state = {}) {
    const row = document.querySelector(`.provider-row[data-provider="${domain}"]`);
    if (!row) return;
    const pill = row.querySelector("[data-provider-pill]");
    if (pill) {
      pill.textContent = providerModeLabel(state.mode);
      pill.className = `c-pill provider-pill ${state.mode === "pc" ? "warn" : "ok"}`;
    }
    const statusEl = row.querySelector("[data-provider-status]");
    if (statusEl) {
      const label = providerStatusLabel(state.status);
      const reason = state.reason ? ` (${state.reason})` : "";
      statusEl.textContent = `${label}${reason}`;
    }
    const changedEl = row.querySelector("[data-provider-changed]");
    if (changedEl) {
      changedEl.textContent = formatChangedTs(state.changed_ts);
    }
  }

  async function fetchProviderState() {
    try {
      const data = await fetchJson(PROVIDER_STATE_ENDPOINT);
      const domains = data.domains || {};
      PROVIDER_DOMAINS.forEach((domain) => {
        renderProviderDomain(domain, domains[domain] || {});
      });
      updateProviderPcBadge(data.pc_health);
    } catch (e) {
      appendLog(`[provider] fetch :: ${e.message || e}`, "warn");
    }
  }

  async function setProviderMode(domain, target) {
    try {
      await sendJson(`/api/providers/${domain}`, { target }, "PATCH");
      appendLog(`[provider] ${domain} ‚Üí ${target}`, "ok");
      await fetchProviderState();
    } catch (e) {
      appendLog(
        `[provider] ${domain} ‚Üí ${target} :: ${e.message || e}`,
        "err",
      );
    }
  }

  document.querySelectorAll("[data-provider-action]").forEach((btn) => {
    btn.addEventListener("click", () => {
      const domain = btn.getAttribute("data-provider-domain");
      const target = btn.getAttribute("data-provider-action");
      if (!domain || !target) return;
      setProviderMode(domain, target);
    });
  });

  // Balance + height UI
  const balanceToggle = qs("#balanceToggle");
  const heightSlider = qs("#heightSlider");
  const heightValue = qs("#heightValue");

  function syncHeightValue(nextValue) {
    if (heightSlider) heightSlider.value = String(nextValue);
    if (heightValue) heightValue.textContent = String(nextValue);
  }

  // sendBalance ‚Äì funkcja wymagana przez testy + realny POST do backendu
  function sendBalance(nextValue) {
    const enabled =
      typeof nextValue === "boolean"
        ? nextValue
        : !!(balanceToggle && balanceToggle.checked);
    if (balanceToggle) balanceToggle.checked = enabled;
    appendLog(
      `[balance] toggle=${enabled ? "on" : "off"}`,
      "ok",
    );
    httpPost("/api/control/balance", { enabled }).catch(() => {});
  }

  function sendHeight(nextHeight) {
    const heightRaw =
      typeof nextHeight === "number"
        ? nextHeight
        : heightSlider
          ? Number(heightSlider.value) || 0
          : 0;
    const height = clamp(heightRaw, 0, 12);
    syncHeightValue(height);
    appendLog(
      `[height] set=${height}`,
      "ok",
    );
    httpPost("/api/control/height", { height }).catch(() => {});
  }

  if (heightSlider && heightValue) {
    syncHeightValue(Number(heightSlider.value) || 0);
    let debounce;
    const updateValue = () => {
      syncHeightValue(Number(heightSlider.value) || 0);
    };
    heightSlider.addEventListener("input", () => {
      updateValue();
      clearTimeout(debounce);
      debounce = setTimeout(() => {
        sendHeight();
      }, 120);
    });
    heightSlider.addEventListener("change", () => {
      updateValue();
      sendHeight();
    });
  }

  if (balanceToggle) {
    balanceToggle.addEventListener("change", (ev) => {
      const enabled = !!ev.target.checked;
      sendBalance(enabled);
    });
  }

  // === RESOURCES DIAG ===
  async function updateResourceRow(resName) {
    const tr = document.querySelector(`tr[data-res="${resName}"]`);
    if (!tr) return;
    const statusEl = tr.querySelector(".res-status");
    const holdersEl = tr.querySelector(".res-holders");
    if (statusEl) statusEl.textContent = t("meta.loading");
    try {
      const data = await fetchJson(`/api/resource/${encodeURIComponent(resName)}`);
      const free = !!data.free;
      if (statusEl) {
        statusEl.textContent = data.error
          ? `${t("resources.status_error")}: ${data.error}`
          : free
            ? t("resources.status_free")
            : t("resources.status_busy");
      }
      if (holdersEl) {
        const holders = (data.holders || []).map((holder) => {
          const svc = holder.service ? ` [${holder.service}]` : "";
          return `${holder.cmd || holder.pid || "pid"} (${holder.pid || "?"})${svc}`;
        });
        holdersEl.textContent = holders.length ? holders.join(", ") : t("resources.holders_none");
      }
    } catch (e) {
      if (statusEl) statusEl.textContent = e.message || String(e);
      if (holdersEl) holdersEl.textContent = "-";
    }
  }

  async function fetchResources() {
    try {
      const rows = Array.from(document.querySelectorAll("tr[data-res]"));
      await Promise.all(rows.map((tr) => updateResourceRow(tr.getAttribute("data-res"))));
      const info = qs("#resInfo");
      if (info) {
        info.textContent = t("resources.last_update", {
          time: new Date().toLocaleTimeString(),
        });
      }
    } catch (e) {
      appendLog(`/api/resource :: ${e.message || e}`, "warn");
    }
  }

  qs("#resTable")?.addEventListener("click", (ev) => {
    const btn = ev.target.closest("button[data-res][data-res-action]");
    if (!btn) return;
    const res = btn.getAttribute("data-res");
    const action = btn.getAttribute("data-res-action");
    if (action === "refresh") {
      updateResourceRow(res);
      return;
    }
    httpPost(`/api/resource/${encodeURIComponent(res)}`, { action })
      .then(() => updateResourceRow(res))
      .catch((err) => {
        appendLog(`[resource ${res}] ${action} :: ${err.message || err}`, "warn");
      });
  });

  // === MOTION QUEUE (tylko UI) ===
  async function fetchMotionQueue() {
    try {
      const j = await fetchJson("/api/motion/queue");
      const info = qs("#motionQueueInfo");
      const body = qs("#motionQueueBody");
      if (!info || !body) return;
      body.innerHTML = "";
      const items = Array.isArray(j.items) ? j.items : [];
      if (!items.length) {
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td colspan="7" class="muted" data-i18n="motion_queue.empty_placeholder">
            Brak zlece≈Ñ ruchu.
          </td>`;
        body.appendChild(tr);
      } else {
        items.slice(0, 10).forEach((item) => {
          const statusNote = item.reason
            ? `<div class="muted">${item.reason}</div>`
            : "";
          const tr = document.createElement("tr");
          tr.innerHTML = `
            <td>${item.source || "-"}</td>
            <td>${item.vx ?? "-"}</td>
            <td>${item.vy ?? "-"}</td>
            <td>${item.yaw ?? "-"}</td>
            <td>${item.time_s ?? "-"}</td>
            <td>${item.status || "-"}${statusNote}</td>
            <td>${item.age_s ?? "-"}</td>
          `;
          body.appendChild(tr);
        });
      }
      info.textContent = t("motion_queue.last_update", {
        time: j.generated_at
          ? new Date(j.generated_at * 1000).toLocaleTimeString()
          : new Date().toLocaleTimeString(),
      });
    } catch (e) {
      appendLog(
        `/api/motion/queue :: ${e.message || e}`,
        "warn",
      );
    }
  }

  qs("#btnMotionQueueFlush")?.addEventListener("click", () => {
    flushMotionQueue("manual-ui");
  });

  // === CAMERA PREVIEW SWITCH ===
  const camPrev = qs("#camPrev");
  const camInfo = qs("#camInfo");
  const camToggle = qs("#camToggle");
  const btnUseEdge = qs("#btnUseEdge");
  const btnUseCam = qs("#btnUseCam");
  let camAuto = true;
  let camSource = "cam";

  function updateCamSrc() {
    if (!camPrev) return;
    const ts = Date.now();
    const base =
      camSource === "edge"
        ? "/vision/edge.jpg"
        : "/camera/last";
    camPrev.src = `${base}?ts=${ts}`;
    if (camInfo) {
      camInfo.textContent = `last: ${new Date().toLocaleTimeString()} ¬∑ source: ${camSource}`;
    }
  }

  btnUseEdge?.addEventListener("click", () => {
    camSource = "edge";
    updateCamSrc();
  });
  btnUseCam?.addEventListener("click", () => {
    camSource = "cam";
    updateCamSrc();
  });

  camToggle?.addEventListener("click", () => {
    camAuto = !camAuto;
    camToggle.textContent = camAuto
      ? t("camera.auto_refresh_on")
      : t("camera.auto_refresh_off");
  });

  setInterval(() => {
    if (camAuto) updateCamSrc();
  }, 1000);

  setInterval(() => {
    fetchProviderState().catch(() => {});
  }, 7000);
  setInterval(() => {
    refreshScenarioList(true).catch(() => {});
  }, 5000);

  // === SSE EVENTS ===
  try {
    const es = new EventSource("/events");
    es.onmessage = (ev) => {
      appendLog(ev.data || String(ev), "muted");
    };
    es.onerror = () => {
      appendLog("SSE: error, reconnecting‚Ä¶", "warn");
      es.close();
      setTimeout(() => {
        location.reload();
      }, 10000);
    };
  } catch (e) {
    appendLog(`SSE init failed :: ${e.message || e}`, "warn");
  }

  // initial loads
  fetchServices().catch(() => {});
  fetchResources().catch(() => {});
  fetchAiModeStatus().catch(() => {});
  fetchProviderState().catch(() => {});
  fetchControlState().catch(() => {});
  fetchMotionQueue().catch(() => {});
  refreshScenarioList().catch(() => {});
</script>
</body>
</html>
