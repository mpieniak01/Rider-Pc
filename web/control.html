<!doctype html>
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Rider-PC ‚Äî Sterowanie ruchem (REST /api)</title>
  <link rel="stylesheet" href="/web/assets/dashboard-common.css" />
  <link rel="stylesheet" href="/web/assets/control.css" />

</head>
<body data-page="control">
<div data-dashboard-menu-target></div>
<div class="wrap">

  <h1 class="control-title page-title" data-i18n="meta.app_title">
    Rider-PC ‚Äî Sterowanie ruchem (REST /api)
    <span
      id="apiStatus"
      class="muted control-status"
      data-i18n="header.api_status_checking"
    >(checking‚Ä¶)</span>
    <span
      id="obstBadge"
      class="c-pill warn control-badge"
      hidden
      data-i18n="header.obstacle_na"
    >Obstacle: n/a</span>
  </h1>

  <div class="panel-row l-row">
    <!-- 1) KAMERA -->
    <div class="c-card cam-card">
      <h2 class="c-card__title" data-i18n="camera.title">PodglƒÖd kamery</h2>

      <div class="cam-actions">
        <button id="camToggle" class="c-btn c-btn-sm" data-i18n="camera.auto_refresh_on">
          ‚ü≥ Auto-refresh (on)
        </button>
        <button id="btnUseEdge" class="c-btn c-btn-sm" data-i18n="camera.use_edge">Use EDGE</button>
        <button id="btnUseCam" class="c-btn c-btn-sm" data-i18n="camera.use_cam">Use CAM</button>
      </div>

      <div class="cam-frame">
        <div>
          <img id="camPrev" class="cam" alt="camera preview" src="/camera/last?ts=0" />
          <div
            class="c-note cam-info"
            id="camInfo"
            data-i18n="camera.last_frame_na"
          >last frame: n/a ¬∑ source: n/a</div>
        </div>
      </div>
    </div>

    <!-- 2) STEROWANIE -->
    <div class="c-card control-card">
      <h2 class="c-card__title" data-i18n="motion.title">Sterowanie ruchem</h2>

      <div class="l-row control-range-row">
        <label>
          <span data-i18n="motion.turning_speed">Prƒôdko≈õƒá skrƒôtu</span>
          <span class="muted" data-i18n="motion.turning_range">(0..1)</span>:
          <input id="speedSpin" type="range" min="0" max="1" step="0.02" value="0.18" />
          <span id="speedSpinVal">0.18</span>
        </label>
        <label>
          <span data-i18n="motion.max_speed">Prƒôdko≈õƒá maksymalna</span>
          <span class="muted" data-i18n="motion.max_speed_range">(0..1)</span>:
          <input id="speedMax" type="range" min="0" max="1" step="0.05" value="0.10" />
          <span id="speedMaxVal">0.10</span>
        </label>
        <label>
          <span data-i18n="motion.pulse_time">Czas impulsu [s]</span>:
          <input id="durationSpin" type="number" min="0.05" step="0.05" value="0.10" />
        </label>
        <div class="u-spacer"></div>
        <button id="btnStop" class="c-btn motion-btn" data-i18n="motion.btn_stop">‚ñ† STOP</button>
      </div>

      <div class="motion-grid">
        <div></div>
        <button id="btnFwd" class="c-btn motion-btn" data-i18n="motion.btn_forward">‚Üë Forward</button>
        <div></div>
        <button id="btnLeft" class="c-btn motion-btn" data-i18n="motion.btn_left">‚Üê Left</button>
        <button id="btnStop2" class="c-btn motion-btn" data-i18n="motion.btn_stop_small">‚ñ† Stop</button>
        <button id="btnRight" class="c-btn motion-btn" data-i18n="motion.btn_right">Right ‚Üí</button>
        <div></div>
        <button id="btnBack" class="c-btn motion-btn" data-i18n="motion.btn_backward">‚Üì Backward</button>
        <div></div>
      </div>

      <div class="l-row">
        <span class="muted">
          <span data-i18n="motion.shortcuts_hint">Skr√≥ty</span>:
          <span class="kbd">W/S/A/D</span>
          <span data-i18n="motion.shortcuts_tail">lub strza≈Çki; Spacja = stop.</span>
        </span>
        <div class="u-spacer"></div>
      </div>

      <div class="balance-control-row">
        <div class="balance-control">
          <label for="balanceToggle">
            <span data-i18n="balance.toggle_label">Balans (stabilizacja)</span>
            <input id="balanceToggle" type="checkbox" />
          </label>
        </div>
        <div class="balance-control">
          <label for="heightSlider">
            <span data-i18n="balance.height_label">Wysoko≈õƒá</span>
            <input
              id="heightSlider"
              type="range"
              min="0"
              max="12"
              step="1"
              value="6"
            />
            <span id="heightValue">6</span>
          </label>
        </div>
      </div>
    </div>
  </div>

  <!-- FUNKCJE + ZASOBY -->
  <div class="panel-row feature-resource">
    <div class="c-card feature-card">
      <h2 class="c-card__title" data-i18n="motion.features_title">Funkcje</h2>
      <div class="feature-list" id="featureList">
        <div class="feature-row" data-feature="face">
          <div class="feature-info">
            <div class="feature-head">
              <div
                class="feature-title"
                data-i18n="motion.follow_face"
              >≈öled≈∫ Twarz (Follow Face)</div>
            </div>
            <div
              class="feature-desc"
              data-i18n="motion.feature_face_desc"
            >Uruchamia tracker i kontroler ruchu oraz ≈õledzi twarz.</div>
          </div>
          <div class="feature-status">
            <span class="c-pill feature-pill" data-feature-pill="face">n/a</span>
          </div>
          <div class="feature-actions">
            <button
              class="c-btn c-btn-sm"
              data-feature-action="start"
              data-i18n="motion.feature_btn_start"
            >Start</button>
            <button
              class="c-btn c-btn-sm"
              data-feature-action="stop"
              data-i18n="motion.feature_btn_stop"
            >Stop</button>
            <div class="feature-note" data-feature-note="face"></div>
          </div>
        </div>

        <div class="feature-row" data-feature="hand">
          <div class="feature-info">
            <div class="feature-head">
              <div
                class="feature-title"
                data-i18n="motion.follow_hand"
              >≈öled≈∫ D≈Ço≈Ñ (Follow Hand)</div>
            </div>
            <div
              class="feature-desc"
              data-i18n="motion.feature_hand_desc"
            >Te same us≈Çugi tracker+controller, ale z trybem d≈Çoni.</div>
          </div>
          <div class="feature-status">
            <span class="c-pill feature-pill" data-feature-pill="hand">n/a</span>
          </div>
          <div class="feature-actions">
            <button
              class="c-btn c-btn-sm"
              data-feature-action="start"
              data-i18n="motion.feature_btn_start"
            >Start</button>
            <button
              class="c-btn c-btn-sm"
              data-feature-action="stop"
              data-i18n="motion.feature_btn_stop"
            >Stop</button>
            <div class="feature-note" data-feature-note="hand"></div>
          </div>
        </div>

        <div class="feature-row" data-feature="recon">
          <div class="feature-info">
            <div class="feature-head">
              <div
                class="feature-title"
                data-i18n="motion.recon_mode"
              >Tryb Rekonesans (autonomiczny)</div>
            </div>
            <div
              class="feature-desc"
              data-i18n="motion.feature_recon_desc"
            >W≈ÇƒÖcza odometriƒô, mapper oraz startuje navigatora.</div>
            <div class="feature-select">
              <span data-i18n="motion.recon_strategy">Strategia</span>:
              <select id="reconStrategy">
                <option value="STOP">STOP (zatrzymaj)</option>
                <option value="AVOID">AVOID (omijaj)</option>
              </select>
            </div>
          </div>
          <div class="feature-status">
            <span class="c-pill feature-pill" data-feature-pill="recon">n/a</span>
          </div>
          <div class="feature-actions">
            <button
              class="c-btn c-btn-sm"
              data-feature-action="start"
              data-i18n="motion.feature_btn_start"
            >Start</button>
            <button
              class="c-btn c-btn-sm"
              data-feature-action="stop"
              data-i18n="motion.feature_btn_stop"
            >Stop</button>
            <button
              class="c-btn c-btn-sm"
              id="btnReturnHome"
              data-feature-action="return-home"
              data-i18n="motion.return_home"
            >üè† Powr√≥t do Bazy</button>
            <div class="feature-note" data-feature-note="recon"></div>
          </div>
        </div>
      </div>
    </div>

    <div class="c-card resource-card">
      <h2 class="c-card__title" data-i18n="resources.title">Diagnostyka zasob√≥w</h2>
      <div id="resInfo" class="muted" data-i18n="meta.loading">≈Åadowanie‚Ä¶</div>
      <table class="svc-table" id="resTable">
        <thead>
        <tr>
          <th data-i18n="resources.column_name">Zas√≥b</th>
          <th data-i18n="resources.column_status">Status</th>
          <th data-i18n="resources.column_holders">BlokujƒÖce procesy</th>
          <th data-i18n="resources.column_actions">Akcje</th>
        </tr>
        </thead>
        <tbody id="resBody">
        <tr data-res="mic">
          <td data-i18n="resources.mic">Mikrofon</td>
          <td class="res-status">n/a</td>
          <td class="res-holders">-</td>
          <td class="svc-actions">
            <button class="c-btn c-btn-sm" data-res="mic" data-res-action="refresh">‚ü≥</button>
            <button
              class="c-btn c-btn-sm"
              data-res="mic"
              data-res-action="stop"
              data-i18n="resources.btn_stop_service"
            >Stop us≈Çugi</button>
            <button
              class="c-btn c-btn-sm"
              data-res="mic"
              data-res-action="release"
              data-i18n="resources.btn_release"
            >Zwolnij</button>
          </td>
        </tr>
        <tr data-res="speaker">
          <td data-i18n="resources.speaker">G≈Ço≈õnik</td>
          <td class="res-status">n/a</td>
          <td class="res-holders">-</td>
          <td class="svc-actions">
            <button class="c-btn c-btn-sm" data-res="speaker" data-res-action="refresh">‚ü≥</button>
            <button
              class="c-btn c-btn-sm"
              data-res="speaker"
              data-res-action="stop"
              data-i18n="resources.btn_stop_service"
            >Stop us≈Çugi</button>
            <button
              class="c-btn c-btn-sm"
              data-res="speaker"
              data-res-action="release"
              data-i18n="resources.btn_release"
            >Zwolnij</button>
          </td>
        </tr>
        <tr data-res="camera">
          <td data-i18n="resources.camera">Kamera</td>
          <td class="res-status">n/a</td>
          <td class="res-holders">-</td>
          <td class="svc-actions">
            <button class="c-btn c-btn-sm" data-res="camera" data-res-action="refresh">‚ü≥</button>
            <button
              class="c-btn c-btn-sm"
              data-res="camera"
              data-res-action="stop"
              data-i18n="resources.btn_stop_service"
            >Stop us≈Çugi</button>
            <button
              class="c-btn c-btn-sm"
              data-res="camera"
              data-res-action="release"
              data-i18n="resources.btn_release"
            >Zwolnij</button>
          </td>
        </tr>
        <tr data-res="lcd">
          <td data-i18n="resources.lcd">Ekran LCD 2"</td>
          <td class="res-status">n/a</td>
          <td class="res-holders">-</td>
          <td class="svc-actions">
            <button class="c-btn c-btn-sm" data-res="lcd" data-res-action="refresh">‚ü≥</button>
            <button
              class="c-btn c-btn-sm"
              data-res="lcd"
              data-res-action="stop"
              data-i18n="resources.btn_stop_service"
            >Stop us≈Çugi</button>
            <button
              class="c-btn c-btn-sm"
              data-res="lcd"
              data-res-action="release"
              data-i18n="resources.btn_release"
            >Zwolnij</button>
          </td>
        </tr>
        </tbody>
      </table>
    </div>
  </div>
  <div class="c-card service-card">
    <h2 class="c-card__title">
      <span data-i18n="services.title">Us≈Çugi (systemd)</span>
      <button
        id="svcRefresh"
        class="c-btn c-btn-sm section-action"
        data-i18n="services.refresh"
      >‚ü≥ od≈õwie≈º</button>
    </h2>
    <div id="svcInfo" class="muted">
      <span data-i18n="meta.loading">≈Åadowanie‚Ä¶</span>
      <span id="svcTs"></span>
    </div>
    <table class="svc-table" id="svcTable" hidden>
      <thead>
      <tr>
        <th data-i18n="services.unit">Unit</th>
        <th data-i18n="services.desc">Opis</th>
        <th data-i18n="services.status">Status</th>
        <th data-i18n="services.autostart">Autostart</th>
        <th data-i18n="services.actions">Akcje</th>
      </tr>
      </thead>
      <tbody id="svcBody"></tbody>
    </table>
  </div>

  <!-- LOG -->
  <div class="c-card log-card">
    <h2 class="c-card__title" data-i18n="events.title">Zdarzenia (SSE /events)</h2>
    <div id="log"></div>
  </div>

  <div class="c-card motion-queue-card">
    <h2 class="c-card__title">
      <span data-i18n="motion_queue.title">Kolejka ruchu</span>
      <button
        id="btnMotionQueueFlush"
        class="c-btn c-btn-sm section-action"
        data-i18n="motion_queue.btn_flush"
      >‚èπ stop &amp; wyczy≈õƒá</button>
    </h2>
    <div id="motionQueueInfo" class="muted" data-i18n="motion_queue.loading">
      Brak danych‚Ä¶
    </div>
    <table class="svc-table" id="motionQueueTable">
      <thead>
      <tr>
        <th data-i18n="motion_queue.column_source">≈πr√≥d≈Ço</th>
        <th data-i18n="motion_queue.column_vx">Vx</th>
        <th data-i18n="motion_queue.column_vy">Vy</th>
        <th data-i18n="motion_queue.column_yaw">Yaw</th>
        <th data-i18n="motion_queue.column_time">Czas [s]</th>
        <th data-i18n="motion_queue.column_status">Status</th>
        <th data-i18n="motion_queue.column_age">Wiek</th>
      </tr>
      </thead>
      <tbody id="motionQueueBody">
      <tr>
        <td
          colspan="7"
          class="muted"
          data-i18n="motion_queue.empty_placeholder"
        >Brak zlece≈Ñ ruchu.</td>
      </tr>
      </tbody>
    </table>
  </div>
</div>

<script type="module" src="/web/assets/menu.js"></script>
<script type="module">
  import { initI18n, applyDom, t } from "/web/assets/i18n.js";

  // --- i18n init ---
  const urlLang = new URLSearchParams(location.search).get("lang");
  const saved = localStorage.getItem("lang");
  const browser = (navigator.language || "").slice(0, 2).toLowerCase();
  const pick = (v) =>
    v && v.toLowerCase().startsWith("en")
      ? "en"
      : v && v.toLowerCase().startsWith("pl")
        ? "pl"
        : null;
  const lang = pick(urlLang) || pick(saved) || pick(browser) || "pl";
  if (urlLang) {
    localStorage.setItem("lang", lang);
  }

  async function fetchControlState() {
    try {
      const j = await fetchJson("/api/control/state");
      const balance = j.balance || {};
      if (balanceToggle && typeof balance.enabled === "boolean") {
        balanceToggle.checked = !!balance.enabled;
      }
      const heightState = j.height || {};
      if (typeof heightState.value === "number") {
        syncHeightValue(heightState.value);
      }

      const tracking = j.tracking || {};
      const trackingMode = (tracking.mode || "none").toLowerCase();
      const trackingEnabled = !!tracking.enabled;
      const faceRunning = trackingEnabled && trackingMode === "face";
      const handRunning = trackingEnabled && trackingMode === "hand";
      setFeatureStatus(
        "face",
        faceRunning ? "running" : "stopped",
        faceRunning ? t("motion.feature_note_mode", { mode: "face" }) : "",
      );
      setFeatureStatus(
        "hand",
        handRunning ? "running" : "stopped",
        handRunning ? t("motion.feature_note_mode", { mode: "hand" }) : "",
      );

      const navigator = j.navigator || {};
      const reconRunning = !!navigator.active;
      const reconNote = navigator.state
        ? t("motion.feature_note_state", { state: navigator.state })
        : "";
      setFeatureStatus(
        "recon",
        reconRunning ? "running" : "stopped",
        reconRunning ? reconNote : "",
      );
    } catch (e) {
      appendLog(
        `/api/control/state :: ${e.message || e}`,
        "warn",
      );
    }
  }
  await initI18n(lang);
  applyDom();
  document.documentElement.setAttribute("lang", lang);
  document.title = t("meta.app_title");

  // ====== helpers ======
  const qs = (s) => document.querySelector(s);
  const logEl = qs("#log");
  const MAX_ERR_SNIPPET = 140;

  function formatHttpError(status, statusText, raw) {
    const txt = (raw || "").trim();
    if (!txt) {
      return `HTTP ${status} :: ${statusText || "error"}`;
    }
    const stripped = txt.replace(/<[^>]*>/g, " ").replace(/\s+/g, " ").trim();
    const preview = stripped || statusText || "error";
    return `HTTP ${status} :: ${preview.slice(0, MAX_ERR_SNIPPET)}`;
  }

  function appendLog(msg, cls = "") {
    if (!logEl) return;
    const line = document.createElement("div");
    if (cls) line.className = cls;
    line.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
    logEl.appendChild(line);
    logEl.scrollTop = logEl.scrollHeight;
  }

  window.addEventListener("error", (e) =>
    appendLog(
      `${t("events.log_js_err", { msg: e.message || e })}`,
      "err",
    ),
  );
  window.addEventListener("unhandledrejection", (e) =>
    appendLog(
      `${t("events.log_prom_err", { reason: e.reason || e })}`,
      "err",
    ),
  );

  const LIN_V_DEFAULT = 0.1;
  const LIN_T = 0.1;
  let linV = LIN_V_DEFAULT;
  function clamp(n, lo, hi) {
    n = Number(n) || 0;
    return Math.max(lo, Math.min(hi, n));
  }
  const spinEl = qs("#speedSpin");
  const spinVal = qs("#speedSpinVal");
  const speedMaxEl = qs("#speedMax");
  const speedMaxVal = qs("#speedMaxVal");
  const durSpinEl = qs("#durationSpin");

  if (spinEl && spinVal) {
    spinEl.addEventListener("input", () => {
      spinVal.textContent = Number(spinEl.value).toFixed(2);
    });
  }

  function updateLinearSpeed() {
    if (!speedMaxEl || !speedMaxVal) {
      linV = LIN_V_DEFAULT;
      return;
    }
    const val = clamp(speedMaxEl.value, 0, 1);
    linV = val;
    speedMaxVal.textContent = val.toFixed(2);
  }

  if (speedMaxEl) {
    updateLinearSpeed();
    speedMaxEl.addEventListener("input", updateLinearSpeed);
  }

  async function pingHealth() {
    try {
      const r = await fetch("/healthz", { cache: "no-store" });
      const j = await r.json().catch(() => ({}));
      const apiStatus = qs("#apiStatus");
      if (!apiStatus) return;
      const ok = !!j.ok;
      apiStatus.textContent = ok
        ? t("header.api_status_ok")
        : t("header.api_status_degraded");
      apiStatus.className = ok ? "ok" : "warn";
    } catch {
      const apiStatus = qs("#apiStatus");
      if (!apiStatus) return;
      apiStatus.textContent = t("header.api_status_down");
      apiStatus.className = "err";
    }
  }

  setInterval(pingHealth, 1000);
  pingHealth();

  const AI_MODE_ENDPOINT = "/api/system/ai-mode";
  const PROVIDER_STATE_ENDPOINT = "/api/providers/state";
  const PROVIDER_DOMAINS = ["vision", "voice", "text"];

  async function sendJson(url, body, method = "POST") {
    const r = await fetch(url, {
      method,
      headers: { "Content-Type": "application/json" },
      body: body ? JSON.stringify(body) : undefined,
      cache: "no-store",
    });
    const raw = await r.text();
    let j = null;
    try {
      j = raw ? JSON.parse(raw) : {};
    } catch {
      /* ignore */
    }
    if (!r.ok) {
      const snippet =
        (j && (j.error || j.stderr || j.stdout)) ||
        formatHttpError(r.status, r.statusText, raw);
      throw new Error(snippet);
    }
    if (!j) {
      throw new Error(`HTTP ${r.status}: invalid JSON`);
    }
    return j;
  }

  async function httpPost(url, body) {
    return sendJson(url, body, "POST");
  }

  async function fetchJson(url, options = {}) {
    const r = await fetch(url, { cache: "no-store", ...options });
    const raw = await r.text();
    if (!r.ok) {
      throw new Error(formatHttpError(r.status, r.statusText, raw));
    }
    if (!raw.trim()) {
      return {};
    }
    try {
      return JSON.parse(raw);
    } catch (err) {
      throw new Error(`invalid JSON :: ${err.message}`);
    }
  }

  async function apiControl(obj) {
    try {
      const j = await httpPost("/api/control", obj);
      appendLog(
        `api/control ‚Üí ${JSON.stringify(obj)} :: ${JSON.stringify(j)}`,
        "ok",
      );
      return j;
    } catch (e) {
      appendLog(
        `api/control ${JSON.stringify(obj)} :: ${e.message}`,
        "err",
      );
    }
  }

  async function doStop() {
    try {
      await apiControl({ cmd: "stop" });
    } catch {
      /* ignore */
    }
  }

  async function goF() {
    const tsec = Math.max(0.05, LIN_T);
    const v = clamp(linV, 0, 1);
    await apiControl({
      cmd: "move",
      dir: "forward",
      v,
      t: tsec,
    });
    setTimeout(() => {
      try {
        doStop();
      } catch {
        /* ignore */
      }
    }, Math.max(100, tsec * 1000));
  }

  async function goB() {
    const tsec = Math.max(0.05, LIN_T);
    const v = clamp(linV, 0, 1);
    await apiControl({
      cmd: "move",
      dir: "backward",
      v,
      t: tsec,
    });
    setTimeout(() => {
      try {
        doStop();
      } catch {
        /* ignore */
      }
    }, Math.max(100, tsec * 1000));
  }

  async function spin(dir) {
    if (!spinEl || !durSpinEl) return;
    const w = clamp(spinEl.value, 0, 1);
    const tsec = clamp(durSpinEl.value, 0.05, 5);
    await apiControl({
      cmd: "move",
      dir: dir === "left" ? "left" : "right",
      w,
      t: tsec,
    });
    setTimeout(() => {
      try {
        doStop();
      } catch {
        /* ignore */
      }
    }, Math.max(100, tsec * 1000));
  }

  qs("#btnFwd")?.addEventListener("click", () => {
    try {
      goF();
    } catch {
      /* ignore */
    }
  });
  qs("#btnBack")?.addEventListener("click", () => {
    try {
      goB();
    } catch {
      /* ignore */
    }
  });
  qs("#btnLeft")?.addEventListener("click", () => {
    try {
      spin("left");
    } catch {
      /* ignore */
    }
  });
  qs("#btnRight")?.addEventListener("click", () => {
    try {
      spin("right");
    } catch {
      /* ignore */
    }
  });
  qs("#btnStop")?.addEventListener("click", () => {
    try {
      doStop();
    } catch {
      /* ignore */
    }
  });
  qs("#btnStop2")?.addEventListener("click", () => {
    try {
      doStop();
    } catch {
      /* ignore */
    }
  });

  const pressed = new Set();
  const isArrow = (k) =>
    ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(k);

  window.addEventListener("keydown", (ev) => {
    try {
      if (ev.repeat) return;
      const k = ev.key;
      if (isArrow(k)) ev.preventDefault();
      pressed.add(k);
      if (k === " ") {
        ev.preventDefault();
        doStop();
        return;
      }
      if (k === "w" || k === "W" || k === "ArrowUp") goF();
      if (k === "s" || k === "S" || k === "ArrowDown") goB();
      if (k === "a" || k === "A" || k === "ArrowLeft") spin("left");
      if (k === "d" || k === "D" || k === "ArrowRight") spin("right");
    } catch {
      /* ignore */
    }
  });

  window.addEventListener("keyup", (ev) => {
    try {
      if (!pressed.has(ev.key)) return;
      pressed.delete(ev.key);
      if (
        [
          "w",
          "W",
          "ArrowUp",
          "s",
          "S",
          "ArrowDown",
          "a",
          "A",
          "ArrowLeft",
          "d",
          "D",
          "ArrowRight",
        ].includes(ev.key)
      ) {
        doStop();
      }
    } catch {
      /* ignore */
    }
  });

  document.addEventListener("visibilitychange", () => {
    if (document.hidden) {
      try {
        doStop();
      } catch {
        /* ignore */
      }
    }
  });

  window.addEventListener("beforeunload", () => {
    try {
      navigator.sendBeacon(
        "/api/control",
        new Blob(['{"cmd":"stop"}'], {
          type: "application/json",
        }),
      );
    } catch {
      /* ignore */
    }
  });

  // ==== FEATURES / SERVICES ====
  const TRACKING_CORE_SERVICES = [
    "rider-tracker.service",
    "rider-tracking-controller.service",
  ];
  const RECON_SERVICES = [
    "rider-vision.service",
    "rider-obstacle.service",
    "rider-motion-bridge.service",
    "rider-odometry.service",
    "rider-mapper.service",
    "rider-navigator.service",
  ];
  const svcCache = new Map();
  const featureBusy = new Set();
  let previewBeforeTracking = null;
  let previewAutoStarted = false;

  const FEATURE_STATUS = {
    running: { cls: "ok", key: "motion.feature_status_running" },
    stopped: { cls: "warn", key: "motion.feature_status_stopped" },
    warn: { cls: "warn", key: "motion.feature_status_warn" },
    error: { cls: "err", key: "motion.feature_status_error" },
    unknown: { cls: "warn", key: "motion.feature_status_unknown" },
    working: { cls: "warn", key: "motion.feature_status_working" },
  };

  const featureList = qs("#featureList");
  if (featureList) {
    featureList.addEventListener("click", (ev) => {
      const btn = ev.target.closest("button[data-feature-action]");
      if (!btn) return;
      const row = btn.closest("[data-feature]");
      if (!row) return;
      const featureId = row.getAttribute("data-feature");
      const action = btn.getAttribute("data-feature-action");
      handleFeatureAction(featureId, action);
    });
  }

  function setFeatureBusy(featureId, busy) {
    const row = document.querySelector(`[data-feature="${featureId}"]`);
    if (!row) return;
    if (busy) featureBusy.add(featureId);
    else featureBusy.delete(featureId);
    row.classList.toggle("busy", !!busy);
    row.querySelectorAll("button").forEach((btn) => {
      btn.disabled = !!busy;
    });
  }

  function setFeatureStatus(featureId, stateKey, noteText = "") {
    const pill = document.querySelector(
      `.feature-pill[data-feature-pill="${featureId}"]`,
    );
    const note = document.querySelector(
      `.feature-note[data-feature-note="${featureId}"]`,
    );
    const meta = FEATURE_STATUS[stateKey] || FEATURE_STATUS.unknown;
    if (pill) {
      pill.className = `c-pill feature-pill ${meta.cls}`;
      pill.textContent = t(meta.key);
    }
    if (note) {
      note.textContent = noteText || "";
    }
  }

  async function handleFeatureAction(featureId, action) {
    if (action === "return-home") {
      await runReturnHome();
      return;
    }
    setFeatureBusy(featureId, true);
    setFeatureStatus(
      featureId,
      "working",
      t("motion.feature_note_waiting"),
    );
    try {
      if (action === "start") {
        await startFeature(featureId);
      } else if (action === "stop") {
        await stopFeature(featureId);
      }
    } catch (e) {
      appendLog(
        `[feature ${featureId}] ${action} :: ${e.message || e}`,
        "err",
      );
      setFeatureStatus(featureId, "error", e.message || String(e));
    } finally {
      setFeatureBusy(featureId, false);
      try {
        await fetchControlState();
      } catch {
        /* ignore */
      }
      try {
        await fetchMotionQueue();
      } catch {
        /* ignore */
      }
      try {
        await fetchServices();
      } catch {
        /* ignore */
      }
    }
  }

  async function startFeature(featureId) {
    if (featureId === "face") return startTrackingFeature("face");
    if (featureId === "hand") return startTrackingFeature("hand");
    if (featureId === "recon") return startReconFeature();
    throw new Error(`unknown feature ${featureId}`);
  }

  async function stopFeature(featureId) {
    if (featureId === "face") return stopTrackingFeature("face");
    if (featureId === "hand") return stopTrackingFeature("hand");
    if (featureId === "recon") return stopReconFeature();
    throw new Error(`unknown feature ${featureId}`);
  }

  async function runReturnHome() {
    setFeatureBusy("recon", true);
    setFeatureStatus(
      "recon",
      "working",
      t("motion.feature_note_waiting"),
    );
    try {
      await httpPost("/api/navigator/return_home", {});
      appendLog("[feature recon] return_home", "ok");
    } catch (e) {
      appendLog(
        `[feature recon] return_home :: ${e.message || e}`,
        "err",
      );
      setFeatureStatus("recon", "error", e.message || String(e));
    } finally {
      setFeatureBusy("recon", false);
      try {
        await fetchControlState();
      } catch {
        /* ignore */
      }
      try {
        await fetchMotionQueue();
      } catch {
        /* ignore */
      }
    }
  }

  async function startTrackingFeature(mode) {
    await ensurePreviewForTracking();
    await runServicesSequence(TRACKING_CORE_SERVICES, "start");
    await httpPost("/api/vision/tracking/mode", {
      mode,
      enabled: true,
    });
    appendLog(
      `[feature tracking] mode=${mode} start ok`,
      "ok",
    );
  }

  async function stopTrackingFeature(mode) {
    await httpPost("/api/vision/tracking/mode", {
      mode: "none",
      enabled: false,
    });
    await runServicesSequence(TRACKING_CORE_SERVICES, "stop");
    await flushMotionQueue();
    await restorePreviewAfterTracking();
    appendLog(
      `[feature tracking] mode=${mode} stop ok`,
      "ok",
    );
  }

  async function startReconFeature() {
    await runServicesSequence(RECON_SERVICES, "start");
    const strategySel = qs("#reconStrategy");
    const strategy =
      strategySel && strategySel.value
        ? String(strategySel.value).toUpperCase()
        : "STOP";
    await httpPost("/api/navigator/start", { strategy });
    appendLog(
      `[feature recon] start strategy=${strategy}`,
      "ok",
    );
  }

  async function stopReconFeature() {
    await httpPost("/api/navigator/stop", {});
    await runServicesSequence(RECON_SERVICES, "stop");
    appendLog("[feature recon] stop", "ok");
  }

  async function runServicesSequence(units, action) {
    const ordered =
      action === "stop" ? [...units].reverse() : [...units];
    for (const unit of ordered) {
      const svc = svcCache.get(unit);
      if (action === "start" && svc && svc.active === "active") {
        appendLog(
          `[svc] ${unit} already active`,
          "warn",
        );
        continue;
      }
      if (action === "stop" && svc && svc.active === "inactive") {
        appendLog(
          `[svc] ${unit} already inactive`,
          "warn",
        );
        continue;
      }
      await svcAction(unit, action);
    }
  }

  function isServiceActive(unit) {
    const svc = svcCache.get(unit);
    return svc && svc.active === "active";
  }

  function getActivePreviewService() {
    const previewUnits = [
      "rider-cam-preview.service",
      "rider-edge-preview.service",
      "rider-ssd-preview.service",
    ];
    for (const u of previewUnits) {
      if (isServiceActive(u)) return u;
    }
    return null;
  }

  async function ensurePreviewForTracking() {
    const camActive = isServiceActive("rider-cam-preview.service");
    if (!camActive) {
      const currentPreview = getActivePreviewService();
      if (!previewBeforeTracking && !previewAutoStarted) {
        if (
          currentPreview &&
          currentPreview !== "rider-cam-preview.service"
        ) {
          previewBeforeTracking = currentPreview;
          previewAutoStarted = false;
        } else {
          previewAutoStarted = true;
          previewBeforeTracking = null;
        }
      }
      await svcAction("rider-cam-preview.service", "start");
    }
  }

  async function flushMotionQueue(reason = "tracking-stop") {
    try {
      await apiControl({ cmd: "stop", reason });
      appendLog(
        `[feature tracking] motion queue flushed (${reason})`,
        "ok",
      );
    } catch (e) {
      appendLog(
        `[feature tracking] flush queue failed :: ${e.message || e}`,
        "warn",
      );
    }
  }

  async function restorePreviewAfterTracking() {
    if (
      previewBeforeTracking &&
      previewBeforeTracking !== "rider-cam-preview.service"
    ) {
      await svcAction(previewBeforeTracking, "start");
    } else if (previewAutoStarted) {
      await svcAction("rider-cam-preview.service", "stop");
    }
  }

  // --- systemd actions: pr√≥ba wielu endpoint√≥w ---
  async function svcAction(unit, action) {
    const body = { unit, action };
    const preferSvcOnly = action === "enable" || action === "disable";
    const endpoints = [
      ...(preferSvcOnly
        ? []
        : [
            { url: "/api/systemd/action", body },
            { url: "/api/services/systemd/action", body },
            { url: "/api/services/action", body },
          ]),
      {
        url: `/svc/${encodeURIComponent(unit)}`,
        body: { action },
      },
    ];
    let lastError = null;

    for (const endpoint of endpoints) {
      const url = endpoint.url;
      try {
        const res = await httpPost(url, endpoint.body);
        appendLog(
          `[svc] ${unit} ${action} @${url} :: ${JSON.stringify(res)}`,
          "ok",
        );
        try {
          await fetchServices();
        } catch {
          /* ignore refresh failure */
        }
        return res;
      } catch (e) {
        lastError = e;
        appendLog(
          `[svc] ${unit} ${action} @${url} :: ${e.message || e}`,
          "warn",
        );
      }
    }

    if (lastError) {
      appendLog(
        `[svc] ${unit} ${action} :: all endpoints failed :: ${lastError.message || lastError}`,
        "err",
      );
    }
  }

  // --- systemd list: pr√≥ba wielu endpoint√≥w / r√≥≈ºnych format√≥w ---
  async function fetchServices() {
    try {
      const SERVICE_DESCRIPTIONS = {
        "rider-api.service": {
          pl: "Serwer API sterowania i monitoringu (REST / SSE)",
          en: "Control & monitoring API server (REST/SSE)",
        },
        "rider-broker.service": {
          pl: "Mostek komunikacyjny ZMQ miƒôdzy modu≈Çami",
          en: "ZMQ broker bridging modules",
        },
        "rider-cam-preview.service": {
          pl: "PodglƒÖd kamery zapisujƒÖcy surowe klatki",
          en: "Raw camera preview recorder",
        },
        "rider-edge-preview.service": {
          pl: "PodglƒÖd kamery z filtrem krawƒôdziowym (Canny)",
          en: "Edge-highlight camera preview (Canny)",
        },
        "rider-google-bridge.service": {
          pl: "Integracja Google Home (pobieranie i wysy≈Çanie danych)",
          en: "Google Home integration and data feed",
        },
        "rider-mapper.service": {
          pl: "Modu≈Ç mapowania SLAM (siatka zajƒôto≈õci)",
          en: "SLAM mapper producing occupancy grid",
        },
        "rider-motion-bridge.service": {
          pl: "Mostek ruchu/XGO ‚Äì telemetria i sterowanie",
          en: "Motion/XGO bridge for telemetry and control",
        },
        "rider-obstacle.service": {
          pl: "Detektor przeszk√≥d bazujƒÖcy na ramkach krawƒôdzi",
          en: "Obstacle detector using edge ROIs",
        },
        "rider-odometry.service": {
          pl: "Odometria robota (≈õledzenie pozycji)",
          en: "Robot odometry tracking",
        },
        "rider-navigator.service": {
          pl: "Autonomiczny nawigator (Rekonesans)",
          en: "Autonomous navigator (Recon mode)",
        },
        "rider-ssd-preview.service": {
          pl: "PodglƒÖd SSD z naniesionymi ramkami detektora",
          en: "SSD detector preview with bounding boxes",
        },
        "rider-tracker.service": {
          pl: "Wizualny tracker (MediaPipe ‚Äì twarz/d≈Ço≈Ñ)",
          en: "Vision tracker using MediaPipe (face/hand)",
        },
        "rider-tracking-controller.service": {
          pl: "Kontroler rotacji w trybie Follow Me",
          en: "Tracking rotation controller for Follow Me",
        },
        "rider-voice-web.service": {
          pl: "Webowe API g≈Çosu (Piper TTS + Vosk ASR)",
          en: "Voice web API (Piper TTS + Vosk ASR)",
        },
        "rider-voice.service": {
          pl: "Asystent g≈Çosowy CLI u≈ºywajƒÖcy lokalnego web ASR/TTS",
          en: "CLI voice assistant using local web ASR/TTS",
        },
        "rider-web-bridge.service": {
          pl: "Mostek HTTP‚ÜíZMQ dla komend ruchu",
          en: "HTTP‚ÜíZMQ bridge for motion commands",
        },
      };

      const endpoints = [
        "/api/systemd/services?scope=motion",
        "/api/services/systemd?scope=motion",
        "/api/services?scope=motion",
        "/api/systemd/services",
        "/api/services/systemd",
        "/api/services",
        "/svc",
      ];

      let data = null;
      let usedUrl = null;

      for (const url of endpoints) {
        try {
          const res = await fetch(url, { cache: "no-store" });
          if (!res.ok) continue;
          const j = await res.json();
          if (
            j &&
            (Array.isArray(j.services) ||
             Array.isArray(j.units) ||
             Array.isArray(j))
          ) {
            data = j;
            usedUrl = url;
            break;
          }
        } catch {
          /* ignore single endpoint failure */
        }
      }

      if (!data) {
        throw new Error("no services data from any endpoint");
      }

      let services;
      if (Array.isArray(data.services)) {
        services = data.services;
      } else if (Array.isArray(data.units)) {
        services = data.units;
      } else if (Array.isArray(data)) {
        services = data;
      } else {
        throw new Error("unsupported services payload format");
      }

    const tbody = qs("#svcBody");
    const table = qs("#svcTable");
    const info = qs("#svcInfo");
      if (!tbody || !table || !info) return;

      tbody.innerHTML = "";
      const normalizeSvcValue = (value) => String(value ?? "").trim().toLowerCase();

      function describeStatus(activeValue, subValue) {
        const activeNorm = normalizeSvcValue(activeValue);
        const subNorm = normalizeSvcValue(subValue);
        if (!activeNorm && !subNorm) {
          return {
            cls: "svc-state-unknown",
            text: t("services.status_unknown"),
          };
        }
        if (
          activeNorm.includes("fail") ||
          activeNorm.includes("error") ||
          subNorm.includes("fail")
        ) {
          return { cls: "svc-state-err", text: t("services.status_failed") };
        }
        if (
          activeNorm.startsWith("inactive") ||
          activeNorm.startsWith("dead") ||
          subNorm.startsWith("dead") ||
          subNorm.startsWith("inactive")
        ) {
          return { cls: "svc-state-warn", text: t("services.status_inactive") };
        }
        if (
          activeNorm.includes("deactivat") ||
          activeNorm.includes("stopping") ||
          subNorm.includes("stopping")
        ) {
          return { cls: "svc-state-warn", text: t("services.status_stopping") };
        }
        if (
          activeNorm.startsWith("activating") ||
          activeNorm.includes("start") ||
          subNorm.includes("start")
        ) {
          return { cls: "svc-state-warn", text: t("services.status_starting") };
        }
        if (
          activeNorm === "active" &&
          (!subNorm || subNorm === "running" || subNorm === "listening")
        ) {
          return { cls: "svc-state-ok", text: t("services.status_active") };
        }
        if (activeNorm.includes("active")) {
          return { cls: "svc-state-ok", text: t("services.status_active") };
        }
        return { cls: "svc-state-unknown", text: t("services.status_unknown") };
      }

      function describeAutostart(rawValue, loadState) {
        const normalized = normalizeSvcValue(rawValue);
        if (!normalized) {
          const loadNorm = normalizeSvcValue(loadState);
          if (loadNorm === "not-found" || loadNorm === "bad-setting") {
            return {
              cls: "svc-state-warn",
              text: t("services.autostart_disabled"),
            };
          }
          return { cls: "svc-state-unknown", text: t("services.autostart_unknown") };
        }
        if (normalized.startsWith("enabled")) {
          return { cls: "svc-state-ok", text: t("services.autostart_enabled") };
        }
        if (normalized.startsWith("disabled")) {
          return {
            cls: "svc-state-warn",
            text: t("services.autostart_disabled"),
          };
        }
        if (normalized.startsWith("masked")) {
          return { cls: "svc-state-err", text: t("services.autostart_masked") };
        }
        if (normalized.startsWith("static")) {
          return { cls: "svc-state-unknown", text: t("services.autostart_static") };
        }
        if (normalized.startsWith("linked")) {
          return {
            cls: "svc-state-unknown",
            text: t("services.autostart_linked"),
          };
        }
        if (normalized.startsWith("generated")) {
          return {
            cls: "svc-state-unknown",
            text: t("services.autostart_generated"),
          };
        }
        if (normalized.startsWith("indirect")) {
          return {
            cls: "svc-state-unknown",
            text: t("services.autostart_indirect"),
          };
        }
        return {
          cls: "svc-state-unknown",
          text: rawValue || t("services.autostart_unknown"),
        };
      }

      services.forEach((svc) => {
        const unit = svc.unit || svc.name || svc.id || "n/a";
        const overrideDesc = SERVICE_DESCRIPTIONS[unit];
        const desc =
          overrideDesc
            ? `<div class="svc-desc-wrapper"><div class="svc-desc-pl">${overrideDesc.pl}</div><div class="svc-desc-en">${overrideDesc.en}</div></div>`
            : (svc.desc || svc.description || "-");
        const activeRaw =
          svc.active ||
          svc.ActiveState ||
          svc.state ||
          svc.status ||
          "";
        const subRaw = svc.sub || svc.SubState || "";
        const enabledRaw =
          (typeof svc.enabled === "boolean"
            ? svc.enabled
              ? "enabled"
              : "disabled"
            : null) ||
          svc.enabled ||
          svc.autostart ||
          svc.UnitFileState ||
          "";
        const loadRaw = svc.load || svc.LoadState || "";
        const statusMeta = describeStatus(activeRaw, subRaw);
        const autostartMeta = describeAutostart(enabledRaw, loadRaw);
        const activeLabel =
          statusMeta.text +
          (subRaw &&
          !["running", "dead", "listening", ""].includes(
            normalizeSvcValue(subRaw),
          )
            ? ` (${subRaw})`
            : "");

        svcCache.set(unit, {
          unit,
          description: desc,
          active: activeRaw,
          enabled: enabledRaw,
        });

        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td>${unit}</td>
          <td>${desc}</td>
          <td><span class="svc-state ${statusMeta.cls}">${activeLabel}</span></td>
          <td><span class="svc-state ${autostartMeta.cls}">${autostartMeta.text}</span></td>
          <td class="svc-actions">
            <button class="c-btn c-btn-sm" data-unit="${unit}" data-action="start" title="${t("services.btn_start")}">‚ñ∂</button>
            <button class="c-btn c-btn-sm" data-unit="${unit}" data-action="stop" title="${t("services.btn_stop")}">‚ñ†</button>
            <button class="c-btn c-btn-sm" data-unit="${unit}" data-action="restart" title="${t("services.btn_restart")}">‚Üª</button>
            <button class="c-btn c-btn-sm" data-unit="${unit}" data-action="enable" title="${t("services.btn_enable")}">Ôºã</button>
            <button class="c-btn c-btn-sm" data-unit="${unit}" data-action="disable" title="${t("services.btn_disable")}">Ôºç</button>
          </td>
        `;
        tbody.appendChild(tr);
      });

      table.style.display = "table";
      info.textContent = `${t("services.loaded_at", {
        ts: new Date().toLocaleTimeString(),
      })} (${usedUrl})`;
    } catch (e) {
      appendLog(
        `/api systemd/services fetch failed :: ${e.message || e}`,
        "err",
      );
    }
  }

  qs("#svcRefresh")?.addEventListener("click", () => {
    fetchServices();
  });
  qs("#svcTable")?.addEventListener("click", (ev) => {
    const btn = ev.target.closest("button[data-unit][data-action]");
    if (!btn) return;
    const unit = btn.getAttribute("data-unit");
    const action = btn.getAttribute("data-action");
    svcAction(unit, action);
  });

  // === AI MODE (UI) ===
  async function fetchAiModeStatus() {
    try {
      const j = await fetchJson(AI_MODE_ENDPOINT);
      const badge = qs("#aiModeCurrentBadge");
      const status = qs("#aiModeStatus");
      const ts = qs("#aiModeChangedTime");
      if (badge) {
        badge.classList.remove("warn", "ok");
        badge.classList.add("ok");
        badge.textContent = j.mode === "pc_offload" ? "PC Offload" : "Local";
      }
      if (status) {
        status.textContent = t("ai_mode.status_ok");
        status.className = "muted";
      }
      if (ts && j.ts) {
        ts.textContent = new Date(j.ts * 1000).toLocaleTimeString();
      }
    } catch (e) {
      appendLog(
        `/api/ai-mode :: ${e.message || e}`,
        "warn",
      );
    }
  }

  async function setAiMode(mode) {
    try {
      await sendJson(AI_MODE_ENDPOINT, { mode }, "PUT");
      appendLog(`[ai_mode] set ${mode}`, "ok");
      await fetchAiModeStatus();
    } catch (e) {
      appendLog(
        `[ai_mode] set ${mode} :: ${e.message || e}`,
        "err",
      );
    }
  }

  qs("#btnAiModeLocal")?.addEventListener("click", () => {
    setAiMode("local");
  });
  qs("#btnAiModeOffload")?.addEventListener("click", () => {
    setAiMode("pc_offload");
  });

  // === PROVIDER CONTROL ===
  function providerModeLabel(mode) {
    return mode === "pc" ? t("provider.mode_pc") : t("provider.mode_local");
  }

  function providerStatusLabel(status) {
    if (!status) {
      return t("provider.status_unknown");
    }
    const key = `provider.status_${status}`;
    const text = t(key);
    return typeof text === "string" && text !== key ? text : `${t("provider.status_unknown")} (${status})`;
  }

  function formatChangedTs(ts) {
    if (!ts || Number.isNaN(Number(ts))) {
      return t("provider.changed_unknown");
    }
    const epochMs = Number(ts) * 1000;
    if (!Number.isFinite(epochMs)) {
      return t("provider.changed_unknown");
    }
    return new Date(epochMs).toLocaleTimeString();
  }

  function updateProviderPcBadge(health = {}) {
    const badge = qs("#providerPcStatus");
    if (!badge) return;
    const reachable = !!health.reachable;
    let cls = "warn";
    let key = "provider.pc_status_unknown";
    if (reachable) {
      cls = "ok";
      key = "provider.pc_status_online";
    } else if (health.status === "offline") {
      cls = "err";
      key = "provider.pc_status_offline";
    } else if (health.reason === "not_initialized") {
      cls = "warn";
      key = "provider.pc_status_pending";
    }
    badge.className = `c-pill ${cls}`;
    const latency = typeof health.latency_ms === "number" ? ` (${Math.round(health.latency_ms)} ms)` : "";
    badge.textContent = `${t(key)}${latency}`;
  }

  function renderProviderDomain(domain, state = {}) {
    const row = document.querySelector(`.provider-row[data-provider="${domain}"]`);
    if (!row) return;
    const pill = row.querySelector("[data-provider-pill]");
    if (pill) {
      pill.textContent = providerModeLabel(state.mode);
      pill.className = `c-pill provider-pill ${state.mode === "pc" ? "warn" : "ok"}`;
    }
    const statusEl = row.querySelector("[data-provider-status]");
    if (statusEl) {
      const label = providerStatusLabel(state.status);
      const reason = state.reason ? ` (${state.reason})` : "";
      statusEl.textContent = `${label}${reason}`;
    }
    const changedEl = row.querySelector("[data-provider-changed]");
    if (changedEl) {
      changedEl.textContent = formatChangedTs(state.changed_ts);
    }
  }

  async function fetchProviderState() {
    try {
      const data = await fetchJson(PROVIDER_STATE_ENDPOINT);
      const domains = data.domains || {};
      PROVIDER_DOMAINS.forEach((domain) => {
        renderProviderDomain(domain, domains[domain] || {});
      });
      updateProviderPcBadge(data.pc_health);
    } catch (e) {
      appendLog(`[provider] fetch :: ${e.message || e}`, "warn");
    }
  }

  async function setProviderMode(domain, target) {
    try {
      await sendJson(`/api/providers/${domain}`, { target }, "PATCH");
      appendLog(`[provider] ${domain} ‚Üí ${target}`, "ok");
      await fetchProviderState();
    } catch (e) {
      appendLog(
        `[provider] ${domain} ‚Üí ${target} :: ${e.message || e}`,
        "err",
      );
    }
  }

  document.querySelectorAll("[data-provider-action]").forEach((btn) => {
    btn.addEventListener("click", () => {
      const domain = btn.getAttribute("data-provider-domain");
      const target = btn.getAttribute("data-provider-action");
      if (!domain || !target) return;
      setProviderMode(domain, target);
    });
  });

  // Balance + height UI
  const balanceToggle = qs("#balanceToggle");
  const heightSlider = qs("#heightSlider");
  const heightValue = qs("#heightValue");

  function syncHeightValue(nextValue) {
    if (heightSlider) heightSlider.value = String(nextValue);
    if (heightValue) heightValue.textContent = String(nextValue);
  }

  // sendBalance ‚Äì funkcja wymagana przez testy + realny POST do backendu
  function sendBalance(nextValue) {
    const enabled =
      typeof nextValue === "boolean"
        ? nextValue
        : !!(balanceToggle && balanceToggle.checked);
    if (balanceToggle) balanceToggle.checked = enabled;
    appendLog(
      `[balance] toggle=${enabled ? "on" : "off"}`,
      "ok",
    );
    httpPost("/api/control/balance", { enabled }).catch(() => {});
  }

  function sendHeight(nextHeight) {
    const heightRaw =
      typeof nextHeight === "number"
        ? nextHeight
        : heightSlider
          ? Number(heightSlider.value) || 0
          : 0;
    const height = clamp(heightRaw, 0, 12);
    syncHeightValue(height);
    appendLog(
      `[height] set=${height}`,
      "ok",
    );
    httpPost("/api/control/height", { height }).catch(() => {});
  }

  if (heightSlider && heightValue) {
    syncHeightValue(Number(heightSlider.value) || 0);
    let debounce;
    const updateValue = () => {
      syncHeightValue(Number(heightSlider.value) || 0);
    };
    heightSlider.addEventListener("input", () => {
      updateValue();
      clearTimeout(debounce);
      debounce = setTimeout(() => {
        sendHeight();
      }, 120);
    });
    heightSlider.addEventListener("change", () => {
      updateValue();
      sendHeight();
    });
  }

  if (balanceToggle) {
    balanceToggle.addEventListener("change", (ev) => {
      const enabled = !!ev.target.checked;
      sendBalance(enabled);
    });
  }

  // === RESOURCES DIAG ===
  async function updateResourceRow(resName) {
    const tr = document.querySelector(`tr[data-res="${resName}"]`);
    if (!tr) return;
    const statusEl = tr.querySelector(".res-status");
    const holdersEl = tr.querySelector(".res-holders");
    if (statusEl) statusEl.textContent = t("meta.loading");
    try {
      const data = await fetchJson(`/api/resource/${encodeURIComponent(resName)}`);
      const free = !!data.free;
      if (statusEl) {
        statusEl.textContent = data.error
          ? `${t("resources.status_error")}: ${data.error}`
          : free
            ? t("resources.status_free")
            : t("resources.status_busy");
      }
      if (holdersEl) {
        const holders = (data.holders || []).map((holder) => {
          const svc = holder.service ? ` [${holder.service}]` : "";
          return `${holder.cmd || holder.pid || "pid"} (${holder.pid || "?"})${svc}`;
        });
        holdersEl.textContent = holders.length ? holders.join(", ") : t("resources.holders_none");
      }
    } catch (e) {
      if (statusEl) statusEl.textContent = e.message || String(e);
      if (holdersEl) holdersEl.textContent = "-";
    }
  }

  async function fetchResources() {
    try {
      const rows = Array.from(document.querySelectorAll("tr[data-res]"));
      await Promise.all(rows.map((tr) => updateResourceRow(tr.getAttribute("data-res"))));
      const info = qs("#resInfo");
      if (info) {
        info.textContent = t("resources.last_update", {
          time: new Date().toLocaleTimeString(),
        });
      }
    } catch (e) {
      appendLog(`/api/resource :: ${e.message || e}`, "warn");
    }
  }

  qs("#resTable")?.addEventListener("click", (ev) => {
    const btn = ev.target.closest("button[data-res][data-res-action]");
    if (!btn) return;
    const res = btn.getAttribute("data-res");
    const action = btn.getAttribute("data-res-action");
    if (action === "refresh") {
      updateResourceRow(res);
      return;
    }
    httpPost(`/api/resource/${encodeURIComponent(res)}`, { action })
      .then(() => updateResourceRow(res))
      .catch((err) => {
        appendLog(`[resource ${res}] ${action} :: ${err.message || err}`, "warn");
      });
  });

  // === MOTION QUEUE (tylko UI) ===
  async function fetchMotionQueue() {
    try {
      const j = await fetchJson("/api/motion/queue");
      const info = qs("#motionQueueInfo");
      const body = qs("#motionQueueBody");
      if (!info || !body) return;
      body.innerHTML = "";
      if (!Array.isArray(j.items) || j.items.length === 0) {
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td colspan="7" class="muted" data-i18n="motion_queue.empty_placeholder">
            Brak zlece≈Ñ ruchu.
          </td>`;
        body.appendChild(tr);
      } else {
        j.items.forEach((item) => {
          const tr = document.createElement("tr");
          tr.innerHTML = `
            <td>${item.source || "-"}</td>
            <td>${item.vx ?? "-"}</td>
            <td>${item.vy ?? "-"}</td>
            <td>${item.yaw ?? "-"}</td>
            <td>${item.time_s ?? "-"}</td>
            <td>${item.status || "-"}</td>
            <td>${item.age_s ?? "-"}</td>
          `;
          body.appendChild(tr);
        });
      }
      info.textContent = t("motion_queue.loaded_at", {
        ts: new Date().toLocaleTimeString(),
      });
    } catch (e) {
      appendLog(
        `/api/motion/queue :: ${e.message || e}`,
        "warn",
      );
    }
  }

  qs("#btnMotionQueueFlush")?.addEventListener("click", () => {
    flushMotionQueue("manual-ui");
  });

  // === CAMERA PREVIEW SWITCH ===
  const camPrev = qs("#camPrev");
  const camInfo = qs("#camInfo");
  const camToggle = qs("#camToggle");
  const btnUseEdge = qs("#btnUseEdge");
  const btnUseCam = qs("#btnUseCam");
  let camAuto = true;
  let camSource = "cam";

  function updateCamSrc() {
    if (!camPrev) return;
    const ts = Date.now();
    const base =
      camSource === "edge"
        ? "/vision/edge.jpg"
        : "/camera/last";
    camPrev.src = `${base}?ts=${ts}`;
    if (camInfo) {
      camInfo.textContent = `last: ${new Date().toLocaleTimeString()} ¬∑ source: ${camSource}`;
    }
  }

  btnUseEdge?.addEventListener("click", () => {
    camSource = "edge";
    updateCamSrc();
  });
  btnUseCam?.addEventListener("click", () => {
    camSource = "cam";
    updateCamSrc();
  });

  camToggle?.addEventListener("click", () => {
    camAuto = !camAuto;
    camToggle.textContent = camAuto
      ? t("camera.auto_refresh_on")
      : t("camera.auto_refresh_off");
  });

  setInterval(() => {
    if (camAuto) updateCamSrc();
  }, 1000);

  setInterval(() => {
    fetchProviderState().catch(() => {});
  }, 7000);

  // === SSE EVENTS ===
  try {
    const es = new EventSource("/events");
    es.onmessage = (ev) => {
      appendLog(ev.data || String(ev), "muted");
    };
    es.onerror = () => {
      appendLog("SSE: error, reconnecting‚Ä¶", "warn");
      es.close();
      setTimeout(() => {
        location.reload();
      }, 10000);
    };
  } catch (e) {
    appendLog(`SSE init failed :: ${e.message || e}`, "warn");
  }

  // initial loads
  fetchServices().catch(() => {});
  fetchResources().catch(() => {});
  fetchAiModeStatus().catch(() => {});
  fetchProviderState().catch(() => {});
  fetchControlState().catch(() => {});
  fetchMotionQueue().catch(() => {});
</script>
</body>
</html>
