<!doctype html>
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Rider-PC ‚Äî Sterowanie ruchem (REST /api)</title>
  <link rel="stylesheet" href="/web/assets/dashboard-common.css" />
  <link rel="stylesheet" href="/web/assets/control.css" />

</head>
<body data-page="control">
<div data-dashboard-menu-target></div>
<div class="wrap">

  <h1 class="control-title page-title" data-i18n="meta.app_title">
    Rider-PC ‚Äî Sterowanie ruchem (REST /api)
    <span
      id="apiStatus"
      class="muted control-status"
      data-i18n="header.api_status_checking"
    >(checking‚Ä¶)</span>
    <span
      id="obstBadge"
      class="c-pill warn control-badge"
      hidden
      data-i18n="header.obstacle_na"
    >Obstacle: n/a</span>
  </h1>

  <div class="panel-row l-row">
    <!-- 1) KAMERA -->
    <div class="c-card cam-card">
      <h2 class="c-card__title" data-i18n="camera.title">PodglƒÖd kamery</h2>

      <div class="cam-actions">
        <button id="camToggle" class="c-btn c-btn-sm" data-i18n="camera.auto_refresh_on">
          ‚ü≥ Auto-refresh (on)
        </button>
        <button id="btnUseEdge" class="c-btn c-btn-sm" data-i18n="camera.use_edge">Use EDGE</button>
        <button id="btnUseCam" class="c-btn c-btn-sm" data-i18n="camera.use_cam">Use CAM</button>
      </div>

      <div class="cam-frame">
        <div>
          <img id="camPrev" class="cam" alt="camera preview" src="/camera/last?ts=0" />
          <div
            class="c-note cam-info"
            id="camInfo"
            data-i18n="camera.last_frame_na"
          >last frame: n/a ¬∑ source: n/a</div>
        </div>
      </div>
    </div>

    <!-- 2) STEROWANIE -->
    <div class="c-card control-card">
      <h2 class="c-card__title" data-i18n="motion.title">Sterowanie ruchem</h2>

      <div class="l-row control-range-row">
        <label>
          <span data-i18n="motion.turning_speed">Prƒôdko≈õƒá skrƒôtu</span>
          <span class="muted" data-i18n="motion.turning_range">(0..1)</span>:
          <input id="speedSpin" type="range" min="0" max="1" step="0.02" value="0.18" />
          <span id="speedSpinVal">0.18</span>
        </label>
        <label>
          <span data-i18n="motion.max_speed">Prƒôdko≈õƒá maksymalna</span>
          <span class="muted" data-i18n="motion.max_speed_range">(0..1)</span>:
          <input id="speedMax" type="range" min="0" max="1" step="0.05" value="0.10" />
          <span id="speedMaxVal">0.10</span>
        </label>
        <label>
          <span data-i18n="motion.pulse_time">Czas impulsu [s]</span>:
          <input id="durationSpin" type="number" min="0.05" step="0.05" value="0.10" />
        </label>
        <div class="u-spacer"></div>
        <button id="btnStop" class="c-btn motion-btn" data-i18n="motion.btn_stop">‚ñ† STOP</button>
      </div>

      <div class="motion-grid">
        <div></div>
        <button id="btnFwd" class="c-btn motion-btn" data-i18n="motion.btn_forward">‚Üë Forward</button>
        <div></div>
        <button id="btnLeft" class="c-btn motion-btn" data-i18n="motion.btn_left">‚Üê Left</button>
        <button id="btnStop2" class="c-btn motion-btn" data-i18n="motion.btn_stop_small">‚ñ† Stop</button>
        <button id="btnRight" class="c-btn motion-btn" data-i18n="motion.btn_right">Right ‚Üí</button>
        <div></div>
        <button id="btnBack" class="c-btn motion-btn" data-i18n="motion.btn_backward">‚Üì Backward</button>
        <div></div>
      </div>

      <div class="l-row">
        <span class="muted">
          <span data-i18n="motion.shortcuts_hint">Skr√≥ty</span>:
          <span class="kbd">W/S/A/D</span>
          <span data-i18n="motion.shortcuts_tail">lub strza≈Çki; Spacja = stop.</span>
        </span>
        <div class="u-spacer"></div>
      </div>

      <div class="balance-control-row">
        <div class="balance-control">
          <label for="balanceToggle">
            <span data-i18n="balance.toggle_label">Balans (stabilizacja)</span>
            <input id="balanceToggle" type="checkbox" />
          </label>
        </div>
        <div class="balance-control">
          <label for="heightSlider">
            <span data-i18n="balance.height_label">Wysoko≈õƒá</span>
            <input
              id="heightSlider"
              type="range"
              min="0"
              max="12"
              step="1"
              value="6"
            />
            <span id="heightValue">6</span>
          </label>
        </div>
      </div>
    </div>
  </div>

  <!-- FUNKCJE + ZASOBY -->
  <div class="panel-row feature-resource">
    <div class="c-card feature-card">
      <h2 class="c-card__title" data-i18n="motion.features_title">Funkcje</h2>
      <div class="feature-list" id="featureList">
        <div class="feature-row" data-feature="zero">
          <div class="feature-info">
            <div class="feature-head">
              <div
                class="feature-title"
                data-i18n="motion.zero_mode"
              >Stan 0 ‚Äì Sterowanie rƒôczne</div>
            </div>
            <div
              class="feature-desc"
              data-i18n="motion.feature_zero_desc"
            >Wy≈ÇƒÖcza rekonesans i ≈õledzenie, zostawiajƒÖc jedynie komunikacjƒô i sterowanie rƒôczne.</div>
          </div>
          <div class="feature-status">
            <span class="c-pill feature-pill" data-feature-pill="zero">n/a</span>
          </div>
          <div class="feature-actions">
            <button
              class="c-btn c-btn-sm"
              data-feature-action="start"
              data-i18n="motion.feature_zero_btn_reset"
            >Reset</button>
            <div class="feature-note" data-feature-note="zero"></div>
          </div>
        </div>

        <div class="feature-row" data-feature="tracking">
          <div class="feature-info">
            <div class="feature-head">
              <div
                class="feature-title"
                data-i18n="motion.tracking_mode_title"
              >≈öledzenie (twarz / d≈Ço≈Ñ)</div>
            </div>
            <div
              class="feature-desc"
              data-i18n="motion.feature_tracking_desc"
            >Uruchamia tracker oraz kontroler ruchu ‚Äì wybierz tryb ≈õledzenia poni≈ºej.</div>
            <div class="feature-select">
              <span data-i18n="motion.tracking_mode_label">Tryb ≈õledzenia</span>:
              <select id="trackingMode">
                <option value="face" data-i18n="motion.tracking_mode_face">Twarz</option>
                <option value="hand" data-i18n="motion.tracking_mode_hand">D≈Ço≈Ñ</option>
              </select>
            </div>
          </div>
          <div class="feature-status">
            <span class="c-pill feature-pill" data-feature-pill="tracking">n/a</span>
          </div>
          <div class="feature-actions">
            <button
              class="c-btn c-btn-sm"
              data-feature-action="start"
              data-i18n="motion.feature_btn_start"
            >Start</button>
            <button
              class="c-btn c-btn-sm"
              data-feature-action="stop"
              data-i18n="motion.feature_btn_stop"
            >Stop</button>
            <div class="feature-note" data-feature-note="tracking"></div>
          </div>
        </div>

        <div class="feature-row" data-feature="recon">
          <div class="feature-info">
            <div class="feature-head">
              <div
                class="feature-title"
                data-i18n="motion.recon_mode"
              >Tryb Rekonesans (autonomiczny)</div>
            </div>
            <div
              class="feature-desc"
              data-i18n="motion.feature_recon_desc"
            >W≈ÇƒÖcza odometriƒô, mapper oraz startuje navigatora.</div>
            <div class="feature-select">
              <span data-i18n="motion.recon_strategy">Strategia</span>:
              <select id="reconStrategy">
                <option value="STOP">STOP (zatrzymaj)</option>
                <option value="AVOID">AVOID (omijaj)</option>
              </select>
            </div>
          </div>
          <div class="feature-status">
            <span class="c-pill feature-pill" data-feature-pill="recon">n/a</span>
          </div>
          <div class="feature-actions">
            <button
              class="c-btn c-btn-sm"
              data-feature-action="start"
              data-i18n="motion.feature_btn_start"
            >Start</button>
            <button
              class="c-btn c-btn-sm"
              data-feature-action="stop"
              data-i18n="motion.feature_btn_stop"
            >Stop</button>
            <button
              class="c-btn c-btn-sm"
              id="btnReturnHome"
              data-feature-action="return-home"
              data-i18n="motion.return_home"
            >üè† Powr√≥t do Bazy</button>
            <div class="feature-note" data-feature-note="recon"></div>
          </div>
        </div>
      </div>
    </div>

    <div class="c-card resource-card">
      <h2 class="c-card__title" data-i18n="resources.title">Diagnostyka zasob√≥w</h2>
      <div id="resInfo" class="muted" data-i18n="meta.loading">≈Åadowanie‚Ä¶</div>
      <table class="svc-table" id="resTable">
        <thead>
        <tr>
          <th data-i18n="resources.column_name">Zas√≥b</th>
          <th data-i18n="resources.column_status">Status</th>
          <th data-i18n="resources.column_holders">BlokujƒÖce procesy</th>
          <th data-i18n="resources.column_actions">Akcje</th>
        </tr>
        </thead>
        <tbody id="resBody">
        <tr data-res="mic">
          <td data-i18n="resources.mic">Mikrofon</td>
          <td class="res-status">n/a</td>
          <td class="res-holders">-</td>
          <td class="svc-actions">
            <button class="c-btn c-btn-sm" data-res="mic" data-res-action="refresh">‚ü≥</button>
            <button
              class="c-btn c-btn-sm"
              data-res="mic"
              data-res-action="stop"
              data-i18n="resources.btn_stop_service"
            >Stop us≈Çugi</button>
            <button
              class="c-btn c-btn-sm"
              data-res="mic"
              data-res-action="release"
              data-i18n="resources.btn_release"
            >Zwolnij</button>
          </td>
        </tr>
        <tr data-res="speaker">
          <td data-i18n="resources.speaker">G≈Ço≈õnik</td>
          <td class="res-status">n/a</td>
          <td class="res-holders">-</td>
          <td class="svc-actions">
            <button class="c-btn c-btn-sm" data-res="speaker" data-res-action="refresh">‚ü≥</button>
            <button
              class="c-btn c-btn-sm"
              data-res="speaker"
              data-res-action="stop"
              data-i18n="resources.btn_stop_service"
            >Stop us≈Çugi</button>
            <button
              class="c-btn c-btn-sm"
              data-res="speaker"
              data-res-action="release"
              data-i18n="resources.btn_release"
            >Zwolnij</button>
          </td>
        </tr>
        <tr data-res="camera">
          <td data-i18n="resources.camera">Kamera</td>
          <td class="res-status">n/a</td>
          <td class="res-holders">-</td>
          <td class="svc-actions">
            <button class="c-btn c-btn-sm" data-res="camera" data-res-action="refresh">‚ü≥</button>
            <button
              class="c-btn c-btn-sm"
              data-res="camera"
              data-res-action="stop"
              data-i18n="resources.btn_stop_service"
            >Stop us≈Çugi</button>
            <button
              class="c-btn c-btn-sm"
              data-res="camera"
              data-res-action="release"
              data-i18n="resources.btn_release"
            >Zwolnij</button>
          </td>
        </tr>
        <tr data-res="lcd">
          <td data-i18n="resources.lcd">Ekran LCD 2"</td>
          <td class="res-status">n/a</td>
          <td class="res-holders">-</td>
          <td class="svc-actions">
            <button class="c-btn c-btn-sm" data-res="lcd" data-res-action="refresh">‚ü≥</button>
            <button
              class="c-btn c-btn-sm"
              data-res="lcd"
              data-res-action="stop"
              data-i18n="resources.btn_stop_service"
            >Stop us≈Çugi</button>
            <button
              class="c-btn c-btn-sm"
              data-res="lcd"
              data-res-action="release"
              data-i18n="resources.btn_release"
            >Zwolnij</button>
          </td>
        </tr>
        </tbody>
      </table>
    </div>
  </div>
  <div class="c-card service-card">
    <h2 class="c-card__title">
      <span data-i18n="services.title">Us≈Çugi (systemd)</span>
      <div class="svc-controls" aria-label="Us≈Çugi ‚Äì sterowanie listƒÖ">
        <button
          id="svcRefresh"
          class="c-btn c-btn-sm section-action"
          data-i18n="services.refresh"
          title="Rƒôcznie od≈õwie≈º listƒô us≈Çug"
        >‚ü≥ od≈õwie≈º</button>
        <label class="svc-control" title="Auto od≈õwie≈ºanie tabeli co 5 sekund">
          <span class="svc-icon" aria-hidden="true">‚ü≥</span>
          <input id="svcAutoRefresh" type="checkbox" />
          <span class="svc-label" data-i18n="services.auto_refresh">Auto (5s)</span>
        </label>
        <label class="svc-control" title="Filtruj wiersze po stanie us≈Çugi">
          <span class="svc-icon" aria-hidden="true">üîé</span>
          <span class="svc-label" data-i18n="services.filter">Filtr</span>
          <select id="svcFilter" class="svc-select">
            <option value="all" data-i18n="services.filter_all">Wszystkie</option>
            <option value="ok" data-i18n="services.filter_ok">Aktywne</option>
            <option value="warn" data-i18n="services.filter_warn">Ostrze≈ºenia</option>
            <option value="err" data-i18n="services.filter_err">B≈Çƒôdy</option>
            <option value="unknown" data-i18n="services.filter_unknown">Nieznane</option>
          </select>
        </label>
      </div>
    </h2>
    <div id="svcInfo" class="muted">
      <span data-i18n="meta.loading">≈Åadowanie‚Ä¶</span>
      <span id="svcTs"></span>
    </div>
    <table class="svc-table" id="svcTable" hidden>
      <thead>
      <tr>
        <th data-i18n="services.unit">Unit</th>
        <th data-i18n="services.desc">Opis</th>
        <th data-i18n="services.status">Status</th>
        <th data-i18n="services.autostart">Autostart</th>
        <th data-i18n="services.actions">Akcje</th>
      </tr>
      </thead>
      <tbody id="svcBody"></tbody>
    </table>
  </div>

  <!-- LOG -->
  <div class="c-card log-card">
    <h2 class="c-card__title" data-i18n="events.title">Zdarzenia (SSE /events)</h2>
    <div id="log"></div>
  </div>

  <div class="c-card motion-queue-card">
    <h2 class="c-card__title">
      <span data-i18n="motion_queue.title">Kolejka ruchu</span>
      <button
        id="btnMotionQueueFlush"
        class="c-btn c-btn-sm section-action"
        data-i18n="motion_queue.btn_flush"
      >‚èπ stop &amp; wyczy≈õƒá</button>
    </h2>
    <div id="motionQueueInfo" class="muted" data-i18n="motion_queue.loading">
      Brak danych‚Ä¶
    </div>
    <table class="svc-table" id="motionQueueTable">
      <thead>
      <tr>
        <th data-i18n="motion_queue.column_source">≈πr√≥d≈Ço</th>
        <th data-i18n="motion_queue.column_vx">Vx</th>
        <th data-i18n="motion_queue.column_vy">Vy</th>
        <th data-i18n="motion_queue.column_yaw">Yaw</th>
        <th data-i18n="motion_queue.column_time">Czas [s]</th>
        <th data-i18n="motion_queue.column_status">Status</th>
        <th data-i18n="motion_queue.column_age">Wiek</th>
      </tr>
      </thead>
      <tbody id="motionQueueBody">
      <tr>
        <td
          colspan="7"
          class="muted"
          data-i18n="motion_queue.empty_placeholder"
        >Brak zlece≈Ñ ruchu.</td>
      </tr>
      </tbody>
    </table>
  </div>
</div>

<script type="module" src="/web/assets/menu.js"></script>
<script type="module">
  import { initI18n, applyDom, t } from "/web/assets/i18n.js";

  // --- i18n init ---
  const urlLang = new URLSearchParams(location.search).get("lang");
  const saved = localStorage.getItem("lang");
  const browser = (navigator.language || "").slice(0, 2).toLowerCase();
  const pick = (v) =>
    v && v.toLowerCase().startsWith("en")
      ? "en"
      : v && v.toLowerCase().startsWith("pl")
        ? "pl"
        : null;
  const lang = pick(urlLang) || pick(saved) || pick(browser) || "pl";
  if (urlLang) {
    localStorage.setItem("lang", lang);
  }

  let remoteOnline = false;

  function markOfflineUI() {
    setFeatureStatus("tracking", "error", "offline");
    setFeatureStatus("recon", "error", "offline");
    const camInfo = qs("#camInfo");
    if (camInfo) camInfo.textContent = t("camera.last_frame_na");
    const camPrevEl = qs("#camPrev");
    if (camPrevEl) camPrevEl.removeAttribute("src");
    const svcBody = qs("#svcBody");
    if (svcBody) {
      svcBody.innerHTML = `<tr><td colspan="5" class="muted">offline</td></tr>`;
    }
    const resBody = qs("#resBody");
    if (resBody) {
      resBody.querySelectorAll(".res-status").forEach((el) => (el.textContent = "offline"));
      resBody.querySelectorAll(".res-holders").forEach((el) => (el.textContent = "-"));
    }
    const mqBody = qs("#motionQueueBody");
    if (mqBody) {
      mqBody.innerHTML = `<tr><td colspan="7" class="muted">offline</td></tr>`;
    }
  }

  async function fetchControlState() {
    try {
      const j = await fetchJson("/api/control/state");
      remoteOnline = true;
      lastControlState = j || {};
      const balance = j.balance || {};
      if (balanceToggle && typeof balance.enabled === "boolean") {
        balanceToggle.checked = !!balance.enabled;
      }
      const heightState = j.height || {};
      if (typeof heightState.value === "number") {
        syncHeightValue(heightState.value);
      }

      const tracking = j.tracking || {};
      const trackingMode = (tracking.mode || "none").toLowerCase();
      const trackingEnabled = !!tracking.enabled;
      const faceRunning = trackingEnabled && trackingMode === "face";
      const handRunning = trackingEnabled && trackingMode === "hand";
    setFeatureStatus(
      "tracking",
      trackingEnabled && trackingMode !== "none" ? "running" : "stopped",
      trackingEnabled && trackingMode !== "none"
        ? t("motion.feature_note_mode", { mode: trackingMode })
        : "",
    );
    if (trackingModeSelect) {
      const next = trackingMode === "hand" ? "hand" : "face";
      trackingModeSelect.value = next;
    }

      const navigator = j.navigator || {};
      const reconRunning = !!navigator.active;
      const reconNote = navigator.state
        ? t("motion.feature_note_state", { state: navigator.state })
        : "";
      setFeatureStatus(
        "recon",
        reconRunning ? "running" : "stopped",
        reconRunning ? reconNote : "",
      );
    } catch (e) {
      remoteOnline = false;
      markOfflineUI();
      appendLog(
        `/api/control/state :: ${e.message || e}`,
        "warn",
      );
    }
  }
  await initI18n(lang);
  applyDom();
  document.documentElement.setAttribute("lang", lang);
  document.title = t("meta.app_title");

  // ====== helpers ======
  const qs = (s) => document.querySelector(s);
  const logEl = qs("#log");
  const MAX_ERR_SNIPPET = 140;

  function formatHttpError(status, statusText, raw) {
    const txt = (raw || "").trim();
    if (!txt) {
      return `HTTP ${status} :: ${statusText || "error"}`;
    }
    const stripped = txt.replace(/<[^>]*>/g, " ").replace(/\s+/g, " ").trim();
    const preview = stripped || statusText || "error";
    return `HTTP ${status} :: ${preview.slice(0, MAX_ERR_SNIPPET)}`;
  }

  function appendLog(msg, cls = "") {
    if (!logEl) return;
    const line = document.createElement("div");
    if (cls) line.className = cls;
    line.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
    logEl.appendChild(line);
    logEl.scrollTop = logEl.scrollHeight;
  }

  window.addEventListener("error", (e) =>
    appendLog(
      `${t("events.log_js_err", { msg: e.message || e })}`,
      "err",
    ),
  );
  window.addEventListener("unhandledrejection", (e) =>
    appendLog(
      `${t("events.log_prom_err", { reason: e.reason || e })}`,
      "err",
    ),
  );

  const LIN_V_DEFAULT = 0.1;
  const LIN_T = 0.1;
  let linV = LIN_V_DEFAULT;
  function clamp(n, lo, hi) {
    n = Number(n) || 0;
    return Math.max(lo, Math.min(hi, n));
  }
  const spinEl = qs("#speedSpin");
  const spinVal = qs("#speedSpinVal");
  const speedMaxEl = qs("#speedMax");
  const speedMaxVal = qs("#speedMaxVal");
  const durSpinEl = qs("#durationSpin");

  if (spinEl && spinVal) {
    spinEl.addEventListener("input", () => {
      spinVal.textContent = Number(spinEl.value).toFixed(2);
    });
  }

  function updateLinearSpeed() {
    if (!speedMaxEl || !speedMaxVal) {
      linV = LIN_V_DEFAULT;
      return;
    }
    const val = clamp(speedMaxEl.value, 0, 1);
    linV = val;
    speedMaxVal.textContent = val.toFixed(2);
  }

  if (speedMaxEl) {
    updateLinearSpeed();
    speedMaxEl.addEventListener("input", updateLinearSpeed);
  }

  async function pingHealth() {
    try {
      const r = await fetch("/healthz", { cache: "no-store" });
      const j = await r.json().catch(() => ({}));
      const apiStatus = qs("#apiStatus");
      if (!apiStatus) return;
      const ok = !!j.ok;
      apiStatus.textContent = ok
        ? t("header.api_status_ok")
        : t("header.api_status_degraded");
      apiStatus.className = ok ? "ok" : "warn";
    } catch {
      const apiStatus = qs("#apiStatus");
      if (!apiStatus) return;
      apiStatus.textContent = t("header.api_status_down");
      apiStatus.className = "err";
    }
  }

  setInterval(pingHealth, 1000);
  pingHealth();

  const AI_MODE_ENDPOINT = "/api/system/ai-mode";
  const PROVIDER_STATE_ENDPOINT = "/api/providers/state";
  const PROVIDER_DOMAINS = ["vision", "voice", "text"];

  async function sendJson(url, body, method = "POST") {
    const r = await fetch(url, {
      method,
      headers: { "Content-Type": "application/json" },
      body: body ? JSON.stringify(body) : undefined,
      cache: "no-store",
    });
    const raw = await r.text();
    let j = null;
    try {
      j = raw ? JSON.parse(raw) : {};
    } catch {
      /* ignore */
    }
    if (!r.ok) {
      const snippet =
        (j && (j.error || j.stderr || j.stdout)) ||
        formatHttpError(r.status, r.statusText, raw);
      throw new Error(snippet);
    }
    if (!j) {
      throw new Error(`HTTP ${r.status}: invalid JSON`);
    }
    return j;
  }

  async function httpPost(url, body) {
    return sendJson(url, body, "POST");
  }

  async function fetchJson(url, options = {}) {
    const r = await fetch(url, { cache: "no-store", ...options });
    const raw = await r.text();
    if (!r.ok) {
      throw new Error(formatHttpError(r.status, r.statusText, raw));
    }
    if (!raw.trim()) {
      return {};
    }
    try {
      return JSON.parse(raw);
    } catch (err) {
      throw new Error(`invalid JSON :: ${err.message}`);
    }
  }

  async function apiControl(obj) {
    try {
      const j = await httpPost("/api/control", obj);
      appendLog(
        `api/control ‚Üí ${JSON.stringify(obj)} :: ${JSON.stringify(j)}`,
        "ok",
      );
      return j;
    } catch (e) {
      appendLog(
        `api/control ${JSON.stringify(obj)} :: ${e.message}`,
        "err",
      );
    }
  }

  async function doStop() {
    try {
      await apiControl({ cmd: "stop" });
    } catch {
      /* ignore */
    }
  }

  async function goF() {
    const tsec = Math.max(0.05, LIN_T);
    const v = clamp(linV, 0, 1);
    await apiControl({
      cmd: "move",
      dir: "forward",
      v,
      t: tsec,
    });
    setTimeout(() => {
      try {
        doStop();
      } catch {
        /* ignore */
      }
    }, Math.max(100, tsec * 1000));
  }

  async function goB() {
    const tsec = Math.max(0.05, LIN_T);
    const v = clamp(linV, 0, 1);
    await apiControl({
      cmd: "move",
      dir: "backward",
      v,
      t: tsec,
    });
    setTimeout(() => {
      try {
        doStop();
      } catch {
        /* ignore */
      }
    }, Math.max(100, tsec * 1000));
  }

  async function spin(dir) {
    if (!spinEl || !durSpinEl) return;
    const w = clamp(spinEl.value, 0, 1);
    const tsec = clamp(durSpinEl.value, 0.05, 5);
    await apiControl({
      cmd: "move",
      dir: dir === "left" ? "left" : "right",
      w,
      t: tsec,
    });
    setTimeout(() => {
      try {
        doStop();
      } catch {
        /* ignore */
      }
    }, Math.max(100, tsec * 1000));
  }

  qs("#btnFwd")?.addEventListener("click", () => {
    try {
      goF();
    } catch {
      /* ignore */
    }
  });
  qs("#btnBack")?.addEventListener("click", () => {
    try {
      goB();
    } catch {
      /* ignore */
    }
  });
  qs("#btnLeft")?.addEventListener("click", () => {
    try {
      spin("left");
    } catch {
      /* ignore */
    }
  });
  qs("#btnRight")?.addEventListener("click", () => {
    try {
      spin("right");
    } catch {
      /* ignore */
    }
  });
  qs("#btnStop")?.addEventListener("click", () => {
    try {
      doStop();
    } catch {
      /* ignore */
    }
  });
  qs("#btnStop2")?.addEventListener("click", () => {
    try {
      doStop();
    } catch {
      /* ignore */
    }
  });

  const pressed = new Set();
  const isArrow = (k) =>
    ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(k);

  window.addEventListener("keydown", (ev) => {
    try {
      if (ev.repeat) return;
      const k = ev.key;
      if (isArrow(k)) ev.preventDefault();
      pressed.add(k);
      if (k === " ") {
        ev.preventDefault();
        doStop();
        return;
      }
      if (k === "w" || k === "W" || k === "ArrowUp") goF();
      if (k === "s" || k === "S" || k === "ArrowDown") goB();
      if (k === "a" || k === "A" || k === "ArrowLeft") spin("left");
      if (k === "d" || k === "D" || k === "ArrowRight") spin("right");
    } catch {
      /* ignore */
    }
  });

  window.addEventListener("keyup", (ev) => {
    try {
      if (!pressed.has(ev.key)) return;
      pressed.delete(ev.key);
      if (
        [
          "w",
          "W",
          "ArrowUp",
          "s",
          "S",
          "ArrowDown",
          "a",
          "A",
          "ArrowLeft",
          "d",
          "D",
          "ArrowRight",
        ].includes(ev.key)
      ) {
        doStop();
      }
    } catch {
      /* ignore */
    }
  });

  document.addEventListener("visibilitychange", () => {
    if (document.hidden) {
      try {
        doStop();
      } catch {
        /* ignore */
      }
    }
  });

  window.addEventListener("beforeunload", () => {
    try {
      navigator.sendBeacon(
        "/api/control",
        new Blob(['{"cmd":"stop"}'], {
          type: "application/json",
        }),
      );
    } catch {
      /* ignore */
    }
  });

  // ==== FEATURES (via /api/logic/feature) ====
  const featureBusy = new Set();
  const svcCache = new Map();
  let lastControlState = {};
  let trackingModeSelect = null;
  let svcRefreshTimer = null;
  let svcFilterMode = "all";

  const FEATURE_STATUS = {
    running: { cls: "ok", key: "motion.feature_status_running" },
    stopped: { cls: "warn", key: "motion.feature_status_stopped" },
    warn: { cls: "warn", key: "motion.feature_status_warn" },
    error: { cls: "err", key: "motion.feature_status_error" },
    unknown: { cls: "warn", key: "motion.feature_status_unknown" },
    working: { cls: "warn", key: "motion.feature_status_working" },
  };

  const featureList = qs("#featureList");
  if (featureList) {
    featureList.addEventListener("click", (ev) => {
      const btn = ev.target.closest("button[data-feature-action]");
      if (!btn) return;
      const row = btn.closest("[data-feature]");
      if (!row) return;
      const featureId = row.getAttribute("data-feature");
      const action = btn.getAttribute("data-feature-action");
      handleFeatureAction(featureId, action);
    });
  }

  function setFeatureBusy(featureId, busy) {
    const row = document.querySelector(`[data-feature="${featureId}"]`);
    if (!row) return;
    if (busy) featureBusy.add(featureId);
    else featureBusy.delete(featureId);
    row.classList.toggle("busy", !!busy);
    row.querySelectorAll("button").forEach((btn) => {
      btn.disabled = !!busy;
    });
  }

  function normalizeTrackingMode(mode) {
    if (!mode) return "none";
    const m = String(mode).toLowerCase();
    if (m.includes("hand")) return "hand";
    if (m.includes("face")) return "face";
    return m === "none" ? "none" : "none";
  }

  function selectedTrackingMode() {
    if (trackingModeSelect && trackingModeSelect.value === "hand") return "hand";
    return "face";
  }

  function trackingFeatureNameForMode(mode) {
    return mode === "hand" ? "hand_tracking" : "face_tracking";
  }

  function setFeatureStatus(featureId, stateKey, noteText = "") {
    const pill = document.querySelector(
      `.feature-pill[data-feature-pill="${featureId}"]`,
    );
    const note = document.querySelector(
      `.feature-note[data-feature-note="${featureId}"]`,
    );
    const meta = FEATURE_STATUS[stateKey] || FEATURE_STATUS.unknown;
    if (pill) {
      pill.className = `c-pill feature-pill ${meta.cls}`;
      pill.textContent = t(meta.key);
    }
    if (note) {
      note.textContent = noteText || "";
    }
  }

  async function handleFeatureAction(featureId, action) {
    if (action === "return-home") {
      await runReturnHome();
      return;
    }
    setFeatureBusy(featureId, true);
    setFeatureStatus(
      featureId,
      "working",
      t("motion.feature_note_waiting"),
    );
    try {
      if (action === "start") {
        await startFeature(featureId);
      } else if (action === "stop") {
        await stopFeature(featureId);
      }
    } catch (e) {
      appendLog(
        `[feature ${featureId}] ${action} :: ${e.message || e}`,
        "err",
      );
      setFeatureStatus(featureId, "error", e.message || String(e));
    } finally {
      setFeatureBusy(featureId, false);
      try {
        await fetchControlState();
      } catch {
        /* ignore */
      }
      try {
        await fetchMotionQueue();
      } catch {
        /* ignore */
      }
      try {
        await fetchServices();
      } catch {
        /* ignore */
      }
    }
  }

  async function startFeature(featureId) {
    if (featureId === "zero") return startZeroFeature();
    if (featureId === "tracking") {
      const mode = selectedTrackingMode();
      const featureName = trackingFeatureNameForMode(mode);
      return featureApiToggle(featureName, true, { featureId, mode });
    }
    if (featureId === "recon") return startReconFeature();
    throw new Error(`unknown feature ${featureId}`);
  }

  async function stopFeature(featureId) {
    if (featureId === "zero") return startZeroFeature();
    if (featureId === "tracking") {
      const activeMode = normalizeTrackingMode(getTrackingState().mode) || selectedTrackingMode();
      const featureName = trackingFeatureNameForMode(activeMode);
      return featureApiToggle(featureName, false, { featureId, mode: activeMode });
    }
    if (featureId === "recon") return stopReconFeature();
    throw new Error(`unknown feature ${featureId}`);
  }

  async function runReturnHome() {
    setFeatureBusy("recon", true);
    setFeatureStatus(
      "recon",
      "working",
      t("motion.feature_note_waiting"),
    );
    try {
      await httpPost("/api/navigator/return_home", {});
      appendLog("[feature recon] return_home", "ok");
    } catch (e) {
      appendLog(
        `[feature recon] return_home :: ${e.message || e}`,
        "err",
      );
      setFeatureStatus("recon", "error", e.message || String(e));
    } finally {
      setFeatureBusy("recon", false);
      try {
        await fetchControlState();
      } catch {
        /* ignore */
      }
      try {
        await fetchMotionQueue();
      } catch {
        /* ignore */
      }
    }
  }

  function reconStrategyValue() {
    const sel = qs("#reconStrategy");
    if (!sel || !sel.value) return "STOP";
    return String(sel.value || "STOP").toUpperCase();
  }

  async function startZeroFeature() {
    await featureApiToggle("face_tracking", false, { featureId: "tracking" });
    await featureApiToggle("hand_tracking", false, { featureId: "tracking" });
    await featureApiToggle("recon", false, { featureId: "recon" });
    setFeatureStatus("zero", "running", t("motion.feature_note_waiting"));
    appendLog("[feature zero] minimal stack ready", "ok");
  }

  async function startReconFeature() {
    const toggleRes = await featureApiToggle("recon", true, { featureId: "recon" });
    if (!toggleRes || toggleRes.ok === false) return toggleRes;
    try {
      const strategy = reconStrategyValue();
      await httpPost("/api/navigator/start", { strategy });
      appendLog(`[feature recon] start strategy=${strategy}`, "ok");
    } catch (e) {
      appendLog(`[feature recon] navigator/start :: ${e.message || e}`, "warn");
    }
    return toggleRes;
  }

  async function stopReconFeature() {
    try {
      await httpPost("/api/navigator/stop", {});
    } catch (e) {
      appendLog(`[feature recon] navigator/stop :: ${e.message || e}`, "warn");
    }
    const res = await featureApiToggle("recon", false, { featureId: "recon" });
    return res;
  }

  async function featureApiToggle(featureName, enabled, opts = {}) {
    if (!remoteOnline) {
      appendLog(`[feature ${featureName}] skipped ‚Äì offline`, "warn");
      setFeatureStatus(opts.featureId || "tracking", "error", "offline");
      return { ok: false, error: "offline" };
    }
    const payload = { enabled };
    const url = `/api/logic/feature/${encodeURIComponent(featureName)}`;
    const res = await httpPost(url, payload);
    const mode =
      featureName === "hand_tracking"
        ? "hand"
        : featureName === "face_tracking"
          ? "face"
          : selectedTrackingMode();
    const note =
      featureName === "face_tracking" || featureName === "hand_tracking"
        ? t("motion.feature_note_mode", { mode })
        : enabled
          ? ""
          : t("motion.feature_status_stopped");
    const targetState = res.ok ? (enabled ? "running" : "stopped") : "error";
    const targetFeature =
      opts.featureId ||
      (featureName === "recon"
        ? "recon"
        : "tracking");
    setFeatureStatus(targetFeature, targetState, note);
    appendLog(
      `[feature ${featureName}] ${enabled ? "start" : "stop"} :: ${JSON.stringify(res)}`,
      res.ok ? "ok" : "err",
    );
    return res;
  }

  // --- systemd actions via /svc ---
  async function svcAction(unit, action) {
    try {
      const res = await httpPost(`/svc/${encodeURIComponent(unit)}`, { action });
      appendLog(
        `[svc] ${unit} ${action} :: ${JSON.stringify(res)}`,
        res.ok ? "ok" : "err",
      );
      await fetchServices();
      return res;
    } catch (e) {
      appendLog(
        `[svc] ${unit} ${action} :: ${e.message || e}`,
        "err",
      );
    }
  }

  function applySvcFilter() {
    const rows = document.querySelectorAll("#svcBody tr");
    rows.forEach((tr) => {
      const state = tr.dataset.state || "unknown";
      const visible =
        svcFilterMode === "all" ||
        state === svcFilterMode ||
        (svcFilterMode === "warn" && state === "unknown");
      tr.hidden = !visible;
    });
  }

  // --- systemd list: /svc ---
  async function fetchServices() {
    try {
      const data = await fetchJson("/svc");
      remoteOnline = true;
      const services = Array.isArray(data?.services) ? data.services : [];
      const tbody = qs("#svcBody");
      const table = qs("#svcTable");
      const info = qs("#svcInfo");
      const ts = qs("#svcTs");
      if (!tbody || !table || !info) return;

      svcCache.clear();
      tbody.innerHTML = "";
      const normalizeSvcValue = (value) => String(value ?? "").trim().toLowerCase();

      function describeStatus(activeValue, subValue) {
        const activeNorm = normalizeSvcValue(activeValue);
        const subNorm = normalizeSvcValue(subValue);
        if (!activeNorm && !subNorm) {
          return {
            cls: "svc-state-unknown",
            text: t("services.status_unknown"),
          };
        }
        if (
          activeNorm.includes("fail") ||
          activeNorm.includes("error") ||
          subNorm.includes("fail")
        ) {
          return { cls: "svc-state-err", text: t("services.status_failed") };
        }
        if (
          activeNorm.startsWith("inactive") ||
          activeNorm.startsWith("dead") ||
          subNorm.startsWith("dead") ||
          subNorm.startsWith("inactive")
        ) {
          return { cls: "svc-state-warn", text: t("services.status_inactive") };
        }
        if (
          activeNorm.includes("deactivat") ||
          activeNorm.includes("stopping") ||
          subNorm.includes("stopping")
        ) {
          return { cls: "svc-state-warn", text: t("services.status_stopping") };
        }
        if (
          activeNorm.startsWith("activating") ||
          activeNorm.includes("start") ||
          subNorm.includes("start")
        ) {
          return { cls: "svc-state-warn", text: t("services.status_starting") };
        }
        if (
          activeNorm === "active" &&
          (!subNorm || subNorm === "running" || subNorm === "listening")
        ) {
          return { cls: "svc-state-ok", text: t("services.status_active") };
        }
        if (activeNorm.includes("active")) {
          return { cls: "svc-state-ok", text: t("services.status_active") };
        }
        return { cls: "svc-state-unknown", text: t("services.status_unknown") };
      }

      function describeAutostart(rawValue, loadState) {
        const normalized = normalizeSvcValue(rawValue);
        if (!normalized) {
          return { cls: "svc-state-unknown", text: t("services.autostart_unknown") };
        }
        if (normalized.startsWith("enabled")) {
          return { cls: "svc-state-ok", text: t("services.autostart_enabled") };
        }
        if (normalized.startsWith("disabled")) {
          return {
            cls: "svc-state-warn",
            text: t("services.autostart_disabled"),
          };
        }
        if (normalized.startsWith("masked")) {
          return { cls: "svc-state-err", text: t("services.autostart_masked") };
        }
        return {
          cls: "svc-state-unknown",
          text: rawValue || t("services.autostart_unknown"),
        };
      }

      services.forEach((svc) => {
        const unit = svc.unit || svc.name || svc.id || "n/a";
        const desc = svc.desc || svc.description || "-";
        const activeRaw =
          svc.active ||
          svc.ActiveState ||
          svc.state ||
          svc.status ||
          "";
        const subRaw = svc.sub || svc.SubState || "";
        const enabledRaw =
          (typeof svc.enabled === "boolean"
            ? svc.enabled
              ? "enabled"
              : "disabled"
            : null) ||
          svc.enabled ||
          svc.autostart ||
          svc.UnitFileState ||
          "";
        const loadRaw = svc.load || svc.LoadState || "";
        const statusMeta = describeStatus(activeRaw, subRaw);
        const autostartMeta = describeAutostart(enabledRaw, loadRaw);
        const activeLabel =
          statusMeta.text +
          (subRaw &&
          !["running", "dead", "listening", ""].includes(
            normalizeSvcValue(subRaw),
          )
            ? ` (${subRaw})`
            : "");
        const stateAttr = statusMeta.cls.replace("svc-state-", "") || "unknown";

        svcCache.set(unit, {
          unit,
          description: desc,
          active: activeRaw,
          enabled: enabledRaw,
        });

        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td>${unit}</td>
          <td>${desc}</td>
          <td><span class="svc-state ${statusMeta.cls}">${activeLabel}</span></td>
          <td><span class="svc-state ${autostartMeta.cls}">${autostartMeta.text}</span></td>
          <td class="svc-actions">
            <button class="c-btn c-btn-sm" data-unit="${unit}" data-action="start" title="${t("services.btn_start")}">‚ñ∂</button>
            <button class="c-btn c-btn-sm" data-unit="${unit}" data-action="stop" title="${t("services.btn_stop")}">‚ñ†</button>
            <button class="c-btn c-btn-sm" data-unit="${unit}" data-action="restart" title="${t("services.btn_restart")}">‚Üª</button>
            <button class="c-btn c-btn-sm" data-unit="${unit}" data-action="enable" title="${t("services.btn_enable")}">Ôºã</button>
            <button class="c-btn c-btn-sm" data-unit="${unit}" data-action="disable" title="${t("services.btn_disable")}">Ôºç</button>
          </td>
        `;
        tr.dataset.state = stateAttr;
        tbody.appendChild(tr);
      });

      table.hidden = false;
      const stamp = new Date().toLocaleTimeString();
      info.textContent = `${t("services.loaded_at", { ts: stamp })}`;
      if (ts) {
        ts.textContent = `(${stamp})`;
      }
      applySvcFilter();
    } catch (e) {
      remoteOnline = false;
      markOfflineUI();
      appendLog(
        `/svc fetch failed :: ${e.message || e}`,
        "err",
      );
    }
  }

  qs("#svcRefresh")?.addEventListener("click", () => {
    fetchServices();
  });
  const svcAutoRefreshToggle = qs("#svcAutoRefresh");
  if (svcAutoRefreshToggle) {
    svcAutoRefreshToggle.addEventListener("change", () => {
      const enabled = !!svcAutoRefreshToggle.checked;
      if (svcRefreshTimer) {
        clearInterval(svcRefreshTimer);
        svcRefreshTimer = null;
      }
      if (enabled) {
        svcRefreshTimer = setInterval(() => {
          fetchServices().catch(() => {});
        }, 5000);
      }
    });
  }
  const svcFilterSel = qs("#svcFilter");
  if (svcFilterSel) {
    svcFilterSel.addEventListener("change", () => {
      svcFilterMode = svcFilterSel.value || "all";
      applySvcFilter();
    });
  }
  qs("#svcTable")?.addEventListener("click", (ev) => {
    const btn = ev.target.closest("button[data-unit][data-action]");
    if (!btn) return;
    const unit = btn.getAttribute("data-unit");
    const action = btn.getAttribute("data-action");
    svcAction(unit, action);
  });

  // === AI MODE (UI) ===
  async function fetchAiModeStatus() {
    try {
      const j = await fetchJson(AI_MODE_ENDPOINT);
      const badge = qs("#aiModeCurrentBadge");
      const status = qs("#aiModeStatus");
      const ts = qs("#aiModeChangedTime");
      if (badge) {
        badge.classList.remove("warn", "ok");
        badge.classList.add("ok");
        badge.textContent = j.mode === "pc_offload" ? "PC Offload" : "Local";
      }
      if (status) {
        status.textContent = t("ai_mode.status_ok");
        status.className = "muted";
      }
      if (ts && j.ts) {
        ts.textContent = new Date(j.ts * 1000).toLocaleTimeString();
      }
    } catch (e) {
      appendLog(
        `/api/ai-mode :: ${e.message || e}`,
        "warn",
      );
    }
  }

  async function setAiMode(mode) {
    try {
      await sendJson(AI_MODE_ENDPOINT, { mode }, "PUT");
      appendLog(`[ai_mode] set ${mode}`, "ok");
      await fetchAiModeStatus();
    } catch (e) {
      appendLog(
        `[ai_mode] set ${mode} :: ${e.message || e}`,
        "err",
      );
    }
  }

  qs("#btnAiModeLocal")?.addEventListener("click", () => {
    setAiMode("local");
  });
  qs("#btnAiModeOffload")?.addEventListener("click", () => {
    setAiMode("pc_offload");
  });

  // === PROVIDER CONTROL ===
  function providerModeLabel(mode) {
    return mode === "pc" ? t("provider.mode_pc") : t("provider.mode_local");
  }

  function providerStatusLabel(status) {
    if (!status) {
      return t("provider.status_unknown");
    }
    const key = `provider.status_${status}`;
    const text = t(key);
    return typeof text === "string" && text !== key ? text : `${t("provider.status_unknown")} (${status})`;
  }

  function formatChangedTs(ts) {
    if (!ts || Number.isNaN(Number(ts))) {
      return t("provider.changed_unknown");
    }
    const epochMs = Number(ts) * 1000;
    if (!Number.isFinite(epochMs)) {
      return t("provider.changed_unknown");
    }
    return new Date(epochMs).toLocaleTimeString();
  }

  function updateProviderPcBadge(health = {}) {
    const badge = qs("#providerPcStatus");
    if (!badge) return;
    const reachable = !!health.reachable;
    let cls = "warn";
    let key = "provider.pc_status_unknown";
    if (reachable) {
      cls = "ok";
      key = "provider.pc_status_online";
    } else if (health.status === "offline") {
      cls = "err";
      key = "provider.pc_status_offline";
    } else if (health.reason === "not_initialized") {
      cls = "warn";
      key = "provider.pc_status_pending";
    }
    badge.className = `c-pill ${cls}`;
    const latency = typeof health.latency_ms === "number" ? ` (${Math.round(health.latency_ms)} ms)` : "";
    badge.textContent = `${t(key)}${latency}`;
  }

  function renderProviderDomain(domain, state = {}) {
    const row = document.querySelector(`.provider-row[data-provider="${domain}"]`);
    if (!row) return;
    const pill = row.querySelector("[data-provider-pill]");
    if (pill) {
      pill.textContent = providerModeLabel(state.mode);
      pill.className = `c-pill provider-pill ${state.mode === "pc" ? "warn" : "ok"}`;
    }
    const statusEl = row.querySelector("[data-provider-status]");
    if (statusEl) {
      const label = providerStatusLabel(state.status);
      const reason = state.reason ? ` (${state.reason})` : "";
      statusEl.textContent = `${label}${reason}`;
    }
    const changedEl = row.querySelector("[data-provider-changed]");
    if (changedEl) {
      changedEl.textContent = formatChangedTs(state.changed_ts);
    }
  }

  async function fetchProviderState() {
    try {
      const data = await fetchJson(PROVIDER_STATE_ENDPOINT);
      const domains = data.domains || {};
      PROVIDER_DOMAINS.forEach((domain) => {
        renderProviderDomain(domain, domains[domain] || {});
      });
      updateProviderPcBadge(data.pc_health);
    } catch (e) {
      appendLog(`[provider] fetch :: ${e.message || e}`, "warn");
    }
  }

  async function setProviderMode(domain, target) {
    try {
      await sendJson(`/api/providers/${domain}`, { target }, "PATCH");
      appendLog(`[provider] ${domain} ‚Üí ${target}`, "ok");
      await fetchProviderState();
    } catch (e) {
      appendLog(
        `[provider] ${domain} ‚Üí ${target} :: ${e.message || e}`,
        "err",
      );
    }
  }

  document.querySelectorAll("[data-provider-action]").forEach((btn) => {
    btn.addEventListener("click", () => {
      const domain = btn.getAttribute("data-provider-domain");
      const target = btn.getAttribute("data-provider-action");
      if (!domain || !target) return;
      setProviderMode(domain, target);
    });
  });

  // Balance + height UI
  const balanceToggle = qs("#balanceToggle");
  const heightSlider = qs("#heightSlider");
  const heightValue = qs("#heightValue");

  function syncHeightValue(nextValue) {
    if (heightSlider) heightSlider.value = String(nextValue);
    if (heightValue) heightValue.textContent = String(nextValue);
  }

  // sendBalance ‚Äì funkcja wymagana przez testy + realny POST do backendu
  function sendBalance(nextValue) {
    const enabled =
      typeof nextValue === "boolean"
        ? nextValue
        : !!(balanceToggle && balanceToggle.checked);
    if (balanceToggle) balanceToggle.checked = enabled;
    appendLog(
      `[balance] toggle=${enabled ? "on" : "off"}`,
      "ok",
    );
    httpPost("/api/control/balance", { enabled }).catch(() => {});
  }

  function sendHeight(nextHeight) {
    const heightRaw =
      typeof nextHeight === "number"
        ? nextHeight
        : heightSlider
          ? Number(heightSlider.value) || 0
          : 0;
    const height = clamp(heightRaw, 0, 12);
    syncHeightValue(height);
    appendLog(
      `[height] set=${height}`,
      "ok",
    );
    httpPost("/api/control/height", { height }).catch(() => {});
  }

  if (heightSlider && heightValue) {
    syncHeightValue(Number(heightSlider.value) || 0);
    let debounce;
    const updateValue = () => {
      syncHeightValue(Number(heightSlider.value) || 0);
    };
    heightSlider.addEventListener("input", () => {
      updateValue();
      clearTimeout(debounce);
      debounce = setTimeout(() => {
        sendHeight();
      }, 120);
    });
    heightSlider.addEventListener("change", () => {
      updateValue();
      sendHeight();
    });
  }

  if (balanceToggle) {
    balanceToggle.addEventListener("change", (ev) => {
      const enabled = !!ev.target.checked;
      sendBalance(enabled);
    });
  }

  async function flushMotionQueue(reason = "manual-ui") {
    try {
      await apiControl({ cmd: "stop", reason, clear: true });
      await fetchMotionQueue();
      appendLog(
        `[motion queue] flushed (${reason})`,
        "ok",
      );
    } catch (e) {
      appendLog(
        `[motion queue] flush failed :: ${e.message || e}`,
        "warn",
      );
    }
  }

  // === RESOURCES DIAG ===
  async function updateResourceRow(resName) {
    const tr = document.querySelector(`tr[data-res="${resName}"]`);
    if (!tr) return;
    const statusEl = tr.querySelector(".res-status");
    const holdersEl = tr.querySelector(".res-holders");
    if (statusEl) statusEl.textContent = t("meta.loading");
    try {
      const data = await fetchJson(`/api/resource/${encodeURIComponent(resName)}`);
      const free = !!data.free;
      if (statusEl) {
        statusEl.textContent = data.error
          ? `${t("resources.status_error")}: ${data.error}`
          : free
            ? t("resources.status_free")
            : t("resources.status_busy");
      }
      if (holdersEl) {
        const holders = (data.holders || []).map((holder) => {
          const svc = holder.service ? ` [${holder.service}]` : "";
          return `${holder.cmd || holder.pid || "pid"} (${holder.pid || "?"})${svc}`;
        });
        holdersEl.textContent = holders.length ? holders.join(", ") : t("resources.holders_none");
      }
    } catch (e) {
      if (statusEl) statusEl.textContent = e.message || String(e);
      if (holdersEl) holdersEl.textContent = "-";
    }
  }

  async function fetchResources() {
    if (!remoteOnline) {
      markOfflineUI();
      return;
    }
    try {
      const rows = Array.from(document.querySelectorAll("tr[data-res]"));
      await Promise.all(rows.map((tr) => updateResourceRow(tr.getAttribute("data-res"))));
      const info = qs("#resInfo");
      if (info) {
        info.textContent = t("resources.last_update", {
          time: new Date().toLocaleTimeString(),
        });
      }
    } catch (e) {
      appendLog(`/api/resource :: ${e.message || e}`, "warn");
    }
  }

  qs("#resTable")?.addEventListener("click", (ev) => {
    const btn = ev.target.closest("button[data-res][data-res-action]");
    if (!btn) return;
    const res = btn.getAttribute("data-res");
    const action = btn.getAttribute("data-res-action");
    if (action === "refresh") {
      updateResourceRow(res);
      return;
    }
    httpPost(`/api/resource/${encodeURIComponent(res)}`, { action })
      .then(() => updateResourceRow(res))
      .catch((err) => {
        appendLog(`[resource ${res}] ${action} :: ${err.message || err}`, "warn");
      });
  });

  // === MOTION QUEUE (tylko UI) ===
  async function fetchMotionQueue() {
    if (!remoteOnline) {
      markOfflineUI();
      return;
    }
    try {
      const j = await fetchJson("/api/motion/queue");
      const info = qs("#motionQueueInfo");
      const body = qs("#motionQueueBody");
      if (!info || !body) return;
      body.innerHTML = "";
      if (!Array.isArray(j.items) || j.items.length === 0) {
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td colspan="7" class="muted" data-i18n="motion_queue.empty_placeholder">
            Brak zlece≈Ñ ruchu.
          </td>`;
        body.appendChild(tr);
      } else {
        j.items.forEach((item) => {
          const tr = document.createElement("tr");
          tr.innerHTML = `
            <td>${item.source || "-"}</td>
            <td>${item.vx ?? "-"}</td>
            <td>${item.vy ?? "-"}</td>
            <td>${item.yaw ?? "-"}</td>
            <td>${item.time_s ?? "-"}</td>
            <td>${item.status || "-"}</td>
            <td>${item.age_s ?? "-"}</td>
          `;
          body.appendChild(tr);
        });
      }
      info.textContent = t("motion_queue.loaded_at", {
        ts: new Date().toLocaleTimeString(),
      });
    } catch (e) {
      appendLog(
        `/api/motion/queue :: ${e.message || e}`,
        "warn",
      );
    }
  }

  qs("#btnMotionQueueFlush")?.addEventListener("click", () => {
    flushMotionQueue("manual-ui");
  });

  // === CAMERA PREVIEW SWITCH ===
  const camPrev = qs("#camPrev");
  const camInfo = qs("#camInfo");
  const camToggle = qs("#camToggle");
  const btnUseEdge = qs("#btnUseEdge");
  const btnUseCam = qs("#btnUseCam");
  let camAuto = true;
  let camSource = "cam";

  function updateCamSrc() {
    if (!camPrev) return;
    const ts = Date.now();
    const base =
      camSource === "edge"
        ? "/vision/edge.jpg"
        : "/camera/last";
    camPrev.src = `${base}?ts=${ts}`;
    if (camInfo) {
      camInfo.textContent = `last: ${new Date().toLocaleTimeString()} ¬∑ source: ${camSource}`;
    }
  }

  btnUseEdge?.addEventListener("click", () => {
    camSource = "edge";
    updateCamSrc();
  });
  btnUseCam?.addEventListener("click", () => {
    camSource = "cam";
    updateCamSrc();
  });

  camToggle?.addEventListener("click", () => {
    camAuto = !camAuto;
    camToggle.textContent = camAuto
      ? t("camera.auto_refresh_on")
      : t("camera.auto_refresh_off");
  });

  setInterval(() => {
    if (camAuto && remoteOnline) updateCamSrc();
  }, 1000);

  setInterval(() => {
    fetchProviderState().catch(() => {});
  }, 7000);

  // === SSE EVENTS ===
  let es = null;
  function startSse() {
    if (es) return;
    try {
      es = new EventSource("/events");
      es.onmessage = (ev) => {
        if (!remoteOnline) return;
        appendLog(ev.data || String(ev), "muted");
      };
      es.onerror = () => {
        appendLog("SSE: error, reconnecting‚Ä¶", "warn");
        es.close();
        es = null;
        setTimeout(() => {
          if (remoteOnline) startSse();
        }, 10000);
      };
    } catch (e) {
      appendLog(`SSE init failed :: ${e.message || e}`, "warn");
    }
  }
  startSse();

  // initial loads
  (async () => {
    try { await fetchControlState(); } catch { /* offline handled inside */ }
    fetchServices().catch(() => {});
    fetchResources().catch(() => {});
    fetchAiModeStatus().catch(() => {});
    fetchProviderState().catch(() => {});
    fetchMotionQueue().catch(() => {});
  })();
</script>
</body>
</html>
