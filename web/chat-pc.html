<!doctype html>
<!--
  Chat PC (Standalone) - Rider-PC
  ================================
  Ekran czatu dzia≈ÇajƒÖcy w 100% lokalnie, niezale≈ºnie od Rider-Pi.
  Obs≈Çuguje tryby: PC (wymuszony lokalny), Proxy (wymuszony Rider-Pi), Auto.
-->
<html lang="pl">
<head>
<meta charset="utf-8">
<title>Rider-PC: Chat PC (Standalone)</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="/web/assets/dashboard-common.css">
<link rel="stylesheet" href="/web/assets/pages/chat-pc.css">
</head>
<body data-page="chat-pc" class="page page-chat-pc">
  <!-- Header with Menu -->
  <header class="layout-header" data-dashboard-menu-target></header>

  <!-- Main content -->
  <main class="layout-main">
    <header class="page-header">
      <div class="page-header__titles">
        <h1 class="page-title"><span class="brand-accent">Rider-PC</span>: <span class="page-title-text">Chat PC (Standalone)</span></h1>
        <p class="c-hint">Czat dzia≈ÇajƒÖcy lokalnie z modelami AI na Twoim PC</p>
      </div>
      <div class="page-header__actions page-header__actions--small links text-legend">
        <a href="/chat">Chat (klasyczny)</a>
        <span class="u-sep">¬∑</span>
        <a href="/view">dashboard</a>
      </div>
    </header>

    <!-- Provider status card -->
    <div class="provider-status-card" id="provider-status">
      <div class="provider-status-info">
        <h3>Status providera tekstowego</h3>
        <div id="provider-details" class="c-kv">
          <div>Status</div><div id="prov-status">≈Åadowanie...</div>
          <div>Model</div><div id="prov-model">‚Äî</div>
          <div>Silnik</div><div id="prov-engine">‚Äî</div>
        </div>
      </div>
      <div class="provider-status-actions">
        <span id="source-badge" class="source-indicator is-offline">Offline</span>
        <button class="c-btn c-btn-sm" id="btnRefreshStatus">Od≈õwie≈º status</button>
      </div>
    </div>

    <p id="status-line" class="status-line c-status-msg">Gotowy</p>

    <!-- Chat board -->
    <div class="board c-card" id="board" aria-live="polite"></div>

    <!-- Compose area -->
    <div class="l-row compose-row">
      <textarea id="input" placeholder="Napisz wiadomo≈õƒá‚Ä¶ (Enter = wy≈õlij, Shift+Enter = nowa linia)"></textarea>
      <div class="side">
        <button class="c-btn" id="sendBtn">Wy≈õlij</button>

        <!-- Mode selector -->
        <div class="mode-selector" role="group" aria-label="Wyb√≥r trybu czatu">
          <button type="button" id="modePC" class="active" title="Tylko lokalny model">PC</button>
          <button type="button" id="modeAuto" title="Automatyczny wyb√≥r">Auto</button>
          <button type="button" id="modeProxy" title="Przez Rider-Pi">Proxy</button>
        </div>

        <div class="controls">
          <input type="checkbox" id="tts" />
          <label for="tts">Czytaj odpowiedzi (TTS)</label>
        </div>

        <div class="c-hint">
          Chat API: <code>/api/chat/pc/send</code><br>
          Status: <code>/api/providers/text</code>
        </div>
      </div>
    </div>

    <!-- Latency info -->
    <div class="meta" id="latency"></div>

    <!-- PR Assistant section -->
    <section class="c-card u-mt-xl" id="pr-assistant-section">
      <div class="l-row">
        <h2 class="c-card__title">Asystent PR</h2>
        <div class="u-spacer"></div>
        <button class="c-btn c-btn-sm" id="btnTogglePrAssistant">Rozwi≈Ñ</button>
      </div>
      <div id="pr-assistant-content" hidden>
        <p class="c-hint u-mb-md">Generuj tre≈õƒá PR na podstawie szkicu z pomocƒÖ lokalnego AI.</p>
        <div class="c-form-group">
          <label for="prDraft">Szkic PR / opis zmian</label>
          <textarea id="prDraft" rows="4" placeholder="Opisz wprowadzone zmiany‚Ä¶"></textarea>
        </div>
        <div class="l-row u-gap-md u-mt-md">
          <div class="c-form-group">
            <label for="prStyle">Styl</label>
            <select id="prStyle">
              <option value="detailed">Szczeg√≥≈Çowy</option>
              <option value="concise">Zwiƒôz≈Çy</option>
              <option value="technical">Techniczny</option>
            </select>
          </div>
          <div class="c-form-group">
            <label for="prLang">Jƒôzyk</label>
            <select id="prLang">
              <option value="pl">Polski</option>
              <option value="en">English</option>
            </select>
          </div>
          <button class="c-btn" id="btnGeneratePr">Generuj PR</button>
        </div>
        <div id="pr-result" class="u-mt-lg" hidden>
          <h3>Wygenerowana tre≈õƒá PR</h3>
          <div class="c-kv u-mb-md">
            <div>Tytu≈Ç</div><div id="pr-title">‚Äî</div>
          </div>
          <div class="c-form-group">
            <label>Opis</label>
            <textarea id="pr-description" rows="6" readonly></textarea>
          </div>
          <div class="c-form-group">
            <label>Podsumowanie</label>
            <textarea id="pr-summary" rows="2" readonly></textarea>
          </div>
          <button class="c-btn c-btn-sm" id="btnCopyPr">Kopiuj do schowka</button>
        </div>
      </div>
    </section>
  </main>

  <!-- Footer -->
  <footer class="layout-footer" data-dashboard-footer-target></footer>

<script>
(function(){
  // DOM elements
  const board = document.getElementById('board');
  const input = document.getElementById('input');
  const sendBtn = document.getElementById('sendBtn');
  const latency = document.getElementById('latency');
  const statusLine = document.getElementById('status-line');
  const sourceBadge = document.getElementById('source-badge');
  const btnRefreshStatus = document.getElementById('btnRefreshStatus');
  const modePCBtn = document.getElementById('modePC');
  const modeAutoBtn = document.getElementById('modeAuto');
  const modeProxyBtn = document.getElementById('modeProxy');
  const ttsChk = document.getElementById('tts');

  // PR Assistant elements
  const btnTogglePrAssistant = document.getElementById('btnTogglePrAssistant');
  const prAssistantContent = document.getElementById('pr-assistant-content');
  const prDraft = document.getElementById('prDraft');
  const prStyle = document.getElementById('prStyle');
  const prLang = document.getElementById('prLang');
  const btnGeneratePr = document.getElementById('btnGeneratePr');
  const prResult = document.getElementById('pr-result');
  const prTitle = document.getElementById('pr-title');
  const prDescription = document.getElementById('pr-description');
  const prSummary = document.getElementById('pr-summary');
  const btnCopyPr = document.getElementById('btnCopyPr');

  // Provider status elements
  const provStatus = document.getElementById('prov-status');
  const provModel = document.getElementById('prov-model');
  const provEngine = document.getElementById('prov-engine');

  // State
  let currentMode = 'pc';
  let providerReady = false;
  const urlParams = new URLSearchParams(window.location.search);
  const auditMode = urlParams.get('audit') === '1';

  // History storage (separate from classic chat)
  const STORAGE_KEY = 'chat_pc_history';
  const history = JSON.parse(sessionStorage.getItem(STORAGE_KEY) || '[]');
  for (const item of history) appendMessage(item.role, item.text, item.error, item.source);

  // Helpers
  function setStatus(text, state) {
    if (!statusLine) return;
    statusLine.textContent = text;
    let cls = 'status-line c-status-msg';
    if (state === 'ok') cls += ' is-ok';
    else if (state === 'warn') cls += ' is-warn';
    else if (state === 'err') cls += ' is-err';
    statusLine.className = cls;
  }

  function setSourceBadge(source, isReady) {
    if (!sourceBadge) return;
    sourceBadge.className = 'source-indicator';
    if (source === 'pc' && isReady) {
      sourceBadge.classList.add('is-pc');
      sourceBadge.textContent = 'üñ•Ô∏è PC (lokalny)';
    } else if (source === 'proxy') {
      sourceBadge.classList.add('is-proxy');
      sourceBadge.textContent = 'üîó Proxy (Rider-Pi)';
    } else {
      sourceBadge.classList.add('is-offline');
      sourceBadge.textContent = '‚ö†Ô∏è Offline';
    }
  }

  function save(role, text, error, source) {
    history.push({ role, text, error: !!error, source });
    if (history.length > 200) history.shift();
    sessionStorage.setItem(STORAGE_KEY, JSON.stringify(history));
  }

  function appendMessage(role, text, isError, source) {
    const el = document.createElement('div');
    let cls = 'msg ' + (role === 'you' ? 'you' : 'bot');
    if (isError) cls += ' err';
    if (source === 'pc' && role === 'bot') cls += ' pc-source';
    el.className = cls;
    el.textContent = text;
    if (source && role === 'bot') {
      const meta = document.createElement('div');
      meta.className = 'msg-meta';
      meta.textContent = `≈πr√≥d≈Ço: ${source === 'pc' ? 'lokalny model' : 'Rider-Pi proxy'}`;
      el.appendChild(meta);
    }
    board.appendChild(el);
    board.scrollTop = board.scrollHeight;
  }

  // Mode selection
  function setMode(mode) {
    currentMode = mode;
    [modePCBtn, modeAutoBtn, modeProxyBtn].forEach(btn => btn.classList.remove('active'));
    if (mode === 'pc') modePCBtn.classList.add('active');
    else if (mode === 'auto') modeAutoBtn.classList.add('active');
    else if (mode === 'proxy') modeProxyBtn.classList.add('active');
    localStorage.setItem('chat_pc_mode', mode);
  }

  // Provider status
  async function refreshProviderStatus() {
    if (auditMode) {
      provStatus.textContent = 'ready';
      provModel.textContent = 'llama3.2:1b (mock)';
      provEngine.textContent = 'mock';
      providerReady = true;
      setSourceBadge('pc', true);
      return;
    }
    try {
      const res = await fetch('/api/providers/text', { cache: 'no-store' });
      const data = await res.json();
      providerReady = data.initialized === true;
      provStatus.textContent = data.status || (providerReady ? 'ready' : 'offline');
      provModel.textContent = data.model || '‚Äî';
      provEngine.textContent = data.engine || '‚Äî';
      setSourceBadge(currentMode === 'proxy' ? 'proxy' : 'pc', providerReady);

      // Disable PC mode if provider not ready
      if (!providerReady && currentMode === 'pc') {
        modePCBtn.disabled = true;
        setMode('auto');
      } else {
        modePCBtn.disabled = false;
      }
    } catch (err) {
      console.error('Provider status error:', err);
      provStatus.textContent = 'b≈ÇƒÖd';
      providerReady = false;
      setSourceBadge('offline', false);
    }
  }

  // Chat API
  async function callChat(promptText) {
    const endpoint = currentMode === 'pc' ? '/api/chat/pc/send' : '/api/chat/send';
    const payload = { msg: promptText, user: 'web-pc' };
    if (currentMode !== 'pc') payload.mode = currentMode;

    const t0 = performance.now();
    const res = await fetch(endpoint, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload),
    });
    const t1 = performance.now();
    latency.textContent = `Czas odpowiedzi: ${(t1 - t0).toFixed(0)} ms`;

    if (!res.ok) {
      const errData = await res.json().catch(() => ({ error: `${res.status} ${res.statusText}` }));
      throw new Error(errData.error || errData.hint || `HTTP ${res.status}`);
    }
    return res.json();
  }

  async function speak(text) {
    const res = await fetch('/api/voice/tts', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ text, backend: 'piper' }),
    });
    if (!res.ok) throw new Error(`TTS HTTP ${res.status}`);
    const blob = await res.blob();
    const url = URL.createObjectURL(blob);
    const audio = new Audio(url);
    await audio.play().catch(() => {});
    setTimeout(() => URL.revokeObjectURL(url), 15000);
  }

  async function send() {
    const text = (input.value || '').trim();
    if (!text) return;
    input.value = '';
    setStatus('Wysy≈Çam‚Ä¶', 'warn');
    sendBtn.disabled = true;

    appendMessage('you', text, false, null);
    save('you', text, false, null);

    try {
      const data = await callChat(text);
      const reply = data.reply || data.text || data.message || JSON.stringify(data);
      const source = data.source || 'unknown';
      appendMessage('bot', reply, false, source);
      save('bot', reply, false, source);
      setStatus('OK', 'ok');
      setSourceBadge(source, providerReady);

      if (ttsChk.checked) {
        try {
          await speak(reply);
        } catch (e) {
          appendMessage('bot', '‚ö†Ô∏è TTS: ' + (e.message || e), true, null);
        }
      }
    } catch (e) {
      const msg = e.message || String(e);
      appendMessage('bot', 'B≈ÇƒÖd: ' + msg, true, null);
      save('bot', 'B≈ÇƒÖd: ' + msg, true, null);
      setStatus('B≈ÇƒÖd', 'err');
    } finally {
      sendBtn.disabled = false;
      input.focus();
    }
  }

  // PR Assistant
  async function generatePrContent() {
    const draft = (prDraft.value || '').trim();
    if (!draft) {
      alert('Wprowad≈∫ szkic PR');
      return;
    }
    btnGeneratePr.disabled = true;
    btnGeneratePr.textContent = 'Generujƒô‚Ä¶';

    try {
      const res = await fetch('/api/chat/pc/generate-pr-content', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          draft,
          style: prStyle.value,
          language: prLang.value,
        }),
      });
      if (!res.ok) {
        const err = await res.json().catch(() => ({}));
        throw new Error(err.error || `HTTP ${res.status}`);
      }
      const data = await res.json();
      prTitle.textContent = data.title || '‚Äî';
      prDescription.value = data.description || '';
      prSummary.value = data.summary || '';
      prResult.hidden = false;
    } catch (e) {
      alert('B≈ÇƒÖd generowania: ' + (e.message || e));
    } finally {
      btnGeneratePr.disabled = false;
      btnGeneratePr.textContent = 'Generuj PR';
    }
  }

  function copyPrToClipboard() {
    const text = `# ${prTitle.textContent}\n\n${prDescription.value}\n\n## Podsumowanie\n${prSummary.value}`;
    navigator.clipboard.writeText(text).then(
      () => { btnCopyPr.textContent = '‚úì Skopiowano!'; setTimeout(() => { btnCopyPr.textContent = 'Kopiuj do schowka'; }, 2000); },
      () => alert('Nie uda≈Ço siƒô skopiowaƒá')
    );
  }

  // Event listeners
  sendBtn.addEventListener('click', send);
  input.addEventListener('keydown', (ev) => {
    if (ev.key === 'Enter' && !ev.shiftKey) {
      ev.preventDefault();
      send();
    }
  });

  modePCBtn.addEventListener('click', () => setMode('pc'));
  modeAutoBtn.addEventListener('click', () => setMode('auto'));
  modeProxyBtn.addEventListener('click', () => setMode('proxy'));

  btnRefreshStatus.addEventListener('click', refreshProviderStatus);

  btnTogglePrAssistant.addEventListener('click', () => {
    const isHidden = prAssistantContent.hidden;
    prAssistantContent.hidden = !isHidden;
    btnTogglePrAssistant.textContent = isHidden ? 'Zwi≈Ñ' : 'Rozwi≈Ñ';
  });

  btnGeneratePr.addEventListener('click', generatePrContent);
  btnCopyPr.addEventListener('click', copyPrToClipboard);

  // Audit mode placeholders
  if (auditMode && history.length === 0) {
    appendMessage('you', 'Przyk≈Çadowa wiadomo≈õƒá u≈ºytkownika w trybie PC.', false, null);
    appendMessage('bot', 'Odpowied≈∫ z lokalnego modelu AI (llama3.2:1b).', false, 'pc');
    appendMessage('bot', '‚ö†Ô∏è Przyk≈Çadowy b≈ÇƒÖd po≈ÇƒÖczenia.', true, null);
    latency.textContent = 'Czas odpowiedzi: 127 ms';
    setStatus('Tryb audytu CSS', 'warn');
  }

  // Initialize
  const storedMode = localStorage.getItem('chat_pc_mode');
  if (storedMode && ['pc', 'auto', 'proxy'].includes(storedMode)) {
    setMode(storedMode);
  } else {
    setMode('pc');
  }
  setStatus('Gotowy', 'ok');
  input.focus();
  refreshProviderStatus();
})();
</script>
<script type="module" src="/web/assets/menu.js"></script>
<script type="module" src="/web/assets/footer.js"></script>
</body>
</html>
