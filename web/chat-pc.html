<!doctype html>
<!--
  Chat PC (Standalone) - Rider-PC
  ================================
  Ekran czatu dzia≈ÇajƒÖcy w 100% lokalnie, niezale≈ºnie od Rider-Pi.
  Obs≈Çuguje tryby: PC (wymuszony lokalny), Proxy (wymuszony Rider-Pi), Auto.
-->
<html lang="pl">
<head>
<meta charset="utf-8">
<title data-i18n="nav.chat_pc">Rider-PC: Chat PC (Standalone)</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<script src="/web/assets/theme-loader.js" defer></script>
<link rel="stylesheet" href="/web/assets/dashboard-common.css">
<link rel="stylesheet" href="/web/assets/themes/classic/theme.css" data-theme-skin="classic">
  <link rel="stylesheet" href="/web/assets/themes/classic-plus/theme.css" data-theme-skin="classic-plus" disabled>
<link rel="stylesheet" href="/web/assets/themes/v2/theme.css" data-theme-skin="v2" disabled>
<link rel="stylesheet" href="/web/assets/themes/v3/theme.css" data-theme-skin="v3" disabled>
<link rel="stylesheet" href="/web/assets/pages/chat-pc.css">
</head>
<body data-page="chat-pc" class="page page-chat page-chat-pc">
  <!-- Header with Menu -->
  <header class="layout-header" data-dashboard-menu-target></header>

  <!-- Main content -->
  <main class="layout-main">
    <header class="page-header">
      <div class="page-header__titles">
        <h1 class="page-title"><span class="brand-accent">Rider-PC</span>: <span class="page-title-text" data-i18n="nav.chat_pc">Chat PC (Standalone)</span></h1>
        <p class="c-hint" data-i18n="chat_pc.subtitle">Czat dzia≈ÇajƒÖcy lokalnie z modelami AI na Twoim PC</p>
      </div>
      <div class="page-header__actions page-header__actions--small links text-legend">
        <a href="/chat" data-i18n="chat_pc.link_classic">Chat (klasyczny)</a>
        <span class="u-sep">¬∑</span>
        <a href="/view" data-i18n="chat_pc.link_dashboard">dashboard</a>
      </div>
    </header>

    <!-- Provider status card -->
    <div class="c-card chat-pc-status" id="provider-status">
      <div class="chat-pc-status__info">
        <h3 data-i18n="chat_pc.text_provider_status_title">Status providera tekstowego</h3>
        <dl id="provider-details" class="chat-pc-status__grid">
          <div>
            <dt data-i18n="chat_pc.status_label">Status</dt>
            <dd id="prov-status" data-i18n="meta.loading">≈Åadowanie...</dd>
          </div>
          <div>
            <dt data-i18n="chat_pc.model_label">Model</dt>
            <dd id="prov-model">‚Äî</dd>
          </div>
          <div>
            <dt data-i18n="chat_pc.engine_label">Silnik</dt>
            <dd id="prov-engine">‚Äî</dd>
          </div>
          <div>
            <dt data-i18n="chat_pc.backend_label">Backend</dt>
            <dd id="prov-backend">‚Äî</dd>
          </div>
        </dl>
        <div class="chat-pc-backend-control" id="chat-backend-control" hidden>
          <label for="chatBackendSelect" data-i18n="chat_pc.preferred_backend">Preferowany backend LLM</label>
          <div class="chat-pc-backend-row">
            <select id="chatBackendSelect"></select>
            <button class="c-btn c-btn-sm" id="chatBackendApply" data-i18n="chat_pc.backend_apply">Zmie≈Ñ</button>
          </div>
          <p class="c-hint" id="chatBackendHint"></p>
        </div>
      </div>
      <div class="chat-pc-status__actions">
        <span id="source-badge" class="chat-pc-pill chat-pc-pill--offline" data-i18n="chat_pc.source_offline">Offline</span>
        <button class="c-btn c-btn-sm" id="btnRefreshStatus" data-i18n="chat_pc.refresh_status">Od≈õwie≈º status</button>
      </div>
    </div>

    <!-- Chat board -->
    <div class="board c-card" id="board" aria-live="polite"></div>

    <!-- Compose area -->
    <div class="l-row compose-row">
      <textarea id="input" placeholder="Napisz wiadomo≈õƒá‚Ä¶ (Enter = wy≈õlij, Shift+Enter = nowa linia)" data-i18n-attr="placeholder:chat_pc.input_placeholder"></textarea>
      <div class="side chat-pc-sidebar">
        <div class="chat-pc-actions">
          <button class="c-btn chat-pc-send" id="sendBtn" data-i18n="chat_pc.send_button">Wy≈õlij</button>
          <div class="chat-pc-controls">
            <button class="c-btn c-btn-sm record-btn chat-pc-record" id="recordBtn" title="Nagrywaj mowƒô (ASR)" data-i18n="chat_pc.record_button" data-i18n-attr="title:chat_pc.record_title">üé§ M√≥w</button>
            <div class="chat-pc-mode" role="group" aria-label="Wyb√≥r trybu czatu" data-i18n-attr="aria-label:chat_pc.mode_group_label">
              <button type="button" id="modePC" class="chat-pc-mode__btn active" title="Tylko lokalny model" data-i18n-attr="title:chat_pc.mode_pc_title">PC</button>
              <button type="button" id="modeAuto" class="chat-pc-mode__btn" title="Automatyczny wyb√≥r" data-i18n="chat_pc.mode_auto_label" data-i18n-attr="title:chat_pc.mode_auto_title">Auto</button>
              <button type="button" id="modeProxy" class="chat-pc-mode__btn" title="Przez Rider-Pi" data-i18n="chat_pc.mode_proxy_label" data-i18n-attr="title:chat_pc.mode_proxy_title">Proxy</button>
            </div>
            <label class="chat-pc-toggle">
              <input type="checkbox" id="tts" />
              <span data-i18n="voice.read_responses">Czytaj odpowiedzi (TTS)</span>
            </label>
            <label class="chat-pc-select">
              <span data-i18n="voice.tts_provider">Provider TTS</span>
              <select id="ttsProvider"></select>
            </label>
          </div>
        </div>
      </div>
    </div>

    <div id="provider-hint" class="provider-hint c-status-msg" hidden data-i18n="chat_pc.provider_loading">≈Åadujƒô listƒô provider√≥w‚Ä¶</div>

    <section class="providers-card c-card l-stack" aria-labelledby="providerTitle">
      <div class="providers-head l-row">
        <h2 id="providerTitle" data-i18n="voice.providers_title">Providerzy TTS</h2>
        <div class="u-spacer"></div>
        <div class="providers-actions">
          <button class="c-btn c-btn-sm" id="btnReloadProviders" data-i18n="chat_pc.refresh_list">Od≈õwie≈º listƒô</button>
          <button class="c-btn c-btn-sm" id="btnTestAll" data-i18n="voice.test_all">Testuj wszystkie</button>
        </div>
      </div>
      <div id="providerList" class="provider-list" aria-live="polite">
        <div class="provider-empty c-status-msg" data-i18n="chat_pc.loading">≈Åadowanie‚Ä¶</div>
      </div>
      <div class="c-hint" data-i18n="chat_pc.test_hint">Kliknij ‚ÄûTest‚Äù, aby wykonaƒá pr√≥bƒô TTS i sprawdziƒá dzia≈Çanie us≈Çug.</div>
    </section>

    <!-- Latency info -->
    <div class="meta" id="latency"></div>

    <!-- Voice Provider status card (collapsible) -->
    <section class="c-card chat-pc-card u-mt-md" id="voice-status-section">
      <div class="l-row">
        <h3 class="c-card__title" data-i18n="chat_pc.voice_status_title">Status providera g≈Çosowego (ASR/TTS)</h3>
        <div class="u-spacer"></div>
        <button class="c-btn c-btn-sm" id="btnToggleVoiceStatus" data-i18n="chat_pc.expand">Rozwi≈Ñ</button>
      </div>
      <div id="voice-status-content" hidden>
        <div class="c-kv u-mb-md">
          <div data-i18n="chat_pc.status_label">Status</div><div id="voice-status" data-i18n="meta.loading">≈Åadowanie...</div>
          <div data-i18n="chat_pc.asr_model_label">ASR Model</div><div id="voice-asr-model">‚Äî</div>
          <div data-i18n="chat_pc.tts_model_label">TTS Model</div><div id="voice-tts-model">‚Äî</div>
          <div data-i18n="chat_pc.asr_available">ASR dostƒôpne</div><div id="voice-asr-available">‚Äî</div>
          <div data-i18n="chat_pc.tts_available">TTS dostƒôpne</div><div id="voice-tts-available">‚Äî</div>
        </div>
        <button class="c-btn c-btn-sm" id="btnRefreshVoiceStatus" data-i18n="chat_pc.voice_refresh">Od≈õwie≈º status g≈Çosu</button>
      </div>
    </section>

    <!-- PR Assistant section -->
    <section class="c-card chat-pc-card u-mt-xl" id="pr-assistant-section">
      <div class="l-row">
        <h2 class="c-card__title" data-i18n="chat_pc.pr_assistant_title">Asystent PR</h2>
        <div class="u-spacer"></div>
        <button class="c-btn c-btn-sm" id="btnTogglePrAssistant" data-i18n="chat_pc.expand">Rozwi≈Ñ</button>
      </div>
      <div id="pr-assistant-content" hidden>
        <p class="c-hint u-mb-md" data-i18n="chat_pc.pr_assistant_hint">Generuj tre≈õƒá PR na podstawie szkicu z pomocƒÖ lokalnego AI.</p>
        <div class="c-form-group">
          <label for="prDraft" data-i18n="chat_pc.pr_draft_label">Szkic PR / opis zmian</label>
          <textarea id="prDraft" rows="4" placeholder="Opisz wprowadzone zmiany‚Ä¶" data-i18n-attr="placeholder:chat_pc.pr_draft_placeholder"></textarea>
        </div>
        <!-- Knowledge base selection -->
        <div class="c-form-group u-mt-md">
          <label for="prKnowledgeBase" data-i18n="chat_pc.pr_knowledge_label">Baza wiedzy / dokumenty referencyjne</label>
          <select id="pr-knowledge-base" class="chat-pc-knowledge" multiple size="3">
            <option value="" data-i18n="chat_pc.documents_loading">≈Åadowanie dokument√≥w...</option>
          </select>
          <p class="c-hint" data-i18n="chat_pc.documents_hint">Wybierz dokumenty, kt√≥re pos≈Çu≈ºƒÖ jako kontekst (Ctrl+klik dla wielokrotnego wyboru)</p>
        </div>
        <div class="l-row u-gap-md u-mt-md">
          <div class="c-form-group">
            <label for="prStyle" data-i18n="chat_pc.pr_style_label">Styl</label>
            <select id="prStyle">
              <option value="detailed" data-i18n="chat_pc.pr_style_detailed">Szczeg√≥≈Çowy</option>
              <option value="concise" data-i18n="chat_pc.pr_style_concise">Zwiƒôz≈Çy</option>
              <option value="technical" data-i18n="chat_pc.pr_style_technical">Techniczny</option>
            </select>
          </div>
          <div class="c-form-group">
            <label for="prLang" data-i18n="chat_pc.pr_lang_label">Jƒôzyk</label>
            <select id="prLang">
              <option value="pl" data-i18n="chat_pc.lang_pl">Polski</option>
              <option value="en" data-i18n="chat_pc.lang_en">English</option>
            </select>
          </div>
          <button class="c-btn c-btn-sm" id="btnPreviewPr" title="PodglƒÖd sugestii przed zatwierdzeniem" data-i18n="chat_pc.preview" data-i18n-attr="title:chat_pc.preview_title">PodglƒÖd</button>
          <button class="c-btn" id="btnGeneratePr" data-i18n="chat_pc.generate_pr">Generuj PR</button>
        </div>
        <!-- Preview section -->
        <div id="pr-preview" class="chat-pc-card u-mt-lg" hidden>
          <h3 data-i18n="chat_pc.preview_title">PodglƒÖd sugerowanych zmian</h3>
          <div id="pr-suggestions" class="c-card u-mb-md"></div>
          <div class="l-row u-gap-sm">
            <button class="c-btn c-btn-sm" id="btnApplyPreview" data-i18n="chat_pc.apply_suggestions">Zastosuj sugestie</button>
            <button class="c-btn c-btn-sm" id="btnDiscardPreview" data-i18n="chat_pc.discard">Odrzuƒá</button>
          </div>
        </div>
        <div id="pr-result" class="chat-pc-card u-mt-lg" hidden>
          <h3 data-i18n="chat_pc.generated_pr_title">Wygenerowana tre≈õƒá PR</h3>
          <div class="c-kv u-mb-md">
            <div data-i18n="chat_pc.pr_title_label">Tytu≈Ç</div><div id="pr-title">‚Äî</div>
          </div>
          <div class="c-form-group">
            <label data-i18n="chat_pc.pr_description_label">Opis</label>
            <textarea id="pr-description" rows="6" readonly></textarea>
          </div>
          <div class="c-form-group">
            <label data-i18n="chat_pc.pr_summary_label">Podsumowanie</label>
            <textarea id="pr-summary" rows="2" readonly></textarea>
          </div>
          <button class="c-btn c-btn-sm" id="btnCopyPr" data-i18n="chat_pc.copy_button">Kopiuj do schowka</button>
        </div>
      </div>
    </section>

    <!-- Benchmark section -->
    <section class="c-card chat-pc-card u-mt-xl" id="benchmark-section">
      <div class="l-row">
        <h2 class="c-card__title" data-i18n="chat_pc.benchmark_title">Benchmark modeli</h2>
        <div class="u-spacer"></div>
        <button class="c-btn c-btn-sm" id="btnToggleBenchmark" data-i18n="chat_pc.expand">Rozwi≈Ñ</button>
      </div>
      <div id="benchmark-content" hidden>
        <p class="c-hint u-mb-md" data-i18n="chat_pc.benchmark_hint">Testuj wydajno≈õƒá modeli AI przez wysy≈Çanie pr√≥bek i mierzenie latencji.</p>
        <div class="c-form-group">
          <label for="benchmarkPrompts" data-i18n="chat_pc.benchmark_prompts_label">Prompty testowe (jeden na liniƒô)</label>
          <textarea id="benchmarkPrompts" rows="4" placeholder="Wprowad≈∫ prompty testowe...
Przyk≈Çad: Wyja≈õnij czym jest FastAPI
Przyk≈Çad: Napisz funkcjƒô sortujƒÖcƒÖ w Pythonie" data-i18n-attr="placeholder:chat_pc.benchmark_prompts_placeholder"></textarea>
        </div>
        <div class="l-row u-gap-md u-mt-md">
          <div class="c-form-group">
            <label for="benchmarkIterations" data-i18n="chat_pc.benchmark_iterations_label">Iteracje</label>
            <select id="benchmarkIterations">
              <option value="1">1</option>
              <option value="3">3</option>
              <option value="5">5</option>
              <option value="10">10</option>
            </select>
          </div>
          <div class="c-form-group">
            <label for="benchmarkMaxTokens" data-i18n="chat_pc.benchmark_max_tokens">Max token√≥w</label>
            <input type="number" id="benchmarkMaxTokens" value="256" min="32" max="2048">
          </div>
          <button class="c-btn" id="btnRunBenchmark" data-i18n="chat_pc.run_benchmark">Uruchom benchmark</button>
        </div>
        <div id="benchmark-results" class="u-mt-lg" hidden>
          <h3 data-i18n="chat_pc.benchmark_results">Wyniki benchmarku</h3>
          <div class="c-kv u-mb-md" id="benchmark-summary">
            <div data-i18n="chat_pc.model_label">Model</div><div id="bench-model">‚Äî</div>
            <div data-i18n="chat_pc.engine_label">Silnik</div><div id="bench-engine">‚Äî</div>
            <div data-i18n="chat_pc.avg_latency">≈örednia latencja</div><div id="bench-avg-latency">‚Äî ms</div>
            <div data-i18n="chat_pc.success_rate">Udane / Wszystkie</div><div id="bench-success-rate">‚Äî / ‚Äî</div>
            <div data-i18n="chat_pc.total_tokens">≈ÅƒÖcznie token√≥w</div><div id="bench-total-tokens">‚Äî</div>
          </div>
          <div id="benchmark-details" class="benchmark-details"></div>
        </div>
      </div>
    </section>
  </main>

  <!-- Footer -->
  <footer class="layout-footer" data-dashboard-footer-target></footer>

  <script type="module">
    import { initI18nPage } from '/web/assets/i18n-loader.js';
    await initI18nPage({ titleKey: 'nav.chat_pc' });
  </script>
  <script>
(function(){
  // DOM elements
  const board = document.getElementById('board');
  const input = document.getElementById('input');
  const sendBtn = document.getElementById('sendBtn');
  const recordBtn = document.getElementById('recordBtn');
  const latency = document.getElementById('latency');
  const statusLine = document.getElementById('status-line');
  const sourceBadge = document.getElementById('source-badge');
  const btnRefreshStatus = document.getElementById('btnRefreshStatus');
  const modePCBtn = document.getElementById('modePC');
  const modeAutoBtn = document.getElementById('modeAuto');
  const modeProxyBtn = document.getElementById('modeProxy');
  const ttsChk = document.getElementById('tts');
  const providerSelect = document.getElementById('ttsProvider');
  const providerHint = document.getElementById('provider-hint');
  const providerListEl = document.getElementById('providerList');
  const btnReloadProviders = document.getElementById('btnReloadProviders');
  const btnTestAll = document.getElementById('btnTestAll');

  // PR Assistant elements
  const btnTogglePrAssistant = document.getElementById('btnTogglePrAssistant');
  const prAssistantContent = document.getElementById('pr-assistant-content');
  const prDraft = document.getElementById('prDraft');
  const prStyle = document.getElementById('prStyle');
  const prLang = document.getElementById('prLang');
  const btnGeneratePr = document.getElementById('btnGeneratePr');
  const prResult = document.getElementById('pr-result');
  const prTitle = document.getElementById('pr-title');
  const prDescription = document.getElementById('pr-description');
  const prSummary = document.getElementById('pr-summary');
  const btnCopyPr = document.getElementById('btnCopyPr');
  const prKnowledgeBase = document.getElementById('pr-knowledge-base');
  const btnPreviewPr = document.getElementById('btnPreviewPr');
  const prPreview = document.getElementById('pr-preview');
  const prSuggestions = document.getElementById('pr-suggestions');
  const btnApplyPreview = document.getElementById('btnApplyPreview');
  const btnDiscardPreview = document.getElementById('btnDiscardPreview');

  // Benchmark elements
  const btnToggleBenchmark = document.getElementById('btnToggleBenchmark');
  const benchmarkContent = document.getElementById('benchmark-content');
  const benchmarkPrompts = document.getElementById('benchmarkPrompts');
  const benchmarkIterations = document.getElementById('benchmarkIterations');
  const benchmarkMaxTokens = document.getElementById('benchmarkMaxTokens');
  const btnRunBenchmark = document.getElementById('btnRunBenchmark');
  const benchmarkResults = document.getElementById('benchmark-results');
  const benchModel = document.getElementById('bench-model');
  const benchEngine = document.getElementById('bench-engine');
  const benchAvgLatency = document.getElementById('bench-avg-latency');
  const benchSuccessRate = document.getElementById('bench-success-rate');
  const benchTotalTokens = document.getElementById('bench-total-tokens');
  const benchmarkDetails = document.getElementById('benchmark-details');

  // Voice status elements
  const btnToggleVoiceStatus = document.getElementById('btnToggleVoiceStatus');
  const voiceStatusContent = document.getElementById('voice-status-content');
  const voiceStatus = document.getElementById('voice-status');
  const voiceAsrModel = document.getElementById('voice-asr-model');
  const voiceTtsModel = document.getElementById('voice-tts-model');
  const voiceAsrAvailable = document.getElementById('voice-asr-available');
  const voiceTtsAvailable = document.getElementById('voice-tts-available');
  const btnRefreshVoiceStatus = document.getElementById('btnRefreshVoiceStatus');

  // Provider status elements
  const provStatus = document.getElementById('prov-status');
  const provModel = document.getElementById('prov-model');
  const provEngine = document.getElementById('prov-engine');
  const provBackend = document.getElementById('prov-backend');
  const chatBackendControl = document.getElementById('chat-backend-control');
  const chatBackendSelect = document.getElementById('chatBackendSelect');
  const chatBackendApply = document.getElementById('chatBackendApply');
  const chatBackendHint = document.getElementById('chatBackendHint');

  const t = window.__i18n_t || ((key, params) => key);

  // Backend display names
  const backendDisplayNames = {
    local: t('chat_pc.backend_local'),
    gemini: 'Gemini',
    chatgpt: 'ChatGPT',
    auto: t('chat_pc.backend_auto'),
    mock: t('chat_pc.backend_mock')
  };
  const FALLBACK_PROVIDERS = [
    { id: 'local',  label: t('chat_pc.provider_piper_label'),  backend: 'piper',  voice: 'pl_PL-gosia-medium.onnx', description: t('chat_pc.provider_piper_desc'), service: 'voice-web' },
    { id: 'openai', label: t('chat_pc.provider_openai_label'), backend: 'openai', voice: 'alloy', model: 'gpt-4o-mini-tts', description: t('chat_pc.provider_openai_desc'), service: null },
    { id: 'google', label: t('chat_pc.provider_google_label'), backend: 'google', voice: 'Kore',  model: 'gemini-2.5-flash-preview-tts', description: t('chat_pc.provider_google_desc'), service: null },
  ];

  // State
  let currentMode = 'pc';
  let providerReady = false;
  let voiceProviderReady = false;
  let isRecording = false;
  let mediaRecorder = null;
  let audioChunks = [];
  let providerCatalog = [];
  const urlParams = new URLSearchParams(window.location.search);
  const auditMode = urlParams.get('audit') === '1';

  // History storage (separate from classic chat)
  const STORAGE_KEY = 'chat_pc_history';
  const history = JSON.parse(sessionStorage.getItem(STORAGE_KEY) || '[]');
  for (const item of history) appendMessage(item.role, item.text, item.error, item.source, item.backend);

  // Helpers
  function setStatus(text, state) {
    if (!statusLine) return;
    statusLine.textContent = text;
    let cls = 'status-line c-status-msg';
    if (state === 'ok') cls += ' is-ok';
    else if (state === 'warn') cls += ' is-warn';
    else if (state === 'err') cls += ' is-err';
    statusLine.className = cls;
  }

  function setSourceBadge(source, isReady) {
    if (!sourceBadge) return;
    sourceBadge.className = 'chat-pc-pill';
    if (source === 'pc' && isReady) {
      sourceBadge.classList.add('chat-pc-pill--pc');
      sourceBadge.textContent = t('chat_pc.source_pc');
    } else if (source === 'proxy') {
      sourceBadge.classList.add('chat-pc-pill--proxy');
      sourceBadge.textContent = t('chat_pc.source_proxy');
    } else {
      sourceBadge.classList.add('chat-pc-pill--offline');
      sourceBadge.textContent = t('chat_pc.source_offline');
    }
  }

  let saveTimeout;
  function save(role, text, error, source, backend) {
    history.push({ role, text, error: !!error, source, backend });
    if (history.length > 200) history.shift();
    // Debounce zapisu do sessionStorage: zapis po 500ms od ostatniej zmiany
    clearTimeout(saveTimeout);
    saveTimeout = setTimeout(() => {
      sessionStorage.setItem(STORAGE_KEY, JSON.stringify(history));
    }, 500);
  }

  function appendMessage(role, text, isError, source, backend) {
    const el = document.createElement('div');
    let cls = 'msg ' + (role === 'you' ? 'you' : 'bot');
    if (isError) cls += ' err';
    if (source === 'pc' && role === 'bot') cls += ' pc-source';
    el.className = cls;
    el.textContent = text;
    if (source && role === 'bot') {
      const meta = document.createElement('div');
      meta.className = 'msg-meta';
      let sourceLabel = source === 'pc' ? t('chat_pc.source_local_model') : t('chat_pc.source_proxy_label');
      if (backend && backendDisplayNames[backend]) {
        sourceLabel = `${backendDisplayNames[backend]}`;
      }
      meta.textContent = `${t('dash.snap.hint_prefix')} ${sourceLabel}`;
      el.appendChild(meta);
    }
    board.appendChild(el);
    board.scrollTop = board.scrollHeight;
  }

  // Voice provider helpers
  function providerStateClass(state) {
    if (state === 'ok') return 'c-pill is-ok';
    if (state === 'error') return 'c-pill is-err';
    return 'c-pill is-warn';
  }

  function serviceStateSummary(provider) {
    const state = provider?.service_state;
    if (!state) return t('chat_pc.no_data');
    if (state.error) return `${t('chat.status_error')} (${state.error})`;
    const parts = [];
    if (state.active) parts.push(state.active);
    if (state.sub && (!parts.length || state.sub !== parts[parts.length - 1])) {
      parts.push(state.sub);
    }
    if (!parts.length && state.enabled) parts.push(state.enabled);
    return parts.join(' / ') || t('chat_pc.not_available');
  }

  function isServiceActive(provider) {
    const state = provider?.service_state;
    if (!state) return false;
    const active = (state.active || '').toLowerCase();
    const sub = (state.sub || '').toLowerCase();
    return active === 'active' || sub === 'running';
  }

  function setProviderHint(provider) {
    if (!providerHint) return;
    if (!provider) {
      providerHint.textContent = t('chat_pc.no_tts_providers');
      providerHint.hidden = false;
      return;
    }
    const state = provider.status?.state || 'unknown';
    const detail = provider.status?.detail || '';
    providerHint.hidden = false;
    providerHint.textContent = `${provider.label}: ${state === 'ok' ? t('chat_pc.ready') : state === 'error' ? t('chat.status_error') : t('chat_pc.no_data')}${detail ? ` ‚Äì ${detail}` : ''}`;
  }

  function getSelectedProvider() {
    if (!providerSelect) return undefined;
    const currentId = providerSelect.value;
    if (!currentId) return undefined;
    return providerCatalog.find((p) => p.id === currentId);
  }

  function renderProviderSelect() {
    if (!providerSelect) return;
    providerSelect.innerHTML = '';
    if (!providerCatalog.length) {
      providerSelect.disabled = true;
      return;
    }
    providerSelect.disabled = false;
    for (const provider of providerCatalog) {
      const opt = document.createElement('option');
      opt.value = provider.id;
      opt.textContent = provider.label;
      providerSelect.appendChild(opt);
    }
    const stored = localStorage.getItem('chat_pc_tts_provider');
    let current = stored && providerCatalog.find((p) => p.id === stored);
    if (!current) {
      current = providerCatalog.find((p) => p.status?.state === 'ok') || providerCatalog[0];
    }
    providerSelect.value = current?.id || providerCatalog[0].id;
    localStorage.setItem('chat_pc_tts_provider', providerSelect.value);
    setProviderHint(getSelectedProvider());
  }

  function renderProviderList() {
    if (!providerListEl) return;
    providerListEl.innerHTML = '';
    if (!providerCatalog.length) {
      const empty = document.createElement('div');
      empty.className = 'provider-empty c-status-msg';
      empty.textContent = t('chat_pc.providers_empty');
      providerListEl.appendChild(empty);
      return;
    }
    for (const provider of providerCatalog) {
      const row = document.createElement('div');
      row.className = 'provider-row c-card';

      const info = document.createElement('div');
      info.className = 'provider-info';
      const name = document.createElement('div');
      name.className = 'provider-name';
      name.textContent = provider.label;
      const desc = document.createElement('div');
      desc.className = 'provider-desc';
      desc.textContent = provider.description || '';
      info.appendChild(name);
      info.appendChild(desc);

      const meta = document.createElement('div');
      meta.className = 'provider-meta';
      const pill = document.createElement('span');
      const state = provider.status?.state || 'unknown';
      pill.className = providerStateClass(state);
      pill.textContent = state === 'ok' ? t('chat.status_ok') : state === 'error' ? t('chat.status_error') : t('chat.status_dash');
      meta.appendChild(pill);
      if (provider.status?.detail) {
        const detail = document.createElement('div');
        detail.className = 'provider-detail';
        detail.textContent = provider.status.detail;
        meta.appendChild(detail);
      }
      if (typeof provider.status?.latency_ms === 'number') {
        const latencyInfo = document.createElement('div');
        latencyInfo.className = 'provider-latency';
        latencyInfo.textContent = `${provider.status.latency_ms} ms`;
        meta.appendChild(latencyInfo);
      }
      if (provider.service) {
        const svcInfo = document.createElement('div');
        svcInfo.className = 'provider-service';
        svcInfo.innerHTML = `<strong>${t('chat.provider_service')}</strong> ${provider.service} (${serviceStateSummary(provider)})`;
        meta.appendChild(svcInfo);
      }

      const actions = document.createElement('div');
      actions.className = 'provider-actions';
      const btn = document.createElement('button');
      btn.className = 'c-btn c-btn-sm';
      btn.textContent = t('chat_pc.test_button');
      btn.addEventListener('click', () => {
        btn.disabled = true;
        btn.textContent = t('chat_pc.testing_short');
        runProviderChecks([provider.id])
          .catch((err) => {
            if (providerHint) {
              providerHint.textContent = t('chat_pc.test_failed', {
                label: provider.label,
                msg: err.message || err,
              });
            }
          })
          .finally(() => {
            btn.disabled = false;
            btn.textContent = t('chat_pc.test_button');
          });
      });
      actions.appendChild(btn);
      if (provider.service) {
        const startBtn = document.createElement('button');
        startBtn.className = 'c-btn c-btn-sm';
        startBtn.textContent = t('chat_pc.start_button');
        if (isServiceActive(provider)) startBtn.disabled = true;
        startBtn.addEventListener('click', () => {
          handleServiceAction(provider, 'start', startBtn);
        });
        const stopBtn = document.createElement('button');
        stopBtn.className = 'c-btn c-btn-sm';
        stopBtn.textContent = t('chat_pc.stop_button');
        if (!isServiceActive(provider)) stopBtn.disabled = true;
        stopBtn.addEventListener('click', () => {
          handleServiceAction(provider, 'stop', stopBtn);
        });
        actions.appendChild(startBtn);
        actions.appendChild(stopBtn);
      }

      row.appendChild(info);
      row.appendChild(meta);
      row.appendChild(actions);
      providerListEl.appendChild(row);
    }
  }

  function updateProviderStatus(providerId, result) {
    if (!providerId) return;
    const provider = providerCatalog.find((p) => p.id === providerId);
    if (!provider) return;
    provider.status = provider.status || {};
    if (result?.state) provider.status.state = result.state;
    provider.status.state = provider.status.state || 'unknown';
    if (result?.detail || result?.error) {
      provider.status.detail = result.detail || result.error;
    }
    if (typeof result?.latency_ms === 'number') {
      provider.status.latency_ms = Math.round(result.latency_ms);
    }
    provider.status.updated = Date.now();
    renderProviderList();
    if (getSelectedProvider()?.id === providerId) {
      setProviderHint(provider);
    }
  }

  async function loadProviders() {
    if (!providerHint) return;
    if (auditMode) {
      providerCatalog = FALLBACK_PROVIDERS.map((p, idx) => ({
        ...p,
        status: {
          state: idx === 0 ? 'ok' : 'warn',
          detail: idx === 0 ? t('chat_pc.local_provider_active') : t('chat_pc.proxy_requires_pi'),
        },
        service_state: p.service ? { unit: p.service, alias: p.service, active: idx === 0 ? 'active' : 'inactive', sub: idx === 0 ? 'running' : 'stopped' } : null,
      }));
      providerHint.textContent = t('chat_pc.audit_hint');
      providerHint.hidden = false;
      renderProviderSelect();
      renderProviderList();
      return;
    }
    providerHint.hidden = false;
    providerHint.textContent = t('chat_pc.provider_loading');
    try {
      const res = await fetch('/api/voice/providers', { cache: 'no-store' });
      if (!res.ok) {
        const errText = await res.text().catch(() => `${res.status} ${res.statusText}`);
        throw new Error(errText);
      }
      const data = await res.json();
      providerCatalog = (data?.providers || []).map((item) => ({
        ...item,
        service_state: item.service_state || null,
      }));
      if (!providerCatalog.length) {
        providerCatalog = FALLBACK_PROVIDERS.map((p) => ({
          ...p,
          status: p.status || { state: 'warn', detail: t('chat.fallback_detail') },
          service_state: p.service ? { unit: p.service, alias: p.service, active: 'inactive', sub: 'dead' } : null,
        }));
      }
      providerHint.textContent = t('chat_pc.select_provider');
    } catch (err) {
      console.warn('voice providers list failed', err);
      providerCatalog = FALLBACK_PROVIDERS.map((p) => ({
        ...p,
        status: { state: 'warn', detail: t('chat_pc.offline_mode_detail') },
        service_state: p.service ? { unit: p.service, alias: p.service, active: 'inactive', sub: 'dead' } : null,
      }));
      providerHint.textContent = t('chat_pc.provider_offline');
    }
    renderProviderSelect();
    renderProviderList();
  }

  function buildTtsPayload(text) {
    const provider = getSelectedProvider();
    if (!provider) {
      return { text, backend: 'piper', voice: 'pl_PL-gosia-medium.onnx' };
    }
    const payload = {
      text,
      backend: provider.backend || provider.id,
      provider: provider.id,
    };
    if (provider.voice) payload.voice = provider.voice;
    if (provider.model) payload.model = provider.model;
    return payload;
  }

  async function runProviderChecks(ids) {
    if (!ids || !ids.length) return;
    const res = await fetch('/api/voice/providers/test', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ providers: ids }),
    });
    if (!res.ok) {
      const errText = await res.text().catch(() => `${res.status} ${res.statusText}`);
      throw new Error(`Providers HTTP ${res.status}: ${errText}`);
    }
    const data = await res.json();
    for (const item of data.results || []) {
      updateProviderStatus(item.id, item);
    }
    return data;
  }

  async function serviceAction(alias, action) {
    if (!alias) throw new Error(t('chat_pc.unknown_alias'));
    const res = await fetch(`/svc/${encodeURIComponent(alias)}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ action }),
    });
    if (!res.ok) {
      const txt = await res.text().catch(() => `${res.status} ${res.statusText}`);
      throw new Error(`svc ${alias} ${action}: ${txt}`);
    }
    return res.json();
  }

  async function handleServiceAction(provider, action, button) {
    if (!provider?.service) return;
    const original = button.textContent;
    button.disabled = true;
    button.textContent = action === 'start' ? t('chat.starting') : t('chat.stopping');
    try {
      const data = await serviceAction(provider.service, action);
      if (data?.status) {
        provider.service_state = data.status;
      }
      setProviderHint(getSelectedProvider());
    } catch (err) {
      if (providerHint) providerHint.textContent = `${t('system_ui.node_title')} ${provider.service}: ${err.message || err}`;
    } finally {
      button.disabled = false;
      button.textContent = original;
      renderProviderList();
    }
  }

  // Mode selection
  function setMode(mode) {
    currentMode = mode;
    [modePCBtn, modeAutoBtn, modeProxyBtn].forEach(btn => btn.classList.remove('active'));
    if (mode === 'pc') modePCBtn.classList.add('active');
    else if (mode === 'auto') modeAutoBtn.classList.add('active');
    else if (mode === 'proxy') modeProxyBtn.classList.add('active');
    localStorage.setItem('chat_pc_mode', mode);
  }

  // Provider status
  async function refreshProviderStatus() {
    if (auditMode) {
      provStatus.textContent = t('chat_pc.ready');
      provModel.textContent = 'llama3.2:1b (mock)';
      provEngine.textContent = 'mock';
      if (provBackend) provBackend.textContent = t('chat_pc.backend_local');
      providerReady = true;
      setSourceBadge('pc', true);
      return;
    }
    try {
      const res = await fetch('/api/providers/text', { cache: 'no-store' });
      const data = await res.json();
      providerReady = data.initialized === true;
      provStatus.textContent = data.status || (providerReady ? t('chat_pc.ready') : t('chat_pc.offline'));
      provModel.textContent = data.model || '‚Äî';
      provEngine.textContent = data.engine || '‚Äî';
      if (provBackend) {
        const backend = data.backend || 'local';
        provBackend.textContent = backendDisplayNames[backend] || backend;
      }
      updateChatBackendControl(data);
      setSourceBadge(currentMode === 'proxy' ? 'proxy' : 'pc', providerReady);

      // Disable PC mode if provider not ready
      if (!providerReady && currentMode === 'pc') {
        modePCBtn.disabled = true;
        setMode('auto');
      } else {
        modePCBtn.disabled = false;
      }
    } catch (err) {
      console.error('Provider status error:', err);
      provStatus.textContent = t('chat.status_error');
      providerReady = false;
      setSourceBadge('offline', false);
    }
  }

  function updateChatBackendControl(data) {
    if (!chatBackendControl || !chatBackendSelect || !chatBackendApply) return;
    const options = data.available_backends || [];
    if (!options.length) {
      chatBackendControl.hidden = true;
      return;
    }
    chatBackendControl.hidden = false;
    chatBackendSelect.innerHTML = '';
    options.forEach((backend) => {
      const opt = document.createElement('option');
      opt.value = backend;
      opt.textContent = backendDisplayNames[backend] || backend;
      chatBackendSelect.appendChild(opt);
    });
    const current = data.backend || options[0];
    chatBackendSelect.value = options.includes(current) ? current : options[0];
    chatBackendApply.disabled = false;
    if (chatBackendHint) chatBackendHint.textContent = '';
  }

  async function applyChatBackend(backend) {
    if (!backend || !chatBackendApply || !chatBackendSelect) return;
    chatBackendApply.disabled = true;
    chatBackendSelect.disabled = true;
    if (chatBackendHint) {
      chatBackendHint.textContent = t('chat_pc.backend_setting', {
        backend: backendDisplayNames[backend] || backend,
      });
    }
    try {
      const res = await fetch('/api/providers/text/backend', {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ backend })
      });
      const data = await res.json();
      if (!res.ok || data.error) throw new Error(data.error || `HTTP ${res.status}`);
      if (chatBackendHint) {
        chatBackendHint.textContent = t('chat_pc.backend_set', {
          backend: backendDisplayNames[data.backend] || data.backend,
        });
      }
      await refreshProviderStatus();
    } catch (err) {
      if (chatBackendHint) chatBackendHint.textContent = t('chat_pc.backend_set_error', { msg: err.message });
    } finally {
      chatBackendApply.disabled = false;
      chatBackendSelect.disabled = false;
    }
  }

  if (chatBackendApply && chatBackendSelect) {
    chatBackendApply.addEventListener('click', () => applyChatBackend(chatBackendSelect.value));
    chatBackendSelect.addEventListener('change', () => applyChatBackend(chatBackendSelect.value));
  }

  // Chat API
  async function callChat(promptText) {
    const endpoint = currentMode === 'pc' ? '/api/chat/pc/send' : '/api/chat/send';
    const payload = { msg: promptText, user: 'web-pc' };
    if (currentMode !== 'pc') payload.mode = currentMode;

    const t0 = performance.now();
    const res = await fetch(endpoint, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload),
    });
    const t1 = performance.now();
    latency.textContent = t('chat_pc.latency', { ms: (t1 - t0).toFixed(0) });

    if (!res.ok) {
      const errData = await res.json().catch((parseErr) => {
        console.warn(t('chat_pc.parse_error'), parseErr);
        return { error: `HTTP ${res.status}: ${res.statusText}` };
      });
      throw new Error(errData.error || errData.hint || `HTTP ${res.status}`);
    }
    return res.json();
  }

  async function speak(text) {
    const payload = buildTtsPayload(text);
    const t0 = performance.now();
    const res = await fetch('/api/voice/tts', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload),
    });
    if (!res.ok) throw new Error(`TTS HTTP ${res.status}`);
    const blob = await res.blob();
    const url = URL.createObjectURL(blob);
    const audio = new Audio(url);
    await audio.play().catch(() => {});
    setTimeout(() => URL.revokeObjectURL(url), 15000);
    if (payload.provider) {
      updateProviderStatus(payload.provider, {
        id: payload.provider,
        state: 'ok',
        detail: t('chat_pc.playback_ok'),
        latency_ms: Math.round(performance.now() - t0),
      });
    }
  }

  async function send() {
    const text = (input.value || '').trim();
    if (!text) return;
    input.value = '';
    setStatus(t('chat_pc.sending'), 'warn');
    sendBtn.disabled = true;

    appendMessage('you', text, false, null);
    save('you', text, false, null);

    try {
      const data = await callChat(text);
      const reply = data.reply || data.text || data.message || JSON.stringify(data);
      const source = data.source || 'unknown';
      appendMessage('bot', reply, false, source);
      save('bot', reply, false, source);
      setStatus(t('meta.ok'), 'ok');
      setSourceBadge(source, providerReady);

      if (ttsChk.checked) {
        try {
          await speak(reply);
        } catch (e) {
          appendMessage('bot', `${t('chat_pc.tts_error_prefix')}${e.message || e}`, true, null);
          const provider = getSelectedProvider();
          if (provider) {
            updateProviderStatus(provider.id, { id: provider.id, state: 'error', detail: e.message || e });
          }
        }
      }
    } catch (e) {
      const msg = e.message || String(e);
      const errMsg = t('chat_pc.error_prefix', { msg });
      appendMessage('bot', errMsg, true, null);
      save('bot', errMsg, true, null);
      setStatus(t('chat.status_error'), 'err');
    } finally {
      sendBtn.disabled = false;
      input.focus();
    }
  }

  // PR Assistant
  async function generatePrContent() {
    const draft = (prDraft.value || '').trim();
    if (!draft) {
      alert(t('chat_pc.pr_draft_required'));
      return;
    }
    btnGeneratePr.disabled = true;
    btnGeneratePr.textContent = t('chat_pc.generating');

    try {
      const res = await fetch('/api/chat/pc/generate-pr-content', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          draft,
          style: prStyle.value,
          language: prLang.value,
        }),
      });
      if (!res.ok) {
        const err = await res.json().catch(() => ({}));
        throw new Error(err.error || `HTTP ${res.status}`);
      }
      const data = await res.json();
      prTitle.textContent = data.title || '‚Äî';
      prDescription.value = data.description || '';
      prSummary.value = data.summary || '';
      prResult.hidden = false;
    } catch (e) {
      alert(t('chat_pc.generate_error', { msg: e.message || e }));
    } finally {
      btnGeneratePr.disabled = false;
      btnGeneratePr.textContent = t('chat_pc.generate_pr');
    }
  }

  function copyPrToClipboard() {
    const text = `# ${prTitle.textContent}\n\n${prDescription.value}\n\n## ${t('chat_pc.summary_title')}\n${prSummary.value}`;
    navigator.clipboard.writeText(text).then(
      () => {
        btnCopyPr.textContent = t('chat_pc.copy_success');
        setTimeout(() => { btnCopyPr.textContent = t('chat_pc.copy_button'); }, 2000);
      },
      () => alert(t('chat_pc.copy_failed'))
    );
  }

  // Knowledge base loading
  let knowledgeDocuments = [];
  async function loadKnowledgeDocuments() {
    if (auditMode) {
      prKnowledgeBase.innerHTML = `
        <option value="docs_pl/SZYBKI_START.md">SZYBKI_START.md (mock)</option>
        <option value="docs_pl/styleguide.md">styleguide.md (mock)</option>
      `;
      return;
    }
    try {
      const res = await fetch('/api/knowledge/documents', { cache: 'no-store' });
      const data = await res.json();
      if (data.ok && data.documents.length > 0) {
        knowledgeDocuments = data.documents;
        prKnowledgeBase.innerHTML = data.documents.map(doc =>
          `<option value="${doc.path}">${doc.name} (${doc.category})</option>`
        ).join('');
      } else {
        prKnowledgeBase.innerHTML = `<option value="">${t('chat_pc.documents_none')}</option>`;
      }
    } catch (err) {
      console.error('Knowledge documents error:', err);
      prKnowledgeBase.innerHTML = `<option value="">${t('chat_pc.documents_load_error')}</option>`;
    }
  }

  // PR Preview
  let previewData = null;
  async function previewPrChanges() {
    const draft = (prDraft.value || '').trim();
    if (!draft) {
      alert(t('chat_pc.pr_draft_required'));
      return;
    }
    btnPreviewPr.disabled = true;
    btnPreviewPr.textContent = t('chat_pc.preview_loading');

    // Pobierz wybrane dokumenty
    const selectedDocs = Array.from(prKnowledgeBase.selectedOptions).map(opt => opt.value).filter(v => v);

    try {
      const res = await fetch('/api/chat/pc/preview-pr-changes', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          draft,
          current_content: prDescription.value || '',
          knowledge_documents: selectedDocs,
          style: prStyle.value,
          language: prLang.value,
        }),
      });
      if (!res.ok) {
        const err = await res.json().catch(() => ({}));
        throw new Error(err.error || `HTTP ${res.status}`);
      }
      const data = await res.json();
      previewData = data;

      // Wy≈õwietl sugestie
      if (data.suggestions && data.suggestions.length > 0) {
        prSuggestions.innerHTML = `
          <h4>${t('chat_pc.suggestions_title')}</h4>
          <ul>${data.suggestions.map(s => `<li>${s}</li>`).join('')}</ul>
          <p class="c-hint">${t('chat_pc.knowledge_used', { count: data.knowledge_used || 0 })}</p>
        `;
      } else {
        prSuggestions.innerHTML = `<p class="c-hint">${t('chat_pc.no_suggestions')}</p>`;
      }
      prPreview.hidden = false;
      prResult.hidden = true;
    } catch (e) {
      alert(t('chat_pc.preview_error', { msg: e.message || e }));
    } finally {
      btnPreviewPr.disabled = false;
      btnPreviewPr.textContent = t('chat_pc.preview');
    }
  }

  function applyPreviewChanges() {
    if (!previewData || !previewData.preview) return;
    prTitle.textContent = previewData.preview.title || '‚Äî';
    prDescription.value = previewData.preview.description || '';
    prSummary.value = previewData.preview.summary || '';
    prPreview.hidden = true;
    prResult.hidden = false;
    previewData = null;
  }

  function discardPreview() {
    prPreview.hidden = true;
    previewData = null;
  }

  // Benchmark
  async function runBenchmark() {
    const promptsText = (benchmarkPrompts.value || '').trim();
    if (!promptsText) {
      alert(t('chat_pc.test_required'));
      return;
    }

    const prompts = promptsText.split('\n').map(p => p.trim()).filter(p => p);
    if (prompts.length === 0) {
      alert(t('chat_pc.test_required'));
      return;
    }

    btnRunBenchmark.disabled = true;
    btnRunBenchmark.textContent = t('chat_pc.benchmark_running');
    benchmarkResults.hidden = true;

    try {
      const res = await fetch('/api/benchmark/models', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          prompts,
          iterations: parseInt(benchmarkIterations.value, 10),
          max_tokens: parseInt(benchmarkMaxTokens.value, 10) || 256,
        }),
      });
      if (!res.ok) {
        const err = await res.json().catch(() => ({}));
        throw new Error(err.error || `HTTP ${res.status}`);
      }
      const data = await res.json();

      // Wype≈Çnij podsumowanie
      benchModel.textContent = data.summary.model || '‚Äî';
      benchEngine.textContent = data.summary.engine || '‚Äî';
      benchAvgLatency.textContent = `${data.summary.avg_latency_ms} ms`;
      benchSuccessRate.textContent = `${data.summary.successful_runs} / ${data.summary.total_iterations}`;
      benchTotalTokens.textContent = data.summary.total_tokens;

      // Wype≈Çnij szczeg√≥≈Çy
      let detailsHtml = '';
      for (const result of data.results) {
        detailsHtml += `<div class="chat-pc-card chat-pc-benchmark-item">
          <strong>Prompt:</strong> ${result.prompt}<br>
          <div class="chat-pc-benchmark-runs">`;
        for (const run of result.runs) {
          const statusClass = run.status === 'completed' ? 'chat-pc-benchmark-run--ok' : 'chat-pc-benchmark-run--err';
          detailsHtml += `<span class="chat-pc-benchmark-run ${statusClass}">
            #${run.iteration}: ${run.latency_ms}ms, ${run.tokens || 0} tok
          </span>`;
        }
        detailsHtml += '</div></div>';
      }
      benchmarkDetails.innerHTML = detailsHtml;
      benchmarkResults.hidden = false;

    } catch (e) {
      alert(t('chat_pc.benchmark_error', { msg: e.message || e }));
    } finally {
      btnRunBenchmark.disabled = false;
      btnRunBenchmark.textContent = t('chat_pc.run_benchmark');
    }
  }

  // Voice provider status
  async function refreshVoiceStatus() {
    if (auditMode) {
      voiceStatus.textContent = t('chat_pc.ready_mock');
      voiceAsrModel.textContent = 'base (mock)';
      voiceTtsModel.textContent = 'en_US-lessac-medium (mock)';
      voiceAsrAvailable.textContent = t('chat_pc.yes');
      voiceTtsAvailable.textContent = t('chat_pc.yes');
      voiceProviderReady = true;
      return;
    }
    try {
      const res = await fetch('/api/providers/voice', { cache: 'no-store' });
      const data = await res.json();
      voiceProviderReady = data.initialized === true;
      voiceStatus.textContent = data.status || (voiceProviderReady ? t('chat_pc.ready') : t('chat_pc.offline'));
      voiceAsrModel.textContent = data.asr_model || '‚Äî';
      voiceTtsModel.textContent = data.tts_model || '‚Äî';
      voiceAsrAvailable.textContent = data.asr_available ? t('chat_pc.yes') : t('chat_pc.no');
      voiceTtsAvailable.textContent = data.tts_available ? t('chat_pc.yes') : t('chat_pc.no');
      recordBtn.disabled = !voiceProviderReady;
    } catch (err) {
      console.error('Voice status error:', err);
      voiceStatus.textContent = t('chat.status_error');
      voiceProviderReady = false;
      recordBtn.disabled = true;
    }
  }

  // ASR (Speech-to-Text) - nagrywanie mowy
  async function startRecording() {
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
      alert(t('chat_pc.mic_unsupported'));
      return;
    }
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
      audioChunks = [];

      mediaRecorder.ondataavailable = (e) => {
        if (e.data.size > 0) audioChunks.push(e.data);
      };

      mediaRecorder.onstop = async () => {
        stream.getTracks().forEach(track => track.stop());
        const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
        await transcribeAudio(audioBlob);
      };

      mediaRecorder.start();
      isRecording = true;
      recordBtn.textContent = t('chat_pc.record_stop');
      recordBtn.classList.add('is-recording');
      setStatus(t('chat_pc.recording'), 'warn');
    } catch (err) {
      console.error('Recording error:', err);
      alert(t('chat_pc.mic_access_error', { msg: err.message }));
    }
  }

  function stopRecording() {
    if (mediaRecorder && mediaRecorder.state !== 'inactive') {
      mediaRecorder.stop();
    }
    isRecording = false;
    recordBtn.textContent = t('chat_pc.record_button');
    recordBtn.classList.remove('is-recording');
    setStatus(t('chat_pc.processing'), 'warn');
  }

  async function transcribeAudio(audioBlob) {
    try {
      // Convert blob to base64
      const reader = new FileReader();
      reader.readAsDataURL(audioBlob);
      const base64Audio = await new Promise((resolve) => {
        reader.onloadend = () => resolve(reader.result.split(',')[1]);
      });

      const res = await fetch('/api/voice/asr', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          audio_data: base64Audio,
          format: 'webm',
        }),
      });
      const data = await res.json();
      if (data.ok && data.text) {
        input.value = (input.value ? input.value + ' ' : '') + data.text;
        setStatus(t('chat_pc.speech_recognized'), 'ok');
        latency.textContent = t('chat_pc.asr_latency', { ms: data.latency_ms || 0 });
      } else {
        setStatus(t('chat_pc.asr_not_recognized', { msg: data.error || t('chat.status_error') }), 'err');
      }
    } catch (err) {
      console.error('ASR error:', err);
      setStatus(t('chat_pc.asr_error', { msg: err.message }), 'err');
    }
  }

  function toggleRecording() {
    if (isRecording) {
      stopRecording();
    } else {
      startRecording();
    }
  }

  // Event listeners
  sendBtn.addEventListener('click', send);
  input.addEventListener('keydown', (ev) => {
    if (ev.key === 'Enter' && !ev.shiftKey) {
      ev.preventDefault();
      send();
    }
  });

  recordBtn.addEventListener('click', toggleRecording);

  modePCBtn.addEventListener('click', () => setMode('pc'));
  modeAutoBtn.addEventListener('click', () => setMode('auto'));
  modeProxyBtn.addEventListener('click', () => setMode('proxy'));

  btnRefreshStatus.addEventListener('click', refreshProviderStatus);

  btnToggleVoiceStatus.addEventListener('click', () => {
    const isHidden = voiceStatusContent.hidden;
    voiceStatusContent.hidden = !isHidden;
    btnToggleVoiceStatus.textContent = isHidden ? t('chat_pc.collapse') : t('chat_pc.expand');
    if (isHidden) refreshVoiceStatus();
  });

  btnRefreshVoiceStatus.addEventListener('click', refreshVoiceStatus);

  providerSelect?.addEventListener('change', () => {
    localStorage.setItem('chat_pc_tts_provider', providerSelect.value);
    setProviderHint(getSelectedProvider());
  });
  btnReloadProviders?.addEventListener('click', (event) => {
    event.preventDefault();
    loadProviders();
  });
  btnTestAll?.addEventListener('click', (event) => {
    event.preventDefault();
    if (!providerCatalog.length) return;
    btnTestAll.disabled = true;
    btnTestAll.textContent = t('chat.testing');
    runProviderChecks(providerCatalog.map((p) => p.id))
      .catch((err) => { if (providerHint) providerHint.textContent = err.message || err; })
      .finally(() => {
        btnTestAll.disabled = false;
        btnTestAll.textContent = t('voice.test_all');
      });
  });

  btnTogglePrAssistant.addEventListener('click', () => {
    const isHidden = prAssistantContent.hidden;
    prAssistantContent.hidden = !isHidden;
    btnTogglePrAssistant.textContent = isHidden ? t('chat_pc.collapse') : t('chat_pc.expand');
    if (isHidden) loadKnowledgeDocuments();
  });

  btnGeneratePr.addEventListener('click', generatePrContent);
  btnCopyPr.addEventListener('click', copyPrToClipboard);
  btnPreviewPr.addEventListener('click', previewPrChanges);
  btnApplyPreview.addEventListener('click', applyPreviewChanges);
  btnDiscardPreview.addEventListener('click', discardPreview);

  // Benchmark event listeners
  btnToggleBenchmark.addEventListener('click', () => {
    const isHidden = benchmarkContent.hidden;
    benchmarkContent.hidden = !isHidden;
    btnToggleBenchmark.textContent = isHidden ? t('chat_pc.collapse') : t('chat_pc.expand');
  });
  btnRunBenchmark.addEventListener('click', runBenchmark);

  // Audit mode placeholders
  if (auditMode && history.length === 0) {
    appendMessage('you', t('chat_pc.sample_user_pc'), false, null);
    appendMessage('bot', t('chat_pc.sample_bot_pc'), false, 'pc');
    appendMessage('bot', t('chat_pc.sample_error_pc'), true, null);
    latency.textContent = t('chat_pc.latency', { ms: 127 });
    setStatus(t('chat.audit_mode'), 'warn');
  }

  // Initialize
  const storedMode = localStorage.getItem('chat_pc_mode');
  if (storedMode && ['pc', 'auto', 'proxy'].includes(storedMode)) {
    setMode(storedMode);
  } else {
    setMode('pc');
  }
  setStatus(t('chat_pc.ready_label'), 'ok');
  input.focus();
  refreshProviderStatus();
  refreshVoiceStatus();
  loadProviders();
})();
</script>
<script type="module" src="/web/assets/menu.js"></script>
<script type="module" src="/web/assets/footer.js"></script>
</body>
</html>
