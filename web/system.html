<!doctype html>
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>System Dashboard – usługi Rider-PC</title>
  <link rel="stylesheet" href="/web/assets/dashboard-common.css">
  <link rel="stylesheet" href="/web/assets/system.css">
</head>
<body data-page="system">
<div data-dashboard-menu-target></div>
<div class="system-shell">
  <header>
    <div class="header-main">
      <h1>System Dashboard – usługi <span class="brand-accent">Rider-PC</span></h1>
      <div id="version-info" class="version-info" title="Informacje o wersji">
        <span class="version-loading">Wczytywanie wersji...</span>
      </div>
    </div>
    <nav class="system-links">
      <a href="/web/view.html">Podgląd</a>
      <a href="/web/control.html">Sterowanie</a>
    </nav>
  </header>
  <p id="status-line">Ładowanie danych usług…</p>
  <section id="system-graph"></section>
  
  <section class="log-panel">
    <header class="log-header">
      <h2>Log Systemowy</h2>
      <button id="log-clear-btn" class="btn btn-sm" title="Wyczyść log">Wyczyść</button>
    </header>
    <div id="log-terminal" class="log-terminal" role="log" aria-live="polite" aria-label="Log systemowy">
      <div class="log-entry log-info"><span class="log-timestamp">[--:--:--]</span> <span class="log-level">INFO</span> Oczekiwanie na zdarzenia...</div>
    </div>
  </section>
</div>
<div id="toast-container"></div>

  <script>
    const graphEl = document.getElementById('system-graph');
    const statusEl = document.getElementById('status-line');
    const toastContainer = document.getElementById('toast-container');

    function statusClass(status) {
      switch ((status || '').toLowerCase()) {
        case 'active':
          return 'status-running';
        case 'failed':
          return 'status-failed';
        case 'inactive':
          return 'status-inactive';
        default:
          return 'status-unknown';
      }
    }

    function nodeStateClass(status) {
      switch ((status || '').toLowerCase()) {
        case 'active':
          return 'is-active';
        case 'failed':
          return 'is-failed';
        case 'inactive':
          return 'is-inactive';
        default:
          return '';
      }
    }

    // Internationalization helper
    function getTooltipText(status) {
      const lang = document.documentElement.lang || 'pl';
      const texts = {
        pl: {
          stop: 'Kliknij, aby zatrzymać usługę',
          start: 'Kliknij, aby uruchomić usługę'
        },
        en: {
          stop: 'Click to stop service',
          start: 'Click to start service'
        }
      };
      const langTexts = texts[lang] || texts['en'];
      return status === 'active' ? langTexts.stop : langTexts.start;
    }

    function formatSince(value) {
      if (!value) return 'n/a';
      return value;
    }

    function showToast(message, type = 'success') {
      const toast = document.createElement('div');
      toast.className = `toast ${type}`;
      toast.textContent = message;
      toastContainer.appendChild(toast);
      setTimeout(() => {
        toast.remove();
      }, 3000);
    }

    async function toggleService(unit, currentStatus) {
      // Determine action based on current status
      const action = currentStatus === 'active' ? 'stop' : 'start';
      const card = document.querySelector(`[data-unit="${unit}"]`);
      
      if (card) {
        card.classList.add('is-busy');
        card.setAttribute('aria-busy', 'true');
      }

      try {
        const resp = await fetch(`/svc/${encodeURIComponent(unit)}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ action }),
        });

        const result = await resp.json();

        if (resp.ok && result.ok) {
          showToast(`Usługa ${unit}: ${action === 'start' ? 'uruchomiona' : 'zatrzymana'}`, 'success');
          // Refresh graph to show updated state
          await loadGraph();
        } else {
          showToast(`Błąd: ${result.error || 'Nie udało się zmienić stanu usługi'}`, 'error');
        }
      } catch (err) {
        console.error('Toggle service error:', err);
        showToast(`Błąd połączenia: ${err.message}`, 'error');
      } finally {
        if (card) {
          card.classList.remove('is-busy');
          card.setAttribute('aria-busy', 'false');
        }
      }
    }

    function renderGraph(nodes, edges) {
      graphEl.innerHTML = '';
      if (!nodes.length) {
        graphEl.innerHTML = '<p>Brak danych usług.</p>';
        return;
      }
      const groups = new Map();
      nodes.forEach((node) => {
        const bucket = groups.get(node.group) || [];
        bucket.push(node);
        groups.set(node.group, bucket);
      });
      const sortedGroups = Array.from(groups.entries()).sort((a, b) => a[0].localeCompare(b[0]));
      const groupFragments = [];
      sortedGroups.forEach(([group, items]) => {
        items.sort((a, b) => a.label.localeCompare(b.label));
        items.forEach((node) => {
          const card = document.createElement('article');
          const stateClass = nodeStateClass(node.status);
          card.className = `service-node ${stateClass}`;
          card.setAttribute('data-unit', node.unit);
          card.setAttribute('data-status', node.status || 'unknown');
          card.setAttribute('title', getTooltipText(node.status));
          card.setAttribute('role', 'button');
          card.setAttribute('aria-label', `${node.label}: ${getTooltipText(node.status)}`);
          
          // Add click handler for toggling service
          card.addEventListener('click', () => {
            toggleService(node.unit, node.status);
          });

          const header = document.createElement('div');
          const title = document.createElement('h2');
          title.textContent = node.label;
          header.appendChild(title);
          const pill = document.createElement('span');
          pill.className = `status-pill ${statusClass(node.status)}`;
          pill.textContent = node.status || 'unknown';
          header.appendChild(pill);
          card.appendChild(header);

          const unit = document.createElement('div');
          unit.textContent = `Unit: ${node.unit}`;
          unit.className = 'desc';
          card.appendChild(unit);

          const info = document.createElement('div');
          info.textContent = `Grupa: ${group}`;
          info.className = 'desc';
          card.appendChild(info);

          if (node.since) {
            const since = document.createElement('div');
            since.textContent = `Aktywny od: ${formatSince(node.since)}`;
            since.className = 'desc';
            card.appendChild(since);
          }

          if (node.edges_out && node.edges_out.length) {
            const label = document.createElement('div');
            label.textContent = 'Połączenia →';
            label.className = 'desc';
            card.appendChild(label);
            const list = document.createElement('div');
            list.className = 'edge-list';
            node.edges_out.forEach((target) => {
              const chip = document.createElement('span');
              chip.textContent = target;
              list.appendChild(chip);
            });
            card.appendChild(list);
          }

          groupFragments.push(card);
        });
      });
      groupFragments.forEach((fragment) => graphEl.appendChild(fragment));
    }

    async function loadGraph() {
      try {
        statusEl.textContent = 'Aktualizuję status usług…';
        const resp = await fetch(`/api/services/graph?ts=${Date.now()}`, { cache: 'no-store' });
        if (!resp.ok) {
          throw new Error(`HTTP ${resp.status}`);
        }
        const payload = await resp.json();
        renderGraph(payload.nodes || [], payload.edges || []);
        const ts = payload.generated_at ? new Date(payload.generated_at * 1000) : new Date();
        statusEl.textContent = `Ostatnia aktualizacja: ${ts.toLocaleTimeString()}`;
      } catch (err) {
        console.error(err);
        statusEl.textContent = 'Błąd podczas pobierania danych usług.';
      }
    }

    loadGraph();
    setInterval(loadGraph, 5000);

    // Log Panel functionality
    const logTerminal = document.getElementById('log-terminal');
    const logClearBtn = document.getElementById('log-clear-btn');
    const MAX_LOG_ENTRIES = 100;
    const SSE_RECONNECT_DELAY_MS = 3000;

    function formatTimestamp(ts) {
      const date = ts ? new Date(ts * 1000) : new Date();
      return date.toLocaleTimeString('pl-PL', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
    }

    function getLevelClass(level) {
      switch ((level || '').toUpperCase()) {
        case 'INFO':
          return 'log-info';
        case 'WARN':
        case 'WARNING':
          return 'log-warn';
        case 'ERROR':
          return 'log-error';
        default:
          return 'log-info';
      }
    }

    function addLogEntry(level, message, ts) {
      const entry = document.createElement('div');
      entry.className = `log-entry ${getLevelClass(level)}`;
      entry.innerHTML = `<span class="log-timestamp">[${formatTimestamp(ts)}]</span> <span class="log-level">${(level || 'INFO').toUpperCase()}</span> ${escapeHtml(message)}`;
      logTerminal.appendChild(entry);

      // Remove old entries if exceeding max
      while (logTerminal.children.length > MAX_LOG_ENTRIES) {
        logTerminal.removeChild(logTerminal.firstChild);
      }

      // Auto-scroll to bottom
      logTerminal.scrollTop = logTerminal.scrollHeight;
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function clearLog() {
      logTerminal.innerHTML = '';
      addLogEntry('INFO', 'Log wyczyszczony. Oczekiwanie na zdarzenia...', Date.now() / 1000);
    }

    logClearBtn.addEventListener('click', clearLog);

    // SSE connection for live log updates
    let eventSource = null;

    function connectSSE() {
      if (eventSource) {
        eventSource.close();
      }

      eventSource = new EventSource('/events');

      eventSource.onopen = function() {
        console.log('SSE connected');
      };

      eventSource.onmessage = function(event) {
        try {
          const payload = JSON.parse(event.data);
          if (payload.topic === 'system.log') {
            const data = payload.data || {};
            addLogEntry(data.level, data.message, payload.ts);
          }
        } catch (err) {
          console.error('Error parsing SSE event:', err);
        }
      };

      eventSource.onerror = function(err) {
        console.error('SSE error:', err);
        // Reconnect after delay
        setTimeout(connectSSE, SSE_RECONNECT_DELAY_MS);
      };
    }

    connectSSE();

    // Cleanup on page unload
    window.addEventListener('beforeunload', function() {
      if (eventSource) {
        eventSource.close();
      }
    });

    // Version info functionality
    const versionInfoEl = document.getElementById('version-info');

    function renderVersionInfo(data) {
      if (!data || !data.available) {
        versionInfoEl.innerHTML = '<span class="version-unavailable">v. Unknown</span>';
        versionInfoEl.title = 'Informacje o wersji niedostępne';
        return;
      }

      const branchBadge = document.createElement('span');
      branchBadge.className = 'version-branch';
      branchBadge.textContent = data.branch || 'unknown';

      const commitHash = document.createElement('span');
      commitHash.className = 'version-commit';
      commitHash.textContent = '#' + (data.commit || 'unknown');
      commitHash.title = 'Kliknij, aby skopiować hash';
      commitHash.style.cursor = 'pointer';
      commitHash.addEventListener('click', function(e) {
        e.stopPropagation();
        const hash = data.commit || '';
        if (hash && navigator.clipboard) {
          navigator.clipboard.writeText(hash).then(function() {
            showToast('Skopiowano hash: ' + hash, 'success');
          }).catch(function() {
            showToast('Nie udało się skopiować', 'error');
          });
        }
      });

      versionInfoEl.innerHTML = '';
      versionInfoEl.appendChild(branchBadge);
      versionInfoEl.appendChild(commitHash);

      if (data.dirty) {
        const dirtyBadge = document.createElement('span');
        dirtyBadge.className = 'version-dirty';
        dirtyBadge.textContent = 'Zmodyfikowany';
        dirtyBadge.title = 'Kod zmodyfikowany lokalnie (niezatwierdzone zmiany)';
        versionInfoEl.appendChild(dirtyBadge);
      }

      versionInfoEl.title = data.message ? ('Ostatni commit: ' + data.message) : 'Informacje o wersji';
    }

    async function loadVersionInfo() {
      try {
        const resp = await fetch('/api/status/version', { cache: 'no-store' });
        if (!resp.ok) {
          throw new Error('HTTP ' + resp.status);
        }
        const data = await resp.json();
        renderVersionInfo(data);
      } catch (err) {
        console.error('Failed to load version info:', err);
        versionInfoEl.innerHTML = '<span class="version-unavailable">v. Unknown</span>';
      }
    }

    // Load version info on page load (server caches for 60s, refresh on page reload)
    loadVersionInfo();
  </script>
  <script type="module" src="/web/assets/menu.js"></script>
</body>
</html>
