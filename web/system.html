<!doctype html>
<!--
  Migrated to dashboard_base.html template structure
  Uses shared layout classes: .layout-header, .layout-main, .layout-footer
-->
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Rider-PC: System Dashboard</title>
  <link rel="stylesheet" href="/web/assets/dashboard-common.css">
  <link rel="stylesheet" href="/web/assets/pages/system.css">
</head>
<body data-page="system" class="page page-system">
  <!-- Header with Menu -->
  <header class="layout-header" data-dashboard-menu-target></header>

  <!-- Main content -->
  <main class="layout-main">
    <!-- Page header -->
    <header class="page-header">
      <div class="page-header__titles">
        <h1 class="page-title"><span class="brand-accent">Rider-PC</span>: <span class="page-title-text">System Dashboard</span></h1>
        <div id="version-info" class="version-info text-legend" title="Informacje o wersji">
          <span class="version-loading">Wczytywanie wersji...</span>
        </div>
      </div>
      <div class="page-header__actions page-header__actions--small system-links text-legend">
        <a href="/view">Podgląd</a>
        <a href="/control">Sterowanie</a>
      </div>
    </header>
    <p id="status-line" class="status-line c-statusbar">Ładowanie danych usług…</p>
  
  <section class="c-card c-section system-section is-network" id="network-status-block">
    <h2 class="c-card__title">Status Sieci</h2>
    <div class="network-status-grid">
      <div class="network-card c-card" id="local-ip-card">
        <div class="network-card-header">
          <span class="network-label">IP Hosta</span>
        </div>
        <div class="network-value" id="local-ip-value">---.---.---.---</div>
      </div>
      <div class="network-card c-card" id="rider-pi-card">
        <div class="network-card-header">
          <span class="network-label">Rider-Pi</span>
          <span class="network-status-indicator" id="rider-pi-indicator"></span>
        </div>
        <div class="network-value">
          <span id="rider-pi-status">Sprawdzanie...</span>
          <span class="network-latency" id="rider-pi-latency"></span>
        </div>
        <div class="network-host" id="rider-pi-host"></div>
      </div>
      <div class="network-card c-card" id="internet-card">
        <div class="network-card-header">
          <span class="network-label">Internet</span>
          <span class="network-status-indicator" id="internet-indicator"></span>
        </div>
        <div class="network-value">
          <span id="internet-status">Sprawdzanie...</span>
          <span class="network-latency" id="internet-latency"></span>
        </div>
        <div class="network-host" id="internet-host">—</div>
      </div>
    </div>
  </section>
  
  <section class="c-card c-section system-section is-pc" id="pc-services-block">
    <h2 class="c-card__title">Usługi lokalne (PC)</h2>
    <div id="pc-services-graph" class="services-grid l-grid"></div>
  </section>
  
  <section class="c-card c-section system-section is-pi" id="pi-services-block">
    <h2 class="c-card__title">Usługi na Rider-Pi</h2>
    <div id="pi-services-graph" class="services-grid l-grid"></div>
  </section>
  
  <template id="service-card-template">
    <article class="service-node c-card" data-unit="" data-status="">
      <header class="service-node__head">
        <h3 class="service-node__title" data-role="title"></h3>
        <span class="c-pill" data-role="pill"></span>
      </header>
      <p class="desc service-node__unit" data-role="unit"></p>
      <p class="desc service-node__group" data-role="group"></p>
      <p class="desc service-node__since" data-role="since" hidden></p>
      <p class="desc service-node__edges-label" data-role="edges-label" hidden>Połączenia →</p>
      <div class="edge-list" data-role="edges" hidden></div>
      <div class="service-node__spinner" aria-hidden="true"></div>
    </article>
  </template>
  
  <section class="log-panel surface c-card">
    <header class="log-header l-cluster">
      <h2 class="section-title">Log Systemowy</h2>
      <div class="u-spacer"></div>
      <button id="log-clear-btn" class="c-btn c-btn-sm" title="Wyczyść log">Wyczyść</button>
    </header>
    <div id="log-terminal" class="log-terminal" role="log" aria-live="polite" aria-label="Log systemowy">
      <div class="log-entry log-info"><span class="log-timestamp">[--:--:--]</span> <span class="log-level">INFO</span> Oczekiwanie na zdarzenia...</div>
    </div>
  </section>
  </main>

  <!-- Ukryty podgląd klas systemowych (dla pokrycia CSS) -->
  <div class="system-style-preview" aria-hidden="true" hidden>
    <div class="version-info">
      <span class="version-loading">Ładowanie...</span>
      <span class="version-unavailable">Brak danych</span>
      <span class="version-branch">main</span>
      <span class="version-commit version-dirty">#abcd123</span>
    </div>
    <div class="system-links">
      <a href="#">Link przykładowy</a>
    </div>
    <section class="system-section is-network c-card">
      <div class="services-grid">
        <article class="service-node is-active">
          <div class="service-node__head">
            <h3 class="service-node__title">Usługa</h3>
            <span class="status-pill is-ok">OK</span>
          </div>
          <p class="service-node__unit">example.service</p>
          <p class="service-node__group">group</p>
          <p class="service-node__since">Od 10:00</p>
          <p class="service-node__edges-label">Łącza</p>
          <div class="edge-list"><span>edge-1</span></div>
          <p class="desc">Opis testowy</p>
          <div class="service-node__spinner"></div>
        </article>
        <article class="service-node is-failed">
          <div class="service-node__head">
            <h3 class="service-node__title">Błąd</h3>
            <span class="status-pill is-err">ERR</span>
          </div>
        </article>
      </div>
    </section>
    <div class="status-pill is-warn" hidden>WARN</div>
    <div class="status-pill is-off" hidden>OFF</div>
    <div class="network-status-grid">
      <div class="network-card is-online">
        <div class="network-card-header">
          <span class="network-label">LAN</span>
          <span class="network-status-indicator is-online"></span>
        </div>
        <div class="network-value">192.168.0.10</div>
        <div class="network-latency">12 ms</div>
        <div class="network-host">host.local</div>
      </div>
      <div class="network-card is-offline">
        <div class="network-card-header">
          <span class="network-label">Internet</span>
          <span class="network-status-indicator is-offline"></span>
        </div>
      </div>
    </div>
    <section class="log-panel">
      <div class="log-entry log-info">
        <span class="log-timestamp">12:00:00</span>
        <span class="log-level">INFO</span>
        <span class="log-message">Podgląd stylu</span>
      </div>
      <div class="log-entry log-warn">
        <span class="log-timestamp">12:01:00</span>
        <span class="log-level">WARN</span>
      </div>
      <div class="log-entry log-error">
        <span class="log-timestamp">12:02:00</span>
        <span class="log-level">ERR</span>
      </div>
    </section>
  </div>

  <!-- Footer -->
  <footer class="layout-footer" data-dashboard-footer-target></footer>

  <script>
    const docLang = (document.documentElement.lang || 'pl').toLowerCase().startsWith('en') ? 'en' : 'pl';
    const SERVICE_STATUS_LABELS = {
      active:   { pl: 'aktywna',    en: 'active' },
      inactive: { pl: 'nieaktywna', en: 'inactive' },
      failed:   { pl: 'błąd',       en: 'failed' },
      starting: { pl: 'uruchamianie', en: 'starting' },
      stopping: { pl: 'zatrzymywanie', en: 'stopping' },
      warning:  { pl: 'ostrzeżenie', en: 'warning' },
      unknown:  { pl: 'nieznany',   en: 'unknown' }
    };
    const SERVICE_LABELS = {
      unit:  { pl: 'Jednostka', en: 'Unit' },
      group: { pl: 'Grupa',     en: 'Group' },
      since: { pl: 'Aktywny od', en: 'Active since' },
      edges: { pl: 'Połączenia →', en: 'Connections →' }
    };
    const serviceCardTemplate = document.getElementById('service-card-template');
    const pcGraphEl = document.getElementById('pc-services-graph');
    const piGraphEl = document.getElementById('pi-services-graph');
    const pcBlockEl = document.getElementById('pc-services-block');
    const piBlockEl = document.getElementById('pi-services-block');
    const statusEl = document.getElementById('status-line');
    const versionInfoEl = document.getElementById('version-info');
    const logTerminal = document.getElementById('log-terminal');
    const logClearBtn = document.getElementById('log-clear-btn');
    const urlParams = new URLSearchParams(window.location.search);
    const auditMode = urlParams.get('audit') === '1';

    const defaultNetworkConfig = {
      riderPiHost: '',
      riderPiPort: 8080,
      internetHost: '8.8.8.8',
      pcHost: '',
    };
    let networkConfig = { ...defaultNetworkConfig };

    async function fetchNetworkConfig() {
      try {
        const resp = await fetch('/api/config/network', { cache: 'no-store' });
        if (!resp.ok) {
          return;
        }
        const data = await resp.json();
        networkConfig = {
          riderPiHost: data.rider_pi_host || networkConfig.riderPiHost,
          riderPiPort: typeof data.rider_pi_port === 'number' ? data.rider_pi_port : networkConfig.riderPiPort,
          internetHost: data.internet_probe_host || networkConfig.internetHost,
          pcHost: data.pc_host || networkConfig.pcHost,
        };
      } catch (err) {
        console.warn('Failed to load network config:', err);
      }
    }

    const networkConfigPromise = fetchNetworkConfig();

    function statusClass(status) {
      switch ((status || '').toLowerCase()) {
        case 'active':
          return 'is-ok';
        case 'failed':
          return 'is-err';
        case 'inactive':
          return 'is-off';
        default:
          return 'is-warn';
      }
    }

    function nodeStateClass(status) {
      switch ((status || '').toLowerCase()) {
        case 'active':
          return 'is-active';
        case 'failed':
          return 'is-failed';
        case 'inactive':
          return 'is-inactive';
        default:
          return '';
      }
    }

    // Internationalization helper
    function getTooltipText(status) {
      const lang = document.documentElement.lang || 'pl';
      const texts = {
        pl: {
          stop: 'Kliknij, aby zatrzymać usługę',
          start: 'Kliknij, aby uruchomić usługę'
        },
        en: {
          stop: 'Click to stop service',
          start: 'Click to start service'
        }
      };
      const langTexts = texts[lang] || texts['en'];
      return status === 'active' ? langTexts.stop : langTexts.start;
    }

    function formatSince(value) {
      if (!value) return 'n/a';
      return value;
    }

    function ensureToastHost() {
      let host = document.querySelector('[data-toast-host]');
      if (!host) {
        host = document.createElement('div');
        host.dataset.toastHost = 'true';
        host.style.position = 'fixed';
        host.style.bottom = 'var(--space-xl)';
        host.style.right = 'var(--space-xl)';
        host.style.display = 'flex';
        host.style.flexDirection = 'column';
        host.style.gap = 'var(--space-md)';
        host.style.zIndex = '1000';
        document.body.appendChild(host);
      }
      return host;
    }

    function showToast(message, type = 'success') {
      const host = ensureToastHost();
      const toast = document.createElement('div');
      toast.className = 'c-status-msg';
      toast.textContent = message;
      toast.style.minWidth = '220px';
      toast.style.maxWidth = '360px';
      toast.style.cursor = 'pointer';
      if (type === 'error') {
        toast.style.borderColor = 'var(--color-error-border)';
        toast.style.color = 'var(--color-error)';
      } else if (type === 'warn') {
        toast.style.borderColor = 'var(--color-warn-border)';
        toast.style.color = 'var(--color-warn)';
      } else {
        toast.style.borderColor = 'var(--color-ok-border)';
        toast.style.color = 'var(--color-ok)';
      }
      host.appendChild(toast);
      const remove = () => toast.remove();
      setTimeout(remove, 3200);
      toast.addEventListener('click', remove);
    }

    async function toggleService(unit, currentStatus) {
      // Determine action based on current status
      const action = currentStatus === 'active' ? 'stop' : 'start';
      const card = document.querySelector(`[data-unit="${unit}"]`);
      
      if (card) {
        card.classList.add('is-busy');
        card.setAttribute('aria-busy', 'true');
      }

      try {
        const resp = await fetch(`/svc/${encodeURIComponent(unit)}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ action }),
        });

        const result = await resp.json();

        if (resp.ok && result.ok) {
          showToast(`Usługa ${unit}: ${action === 'start' ? 'uruchomiona' : 'zatrzymana'}`, 'success');
          // Refresh graph to show updated state
          await loadGraph();
        } else {
          showToast(`Błąd: ${result.error || 'Nie udało się zmienić stanu usługi'}`, 'error');
        }
      } catch (err) {
        console.error('Toggle service error:', err);
        showToast(`Błąd połączenia: ${err.message}`, 'error');
      } finally {
        if (card) {
          card.classList.remove('is-busy');
          card.setAttribute('aria-busy', 'false');
        }
      }
    }

    function createServiceCard(node, group) {
      const labelGroup = group || 'services';
      let card;
      if (serviceCardTemplate && serviceCardTemplate.content?.firstElementChild) {
        card = serviceCardTemplate.content.firstElementChild.cloneNode(true);
      } else {
        card = document.createElement('article');
        card.className = 'service-node c-card';
        card.appendChild(document.createElement('div')).className = 'service-node__spinner';
      }
      const stateClass = nodeStateClass(node.status);
      card.classList.remove('is-active', 'is-failed', 'is-inactive');
      if (stateClass) card.classList.add(stateClass);
      card.setAttribute('data-unit', node.unit);
      card.setAttribute('data-status', node.status || 'unknown');
      card.setAttribute('data-location', node.location || 'pc');
      card.setAttribute('title', getTooltipText(node.status));
      card.setAttribute('role', 'button');
      card.setAttribute('aria-label', `${node.label}: ${getTooltipText(node.status)}`);
      
      const titleEl = card.querySelector('[data-role="title"]') || card.querySelector('.service-node__title');
      if (titleEl) titleEl.textContent = node.label;
      
      const pillEl = card.querySelector('[data-role="pill"]');
      if (pillEl) {
        const statusKey = (node.status || 'unknown').toLowerCase();
        const pillText = SERVICE_STATUS_LABELS[statusKey]?.[docLang] || SERVICE_STATUS_LABELS.unknown[docLang];
        pillEl.textContent = pillText;
        pillEl.className = `status-pill ${statusClass(node.status)}`;
      }
      
      const unitEl = card.querySelector('[data-role="unit"]');
      if (unitEl) unitEl.textContent = `${SERVICE_LABELS.unit[docLang]}: ${node.unit}`;
      
      const groupEl = card.querySelector('[data-role="group"]');
      if (groupEl) groupEl.textContent = `${SERVICE_LABELS.group[docLang]}: ${labelGroup}`;
      
      const sinceEl = card.querySelector('[data-role="since"]');
      if (sinceEl) {
        if (node.since) {
          sinceEl.textContent = `${SERVICE_LABELS.since[docLang]}: ${formatSince(node.since)}`;
          sinceEl.hidden = false;
        } else {
          sinceEl.hidden = true;
        }
      }
      
      const edgesLabelEl = card.querySelector('[data-role="edges-label"]');
      const edgesEl = card.querySelector('[data-role="edges"]');
      if (edgesEl) edgesEl.innerHTML = '';
      if (edgesLabelEl) edgesLabelEl.hidden = true;
      if (edgesEl) edgesEl.hidden = true;
      
      if (node.edges_out && node.edges_out.length && edgesEl) {
        if (edgesLabelEl) {
          edgesLabelEl.textContent = SERVICE_LABELS.edges[docLang];
          edgesLabelEl.hidden = false;
        }
        edgesEl.hidden = false;
        node.edges_out.forEach((target) => {
          const chip = document.createElement('span');
          chip.textContent = target;
          edgesEl.appendChild(chip);
        });
      }
      
      card.addEventListener('click', () => toggleService(node.unit, node.status));
      return card;
    }

    function renderGraph(nodes, edges) {
      pcGraphEl.innerHTML = '';
      piGraphEl.innerHTML = '';
      
      if (!nodes.length) {
        pcGraphEl.innerHTML = '<div class="no-services c-card">Brak danych usług.</div>';
        piBlockEl.style.display = 'none';
        return;
      }
      
      // Split nodes by location (defensive: default to 'pc' if location is undefined)
      const pcNodes = nodes.filter(n => (n.location || 'pc') === 'pc');
      const piNodes = nodes.filter(n => (n.location || '') === 'pi');
      
      // Group by service group within each location
      function groupByServiceGroup(nodeList) {
        const groups = new Map();
        nodeList.forEach((node) => {
          const bucket = groups.get(node.group) || [];
          bucket.push(node);
          groups.set(node.group, bucket);
        });
        return Array.from(groups.entries()).sort((a, b) => a[0].localeCompare(b[0]));
      }
      
      // Render PC services
      if (pcNodes.length > 0) {
        pcBlockEl.style.display = 'block';
        const pcGroups = groupByServiceGroup(pcNodes);
        pcGroups.forEach(([group, items]) => {
          items.sort((a, b) => a.label.localeCompare(b.label));
          items.forEach((node) => {
            pcGraphEl.appendChild(createServiceCard(node, group));
          });
        });
      } else {
        pcBlockEl.style.display = 'block';
        pcGraphEl.innerHTML = '<div class="no-services c-card">Brak usług lokalnych.</div>';
      }
      
      // Render Pi services
      if (piNodes.length > 0) {
        piBlockEl.style.display = 'block';
        const piGroups = groupByServiceGroup(piNodes);
        piGroups.forEach(([group, items]) => {
          items.sort((a, b) => a.label.localeCompare(b.label));
          items.forEach((node) => {
            piGraphEl.appendChild(createServiceCard(node, group));
          });
        });
      } else {
        piBlockEl.style.display = 'none';
      }
    }

    async function seedAuditGraph() {
      await networkConfigPromise;
      const nodes = [
        { unit: 'panel.service', label: 'Panel WWW', status: 'active', group: 'rider-pc', location: 'pc', edges_out: ['redis', 'grafana'], since: '00:12:32' },
        { unit: 'redis', label: 'Redis', status: 'active', group: 'rider-pc', location: 'pc', edges_out: ['panel.service'], since: '04:20:10' },
        { unit: 'grafana', label: 'Grafana', status: 'active', group: 'rider-pc', location: 'pc', edges_out: ['prometheus'], since: '01:02:03' },
        { unit: 'prometheus', label: 'Prometheus', status: 'failed', group: 'rider-pc', location: 'pc', edges_out: [], since: '—' },
        { unit: 'pi.core', label: 'Rider-Pi Core', status: 'active', group: 'rider-pi', location: 'pi', edges_out: ['pi.voice', 'pi.vision'], since: '12:34:56' },
        { unit: 'pi.voice', label: 'Voice Provider', status: 'inactive', group: 'rider-pi', location: 'pi', edges_out: [], since: '—' },
        { unit: 'pi.vision', label: 'Vision Provider', status: 'active', group: 'rider-pi', location: 'pi', edges_out: ['pi.voice'], since: '02:45:00' },
        { unit: 'pi.queue', label: 'Task Queue', status: 'active', group: 'rider-pi', location: 'pi', edges_out: ['pi.core'], since: '05:15:00' },
      ];
      renderGraph(nodes, []);
      const busyCard = document.querySelector('[data-unit="prometheus"]');
      if (busyCard) {
        busyCard.classList.add('is-busy');
        busyCard.setAttribute('aria-busy', 'true');
      }
      const noServices = document.createElement('div');
      noServices.className = 'no-services c-card';
      noServices.textContent = 'Brak usług w tej grupie (audit)';
      piGraphEl.appendChild(noServices);
      setNetworkCardState('local-ip-card', '192.168.1.77', 'online', '—');
      const riderHost = networkConfig.riderPiHost || 'Rider-Pi';
      setNetworkCardState('rider-pi-card', riderHost, 'online', '12 ms');
      const internetHost = networkConfig.internetHost || defaultNetworkConfig.internetHost;
      setNetworkCardState('internet-card', internetHost, 'offline', 'n/a');
      logTerminal.innerHTML = `
        <div class="log-entry log-info"><span class="log-timestamp">[12:00:01]</span> <span class="log-level">INFO</span> Audit mode: sample data rendered.</div>
        <div class="log-entry log-warn"><span class="log-timestamp">[12:00:05]</span> <span class="log-level">WARN</span> Prometheus restarted (audit).</div>
        <div class="log-entry log-error"><span class="log-timestamp">[12:00:09]</span> <span class="log-level">ERROR</span> Voice provider offline (audit).</div>
      `;
      renderVersionInfo({ available: true, branch: 'audit/main', commit: 'abc1234', dirty: true, message: 'Audit seed commit' });
      statusEl.textContent = 'Tryb audytu CSS – dane przykładowe';
      statusEl.className = 'status-line c-statusbar is-success';
      await loadNetworkStatus();
    }

    function setNetworkCardState(cardId, hostText, state, latency) {
      const card = document.getElementById(cardId);
      if (!card) return;
      const indicator = card.querySelector('.network-status-indicator');
      const host = card.querySelector('.network-host');
      const latencyEl = card.querySelector('.network-latency');
      const value = card.querySelector('.network-value span:first-child');
      if (indicator) {
        indicator.classList.toggle('is-online', state === 'online');
        indicator.classList.toggle('is-offline', state === 'offline');
      }
      if (card) {
        card.classList.toggle('is-online', state === 'online');
        card.classList.toggle('is-offline', state === 'offline');
      }
      if (value) value.textContent = state === 'online' ? 'Online' : 'Offline';
      if (latencyEl) latencyEl.textContent = latency;
      if (host) host.textContent = hostText;
    }

    async function loadGraph() {
      try {
        statusEl.textContent = 'Aktualizuję status usług…';
        const resp = await fetch(`/api/services/graph?ts=${Date.now()}`, { cache: 'no-store' });
        if (!resp.ok) {
          throw new Error(`HTTP ${resp.status}`);
        }
        const payload = await resp.json();
        renderGraph(payload.nodes || [], payload.edges || []);
        const ts = payload.generated_at ? new Date(payload.generated_at * 1000) : new Date();
        statusEl.textContent = `Ostatnia aktualizacja: ${ts.toLocaleTimeString()}`;
      } catch (err) {
        console.error(err);
        statusEl.textContent = 'Błąd podczas pobierania danych usług.';
      }
    }

    if (auditMode) {
      seedAuditGraph().catch((err) => console.error('Audit seed failed:', err));
    } else {
      loadGraph();
      setInterval(loadGraph, 5000);
      networkConfigPromise.then(() => {
        startNetworkPolling();
      });
    }

    // Log Panel functionality
    const MAX_LOG_ENTRIES = 100;
    const SSE_RECONNECT_DELAY_MS = 3000;

    function formatTimestamp(ts) {
      const date = ts ? new Date(ts * 1000) : new Date();
      return date.toLocaleTimeString('pl-PL', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
    }

    function getLevelClass(level) {
      switch ((level || '').toUpperCase()) {
        case 'INFO':
          return 'log-info';
        case 'WARN':
        case 'WARNING':
          return 'log-warn';
        case 'ERROR':
          return 'log-error';
        default:
          return 'log-info';
      }
    }

    function addLogEntry(level, message, ts) {
      const entry = document.createElement('div');
      entry.className = `log-entry ${getLevelClass(level)}`;
      entry.innerHTML = `<span class="log-timestamp">[${formatTimestamp(ts)}]</span> <span class="log-level">${(level || 'INFO').toUpperCase()}</span> ${escapeHtml(message)}`;
      logTerminal.appendChild(entry);

      // Remove old entries if exceeding max
      while (logTerminal.children.length > MAX_LOG_ENTRIES) {
        logTerminal.removeChild(logTerminal.firstChild);
      }

      // Auto-scroll to bottom
      logTerminal.scrollTop = logTerminal.scrollHeight;
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function clearLog() {
      logTerminal.innerHTML = '';
      addLogEntry('INFO', 'Log wyczyszczony. Oczekiwanie na zdarzenia...', Date.now() / 1000);
    }

    logClearBtn.addEventListener('click', clearLog);

    // SSE connection for live log updates
    let eventSource = null;

    function connectSSE() {
      if (eventSource) {
        eventSource.close();
      }

      eventSource = new EventSource('/events');

      eventSource.onopen = function() {
        console.log('SSE connected');
      };

      eventSource.onmessage = function(event) {
        try {
          const payload = JSON.parse(event.data);
          if (payload.topic === 'system.log') {
            const data = payload.data || {};
            addLogEntry(data.level, data.message, payload.ts);
          }
        } catch (err) {
          console.error('Error parsing SSE event:', err);
        }
      };

      eventSource.onerror = function(err) {
        console.error('SSE error:', err);
        // Reconnect after delay
        setTimeout(connectSSE, SSE_RECONNECT_DELAY_MS);
      };
    }

    if (!auditMode) {
      connectSSE();
    }

    // Cleanup on page unload
    window.addEventListener('beforeunload', function() {
      if (eventSource) {
        eventSource.close();
      }
    });

    // Version info functionality
    function renderVersionInfo(data) {
      if (!data || !data.available) {
        versionInfoEl.innerHTML = '<span class="version-unavailable">v. Unknown</span>';
        versionInfoEl.title = 'Informacje o wersji niedostępne';
        return;
      }

      const branchBadge = document.createElement('span');
      branchBadge.className = 'version-branch';
      branchBadge.textContent = data.branch || 'unknown';

      const commitHash = document.createElement('span');
      commitHash.className = 'version-commit';
      commitHash.textContent = '#' + (data.commit || 'unknown');
      commitHash.title = 'Kliknij, aby skopiować hash';
      commitHash.style.cursor = 'pointer';
      commitHash.addEventListener('click', function(e) {
        e.stopPropagation();
        const hash = data.commit || '';
        if (hash && navigator.clipboard) {
          navigator.clipboard.writeText(hash).then(function() {
            showToast('Skopiowano hash: ' + hash, 'success');
          }).catch(function() {
            showToast('Nie udało się skopiować', 'error');
          });
        }
      });

      versionInfoEl.innerHTML = '';
      versionInfoEl.appendChild(branchBadge);
      versionInfoEl.appendChild(commitHash);

      if (data.dirty) {
        const dirtyBadge = document.createElement('span');
        dirtyBadge.className = 'version-dirty';
        dirtyBadge.textContent = 'Zmodyfikowany';
        dirtyBadge.title = 'Kod zmodyfikowany lokalnie (niezatwierdzone zmiany)';
        versionInfoEl.appendChild(dirtyBadge);
      }

      versionInfoEl.title = data.message ? ('Ostatni commit: ' + data.message) : 'Informacje o wersji';
    }

    async function loadVersionInfo() {
      try {
        const resp = await fetch('/api/status/version', { cache: 'no-store' });
        if (!resp.ok) {
          throw new Error('HTTP ' + resp.status);
        }
        const data = await resp.json();
        renderVersionInfo(data);
      } catch (err) {
        console.error('Failed to load version info:', err);
        versionInfoEl.innerHTML = '<span class="version-unavailable">v. Unknown</span>';
      }
    }

    // Load version info on page load (server caches for 60s, refresh on page reload)
    loadVersionInfo();

    // Network Status functionality
    const NETWORK_POLL_INTERVAL_MS = 10000; // 10 seconds as per requirements
    let lastRiderPiOnline = null;

    function updateNetworkUI(data) {
      // Update Local IP
      const localIpEl = document.getElementById('local-ip-value');
      if (localIpEl) {
        const preferredHost = networkConfig.pcHost || data.local_ip;
        localIpEl.textContent = preferredHost || '---.---.---.---';
      }

      // Update Rider-Pi status
      const riderPiStatusEl = document.getElementById('rider-pi-status');
      const riderPiLatencyEl = document.getElementById('rider-pi-latency');
      const riderPiIndicator = document.getElementById('rider-pi-indicator');
      const riderPiHostEl = document.getElementById('rider-pi-host');
      const riderPiCard = document.getElementById('rider-pi-card');

      if (data.rider_pi) {
        const isOnline = data.rider_pi.status === 'online';
        
        if (riderPiStatusEl) {
          riderPiStatusEl.textContent = isOnline ? 'Online' : 'Offline';
        }
        if (riderPiLatencyEl) {
          riderPiLatencyEl.textContent = isOnline && data.rider_pi.latency !== undefined 
            ? data.rider_pi.latency + 'ms' 
            : '';
        }
        if (riderPiIndicator) {
          riderPiIndicator.className = 'network-status-indicator ' + (isOnline ? 'is-online' : 'is-offline');
        }
        if (riderPiHostEl) {
          riderPiHostEl.textContent = data.rider_pi.host || '';
        }
        if (riderPiCard) {
          riderPiCard.className = 'network-card c-card ' + (isOnline ? 'is-online' : 'is-offline');
        }

        // Show warning toast if Rider-Pi goes offline
        if (lastRiderPiOnline !== null && lastRiderPiOnline && !isOnline) {
          showToast('Robot Offline - Rider-Pi niedostępny', 'error');
        }
        lastRiderPiOnline = isOnline;
      }

      // Update Internet status
      const internetStatusEl = document.getElementById('internet-status');
      const internetLatencyEl = document.getElementById('internet-latency');
      const internetIndicator = document.getElementById('internet-indicator');
      const internetCard = document.getElementById('internet-card');

      if (data.internet) {
        const isOnline = data.internet.status === 'online';
        
        if (internetStatusEl) {
          internetStatusEl.textContent = isOnline ? 'Online' : 'Offline';
        }
        if (internetLatencyEl) {
          internetLatencyEl.textContent = isOnline && data.internet.latency !== undefined 
            ? data.internet.latency + 'ms' 
            : '';
        }
        if (internetIndicator) {
          internetIndicator.className = 'network-status-indicator ' + (isOnline ? 'is-online' : 'is-offline');
        }
        if (internetCard) {
          internetCard.className = 'network-card c-card ' + (isOnline ? 'is-online' : 'is-offline');
        }
      }
    }

    async function loadNetworkStatus() {
      try {
        const resp = await fetch('/api/status/network', { cache: 'no-store' });
        if (!resp.ok) {
          throw new Error('HTTP ' + resp.status);
        }
        const data = await resp.json();
        updateNetworkUI(data);
      } catch (err) {
        console.error('Failed to load network status:', err);
        // Set all indicators to offline on error
        updateNetworkUI({
          local_ip: '---.---.---.---',
          rider_pi: { status: 'offline', host: networkConfig.riderPiHost || '' },
          internet: { status: 'offline', host: networkConfig.internetHost || defaultNetworkConfig.internetHost }
        });
      }
    }

    // Load network status on page load and poll every 10 seconds
    function startNetworkPolling() {
      loadNetworkStatus();
      setInterval(loadNetworkStatus, NETWORK_POLL_INTERVAL_MS);
    }
  </script>
  <script type="module" src="/web/assets/menu.js"></script>
  <script type="module" src="/web/assets/footer.js"></script>
</body>
</html>
